<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"leetao50.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
<meta property="og:type" content="website">
<meta property="og:title" content="InfoPool">
<meta property="og:url" content="https://leetao50.github.io/index.html">
<meta property="og:site_name" content="InfoPool">
<meta property="og:description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
<meta property="og:locale" content="zh_CN">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://leetao50.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>InfoPool</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">InfoPool</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">私人信息记录</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">记录信息来源网络，内容只为方便查找，非公开信息，非请勿入</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/09/04/css/MouseEvent%E4%BA%8B%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/04/css/MouseEvent%E4%BA%8B%E4%BB%B6/" class="post-title-link" itemprop="url">MouseEvent事件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-09-04 16:31:43 / 修改时间：17:15:30" itemprop="dateCreated datePublished" datetime="2023-09-04T16:31:43+08:00">2023-09-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>MouseEvent 接口指用户与指针设备（如鼠标）交互时发生的事件。使用此接口的常见事件包括：click、dblclick、mouseup、mousedown。</p>
<p>打印出来的 MouseEvent  如下：</p>
<p><img src="7755c89eb753af75544ad119bd7378d3c70c50e3021cf5e47cca86fbb1d8ac09.png" alt="图 0">  </p>
<p>经典的图:<br><img src="7a837e92eaefb8d797d585e08a05beffdbfea43f86717d43cf5f954ced967439.png" alt="图 1">  </p>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><ul>
<li><p>MouseEvent.pageX：实验性，鼠标指针相对于整个文档的 X 坐标；</p>
</li>
<li><p>MouseEvent.pageY：实验性，鼠标指针相对于整个文档的 Y 坐标；</p>
<blockquote>
<p>MouseEvent.page* 鼠标事件发生时，鼠标指针相对于整个文档左上角的水平距离和垂直距离。它受页面滚动的影响，页面滚动，它的值也会随之改变。</p>
</blockquote>
</li>
<li><p>MouseEvent.clientX:鼠标指针在点击元素（DOM）中的 X 坐标。</p>
</li>
<li><p>MouseEvent.clientY:鼠标指针在点击元素（DOM）中的 Y 坐标。</p>
</li>
</ul>
<blockquote>
<p>MouseEvent.client*: 鼠标指针相对于浏览器窗口左上角的水平距离和垂直距离。它不受页面滚动的影响，即使页面滚动，它的值也不会改变</p>
</blockquote>
<ul>
<li><p>MouseEvent.x 实验性，MouseEvent.clientX的别名。</p>
</li>
<li><p>MouseEvent.y 实验性，MouseEvent.clientY的别名。</p>
</li>
<li><p>MouseEvent.screenX：鼠标指针相对于全局（屏幕）的 X 坐标；</p>
</li>
<li><p>MouseEvent.screenY：鼠标指针相对于全局（屏幕）的 Y 坐标；</p>
</li>
<li><p>MouseEvent.offsetX：实验性，鼠标指针相对于目标节点内边位置的 X 坐标</p>
</li>
<li><p>MouseEvent.offsetY：实验性，鼠标指针相对于目标节点内边位置的 Y 坐标</p>
</li>
<li><p>MouseEvent.movementX:鼠标指针相对于最后mousemove事件位置的 X 坐标。</p>
</li>
<li><p>MouseEvent.movementY：鼠标指针相对于最后mousemove事件位置的 Y 坐标。</p>
</li>
<li><p>MouseEvent.altKey:当鼠标事件触发的时，如果 alt 键被按下，返回 true;</p>
</li>
<li><p>MouseEvent.button:当鼠标事件触发的时，如果鼠标按钮被按下（如果有的话），将会返回一个数值。0 表示左键，1 表示中键，2 表示右键</p>
</li>
<li><p>MouseEvent.buttons:当鼠标事件触发的时，如果多个鼠标按钮被按下（如果有的话），将会返回一个或者多个代表鼠标按钮的数字。</p>
</li>
<li><p>MouseEvent.ctrlKey:当鼠标事件触发时，如果 control 键被按下，则返回 true；</p>
</li>
<li><p>MouseEvent.metaKey:当鼠标事件触发时，如果 meta 键被按下，则返回 true；</p>
</li>
<li><p>MouseEvent.region：返回被点击事件影响的点击区域的 id，如果没有区域被影响则返回 null。</p>
</li>
<li><p>MouseEvent.relatedTarget：鼠标事件的次要目标（如果有的话）</p>
</li>
<li><p>MouseEvent.shiftKey：当鼠标事件触发时，如果 shift 键被按下，则返回 true；</p>
</li>
<li><p>MouseEvent.which 非标准，当鼠标事件触发时，表示被按下的按钮。</p>
</li>
<li><p>MouseEvent.mozInputSource 非标准，生成事件的类型（若干 MOZ_SOURCE_*常量如下列出）。可通过该属性获知鼠标事件是否由真实鼠标设备触发，亦或通过触摸事件触发（这可能影响处理坐标事件时的精确程度）。</p>
</li>
<li><p>MouseEvent.webkitForce 非标准，点击时施加的压力量。</p>
</li>
</ul>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><ol>
<li>当页面没有滚动时，MouseEvent.clientX 和 MouseEvent.pageX 的值相等。但当页面滚动时，MouseEvent.clientX 的值不变，而 MouseEvent.pageX 的值会随着页面滚动而增加或减少。</li>
<li>如果需要获得相对于事件目标元素的坐标，应该使用 MouseEvent.offsetX。如果需要获得相对于当前窗口的坐标，应该使用 MouseEvent.clientX。</li>
<li>preventDefault()：阻止事件的默认行为。例如，在链接上单击鼠标时，会跳转到链接指向的地址。如果在单击事件处理程序中调用了 preventDefault() 方法，则不会跳转到链接地址。</li>
<li>stopPropagation()：阻止事件进一步传播到其他元素。例如，在一个元素上发生的单击事件可能会传播到该元素的父元素或其他子元素。如果在单击事件处理程序中调用了 stopPropagation() 方法，则事件将不会进一步传播。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/09/01/css/pointer-events%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/01/css/pointer-events%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">pointer-events介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-09-01 17:30:06 / 修改时间：18:09:58" itemprop="dateCreated datePublished" datetime="2023-09-01T17:30:06+08:00">2023-09-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>pointer-events 属性是一个指针属性，是用于控制在什么条件下特定的图形元素可以成为指针事件的目标,当这个属性设置为none时，可以禁用 HTML 元素的 hover&#x2F;focus&#x2F;active 等动态效果,元素则不接收hover、click事件，由他后面的元素进行接收。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Keyword values */</span></span><br><span class="line"><span class="attribute">pointer-events</span>: auto;</span><br><span class="line"><span class="attribute">pointer-events</span>: none;</span><br><span class="line"><span class="attribute">pointer-events</span>: visiblePainted; <span class="comment">/* SVG only */</span></span><br><span class="line"><span class="attribute">pointer-events</span>: visibleFill;    <span class="comment">/* SVG only */</span></span><br><span class="line"><span class="attribute">pointer-events</span>: visibleStroke;  <span class="comment">/* SVG only */</span></span><br><span class="line"><span class="attribute">pointer-events</span>: visible;        <span class="comment">/* SVG only */</span></span><br><span class="line"><span class="attribute">pointer-events</span>: painted;        <span class="comment">/* SVG only */</span></span><br><span class="line"><span class="attribute">pointer-events</span>: fill;           <span class="comment">/* SVG only */</span></span><br><span class="line"><span class="attribute">pointer-events</span>: stroke;         <span class="comment">/* SVG only */</span></span><br><span class="line"><span class="attribute">pointer-events</span>: all;            <span class="comment">/* SVG only */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global values */</span></span><br><span class="line"><span class="attribute">pointer-events</span>: inherit;  从其父元素继承此属性</span><br><span class="line"><span class="attribute">pointer-events</span>: initial;  将此属性设置为其默认值</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="针对HTML元素"><a href="#针对HTML元素" class="headerlink" title="针对HTML元素"></a>针对HTML元素</h1><ul>
<li>none：该元素永远不会成为鼠标事件的 target。但是，当其后代元素的 pointer-events 属性指定其他值时，鼠标事件可以指向后代元素，在这种情况下，鼠标事件将在捕获或冒泡阶段触发父元素的事件侦听器 (鼠标的动作将不能被该元素及其子元素所捕获，但是能够被其父元素所捕获)。</li>
<li>auto：默认值，表示指针事件已启用；此时元素会响应指针事件，阻止这些事件在其下面的元素上触发。</li>
<li>inherit：将使用 pointer-events 元素的父级的值。</li>
</ul>
<p>除去SVG的独有属性，其他是对浏览器来说生效的属性值。</p>
<h1 id="未设置属性pointer-events"><a href="#未设置属性pointer-events" class="headerlink" title="未设置属性pointer-events"></a>未设置属性pointer-events</h1><p>未设置属性的情况下，在光标移动到box1可以正常的触发hover，并且移动到box1和box2重叠的部分也是触发box1的hover</p>
<p><img src="d98836850a8653b984b300e6e5293051c1359cb67ed1f38b5efd29a38cdca6a1.gif" alt="图 0">  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .box1 &#123;</span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 100px;</span><br><span class="line">      background: #04BBD4;</span><br><span class="line">      margin: 20px;</span><br><span class="line">      z-index: 3;</span><br><span class="line">    &#125;</span><br><span class="line">    .box2 &#123;</span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 100px;</span><br><span class="line">      background: #090A0E;</span><br><span class="line">      margin: -80px 40px 20px;</span><br><span class="line">      z-index: 2;</span><br><span class="line">      /* pointer-events: none; */</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .box1:hover &#123;</span><br><span class="line">      background:#078404;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .box2:hover &#123;</span><br><span class="line">      background:#E98889;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h1 id="设置box1属性pointer-events为none"><a href="#设置box1属性pointer-events为none" class="headerlink" title="设置box1属性pointer-events为none"></a>设置box1属性pointer-events为none</h1><p>设置属性的情况下，在光标移动到box1无法正常的触发hover，此时hover已经失效，移动到box1和box2重叠的部分则是触发box2的hover</p>
<p><img src="96c76495ee7c4a08932ebd3b3ba22f5f.gif" alt="图 1">  </p>
<h1 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h1><p>父元素如果设置了pointer-event:none 并不意味着父元素上的事件侦听器永远不会被触发，当子元素上设置pointer-event值不是none,那么都可以通过事件传播机制来触发父元素上的事件。</p>
<p>该属性也可用来提高滚动时的帧频。的确，当滚动时，鼠标悬停在某些元素上，则触发其上的 hover 效果，然而这些影响通常不被用户注意，并多半导致滚动出现问题。对body元素应用pointer-events：none，禁用了包括hover在内的鼠标事件，从而提高滚动性能。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/08/24/angular/Angular%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/24/angular/Angular%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB/" class="post-title-link" itemprop="url">Angular路由守卫</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-08-24 10:23:51 / 修改时间：14:06:25" itemprop="dateCreated datePublished" datetime="2023-08-24T10:23:51+08:00">2023-08-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我们使用Angular Guards来控制用户是否可以导航到或离开当前路由。</p>
<p>我们使用路由守卫的常见场景之一是身份验证。我们希望我们的应用程序能够阻止未经授权的用户访问受保护的路由。当用户试图导航到受保护的路由时，angular调用CanActivate。然后，我们挂接到CanActivate防护程序，并使用身份验证服务来检查用户是否有权使用路由，如果没有，我们可以将用户重定向到登录页面。</p>
<h1 id="守卫路由的作用"><a href="#守卫路由的作用" class="headerlink" title="守卫路由的作用"></a>守卫路由的作用</h1><ul>
<li>确认导航操作</li>
<li>询问是否在离开视图之前进行数据保存</li>
<li>允许特定用户访问应用程序的某些部分</li>
<li>在导航到新路由之前验证路由参数</li>
<li>在显示组件之前获取一些数据</li>
</ul>
<h1 id="路由守卫类型"><a href="#路由守卫类型" class="headerlink" title="路由守卫类型"></a>路由守卫类型</h1><p>Angular Router支持五种不同的路由守卫，您可以使用它们来保护路由</p>
<ul>
<li>CanActivate：决定是否可以激活路由（或使用组件）。在用户未被授权导航到目标组件的情况下，此保护非常有用。或者用户可能没有登录到系统</li>
<li>CanDeactivate：决定用户是否可以离开组件（导航离开当前组件）。在用户可能有一些未保存的挂起更改的情况下，此路由非常有用。</li>
<li>Resolve：延迟路由的激活，直到某些任务完成。在激活路由之前，您可以使用Resolve守卫从后端API获取数据</li>
<li>CanLoad：防止加载延迟加载模块。我们通常在不希望未经授权的用户看到模块的源代码时使用此保护。CanLoad与CanActivate类似，但有一点不同。CanActivate防止访问特定的路由。CanLoad防止整个延迟加载模块被下载，从而保护该模块中的所有路由。</li>
<li>CanActivateChild：确定是否可以激活子路由。CanActivateChild与CanActivate非常相似。我们将CanActivateChild应用于父路由。每当用户试图导航到其任何子路由时，Angular都会调用CanActivateChild。这使我们能够检查某些情况，并决定是继续导航还是取消导航。</li>
</ul>
<h1 id="如何创建Angular路由守卫"><a href="#如何创建Angular路由守卫" class="headerlink" title="如何创建Angular路由守卫"></a>如何创建Angular路由守卫</h1><ul>
<li><p>建立Guard服务。</p>
<blockquote>
<p>@Injectable()<br>export class ProductGuardService implements CanActivate {}</p>
</blockquote>
</li>
<li><p>在服务中实现Guard方法</p>
<blockquote>
<p>canActivate(): boolean {<br>  &#x2F;&#x2F; Check weather the route can be activated;<br>  return true;<br>  &#x2F;&#x2F; or false if you want to cancel the navigation;<br>  }</p>
</blockquote>
</li>
<li><p>在根模块中注册Guard服务</p>
<blockquote>
<p>providers: [ProductService,ProductGuardService]</p>
</blockquote>
</li>
<li><p>更新路由以使用Guard服务</p>
<blockquote>
<p>{ path: ‘product’, component: ProductComponent, canActivate : [ProductGuardService] }</p>
</blockquote>
</li>
</ul>
<h1 id="守卫路由调用顺序"><a href="#守卫路由调用顺序" class="headerlink" title="守卫路由调用顺序"></a>守卫路由调用顺序</h1><p>添加路由守卫语法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">path</span>: <span class="string">&#x27;product&#x27;</span>, component,        </span><br><span class="line">    canActivate : any[],        </span><br><span class="line">    <span class="attr">canActivateChild</span>: any[],       </span><br><span class="line">    <span class="attr">canDeactivate</span>: any[],       </span><br><span class="line">    <span class="attr">canLoad</span>: any[],       </span><br><span class="line">    <span class="attr">resolve</span>: any[] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一条路由可以有多个守卫保护，并且可以在路由层次结构的每个级别都有守卫保护。</p>
<ul>
<li>始终首先检查CanDeactivate（）和CanActivateChild（）防护。检查从最深的子路径开始到顶部。</li>
<li>接下来将检查CanActivate（）保护，并从顶部开始检查最深的子路由。</li>
<li>接下来调用CanLoad（），如果要异步加载功能模块。</li>
<li>Resolve（）Guard是最后调用的。</li>
</ul>
<p>如果任何防护返回false，则Angular路由器将取消导航。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/08/23/angular/Angular%E8%B7%AF%E7%94%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/23/angular/Angular%E8%B7%AF%E7%94%B1/" class="post-title-link" itemprop="url">Angular路由</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-23 11:42:36" itemprop="dateCreated datePublished" datetime="2023-08-23T11:42:36+08:00">2023-08-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-08-24 10:24:13" itemprop="dateModified" datetime="2023-08-24T10:24:13+08:00">2023-08-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h1><p>路由允许您从应用程序的一部分移动到另一部分，或者从一个视图移动到另一个视图。</p>
<p>在Angular中，路由由Angular路由器模块处理。</p>
<p>路由器是Angular中的一个独立模块。它在@angular&#x2F;router包中。Angular Router提供了应用程序视图中导航所需的服务和指令。</p>
<p>使用Angular Router，您可以</p>
<ul>
<li>通过在地址栏中键入URL导航到特定视图</li>
<li>将可选参数（查询参数）传递到视图</li>
<li>将可单击元素绑定到视图，并在用户执行应用程序任务时加载视图</li>
<li>处理浏览器的后退和前进按钮</li>
<li>允许您动态加载视图</li>
<li>使用路由保护程序保护路由不受未经授权的用户的攻击</li>
</ul>
<h1 id="Angular路由组件"><a href="#Angular路由组件" class="headerlink" title="Angular路由组件"></a>Angular路由组件</h1><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p>Angular  Router 是服务(service)（Angular Router API），它允许用户在执行应用程序任务时从一个组件导航到下一个组件，如单击菜单链接和按钮，或单击浏览器上的后退&#x2F;前进按钮。我们可以访问router对象，并使用其方法（如navigate（）或navigateByUrl（））来导航到路由.</p>
<h2 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h2><p>当用户单击链接或将URL粘贴到浏览器地址栏时，Route 告诉Angular Router要显示哪个视图。每个Route都由一个路径和映射到的组件组成。Router对象使用Route解析并构建最终的URL.</p>
<p><img src="516766e8960da632098beec85bb388cea2abc787145632fefa2a6b4b16f2792e.png" alt="图 0">  </p>
<h2 id="Routes"><a href="#Routes" class="headerlink" title="Routes"></a>Routes</h2><p>Routes是应用程序支持的Route对象的数组</p>
<h2 id="RouterOutlet"><a href="#RouterOutlet" class="headerlink" title="RouterOutlet"></a>RouterOutlet</h2><p>RouterOutlet是一个用作占位符的指令（＜router-outlet＞），路由器应在其中显示视图</p>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>router-outlet</p>
<h3 id="模板变量参考手册"><a href="#模板变量参考手册" class="headerlink" title="模板变量参考手册"></a>模板变量参考手册</h3><p>outlet #myTemplateVar&#x3D;”outlet”</p>
<p>每当新组件实例化之后，路由出口就会发出一个激活事件；在销毁时则发出取消激活的事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-outlet</span><br><span class="line">  (activate)=&#x27;onActivate($event)&#x27;</span><br><span class="line">  (deactivate)=&#x27;onDeactivate($event)&#x27;</span><br><span class="line">  (attach)=&#x27;onAttach($event)&#x27;</span><br><span class="line">  (detach)=&#x27;onDetach($event)&#x27;&gt;&lt;/router-outlet&gt;</span><br></pre></td></tr></table></figure>

<p>每个出口可以具有唯一的名称，该 name 由可选的 name 属性确定。该名称不能动态设置或更改。如果未设置，则默认值为 “primary”。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-outlet</span>&gt;</span><span class="tag">&lt;/<span class="name">router-outlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-outlet</span> <span class="attr">name</span>=<span class="string">&#x27;left&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-outlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-outlet</span> <span class="attr">name</span>=<span class="string">&#x27;right&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-outlet</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">path</span>: &lt;base-path&gt;, <span class="attr">component</span>: &lt;component&gt;, <span class="attr">outlet</span>: &lt;target_outlet_name&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>使用命名的出口和辅助路由，你可以在同一 RouterLink 指令中定位多个出口。</p>
<p>路由器在导航树中跟踪每个命名出口的单独分支，并在 URL 中生成该树的表示形式。辅助路由的 URL 使用以下语法同时指定主要路由和辅助路由：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://base-path/<span class="built_in">primary-route-path</span>(outlet-name:route-path)</span><br></pre></td></tr></table></figure>

<h2 id="RouterLink"><a href="#RouterLink" class="headerlink" title="RouterLink"></a>RouterLink</h2><p>RouterLink是一个将HTML元素绑定到Route的指令。单击绑定到RouterLink的HTML元素，将导航到Route。RouterLink可能包含要传递给路由组件的参数。</p>
<p>给定路由配置 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123; <span class="attr">path</span>: <span class="string">&#x27;user/:name&#x27;</span>, <span class="attr">component</span>: <span class="title class_">UserCmp</span> &#125;]</span><br></pre></td></tr></table></figure>
<p>，以下内容将创建一个到该路由的静态链接：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">&quot;/user/bob&quot;</span>&gt;</span>link to user component<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你也可以使用动态值来生成链接。对于动态链接，请传递路径段数组，然后传递每个段的参数。比如，<br><code>[&#39;/team&#39;, teamId, &#39;user&#39;, userName, &#123;details: true&#125;] </code>生成到 <code>/team/11/user/bob;details=true</code>。</p>
<p>多个静态段可以合并为一个词，并与动态段组合。比如，<code>[&#39;/team/11/user&#39;, userName, &#123;details: true&#125;]</code></p>
<p>你提供给链接的输入将被视为当前 URL 的增量。比如，假设当前 URL 是 <code>/user/(box//aux:team)</code>。则链接 <code>&lt;a [routerLink]=&quot;[&#39;/user/jim&#39;]&quot;&gt;Jim&lt;/a&gt; </code>会创建<code> URL /user/(jim//aux:team)</code> 。</p>
<p>你可以在链接中使用绝对或相对路径、设置查询参数、控制如何处理参数以及保留导航状态的历史记录。</p>
<h2 id="RouterLinkActive"><a href="#RouterLinkActive" class="headerlink" title="RouterLinkActive"></a>RouterLinkActive</h2><p>RouterLinkActive是用于从绑定到RouterLink的HTML元素中添加或删除CSS样式的指令。使用此指令，我们可以根据当前RouterState切换RouterLinks的CSS样式</p>
<h2 id="ActivatedRoute"><a href="#ActivatedRoute" class="headerlink" title="ActivatedRoute"></a>ActivatedRoute</h2><p>ActivatedRoute是一个对象，表示与加载的组件关联的当前激活的路由。</p>
<h2 id="RouterState"><a href="#RouterState" class="headerlink" title="RouterState"></a>RouterState</h2><h1 id="如何使用-Angular路由"><a href="#如何使用-Angular路由" class="headerlink" title="如何使用 Angular路由"></a>如何使用 Angular路由</h1><p>以下几步来配置使用路由</p>
<ul>
<li>设置<base href></li>
<li>定义视图的管线</li>
<li>向Routes注册路由器服务</li>
<li>将HTML元素操作映射到路由</li>
<li>选择要显示视图的位置</li>
</ul>
<h1 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h1><p>在Angular中支持两种不同的路由策略。一个是PathlocationStrategy，另一个是HashLocationStrategy。HashLocationStrategy使用Hash风格的路由，而PathlocationStrategy使用HTML5路由。</p>
<ul>
<li>HashLocationStrategy： URL格式 <a target="_blank" rel="noopener" href="http://localhost:4200/#/product">http://localhost:4200/#/product</a></li>
<li>PathLocationStrategy：URL格式 <a target="_blank" rel="noopener" href="http://localhost:4200/product">http://localhost:4200/product</a></li>
</ul>
<p>我们建议使用HTML5样式（PathLocationStrategy）作为定位策略。因为</p>
<ul>
<li>它产生干净和SEO友好的URL，用户更容易理解和记住。</li>
<li>可以利用服务器端渲染，这将使我们的应用程序加载更快，方法是在将页面交付给客户端之前先在服务器中渲染页面</li>
</ul>
<p>只有当软件必须支持较旧的浏览器时，才使用哈希位置策略。</p>
<h1 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h1><h2 id="定义路由"><a href="#定义路由" class="headerlink" title="定义路由"></a>定义路由</h2><p>我们可以通过添加’&#x2F;:’和一个占位符（id）来定义参数，如下所示</p>
<p><code>&#123; path: &#39;product/:id&#39;, component: ProductDetailComponent &#125;</code></p>
<p>其中id是路由的动态部分。<br>现在，上面的路径与URL &#x2F;product&#x2F;1、&#x2F;product&#x2F;2等相匹配。</p>
<p>如果您有多个参数，那么您可以通过继续添加占位符来扩展它</p>
<p><code>&#123; path: &#39;product/:id/:id1/:id2&#39;, component: ProductDetailComponent &#125;</code></p>
<p>名称id、id1和id2是参数的占位符。我们将在检索参数值时使用它们。</p>
<h2 id="定义导航"><a href="#定义导航" class="headerlink" title="定义导航"></a>定义导航</h2><p>我们现在需要提供带有路径和路由参数的routerLink指令。通过将产品的id作为第二个元素添加到routerLink参数数组中来完成，如下所示</p>
<p><code>&lt;a [routerLink]=&quot;[&#39;/Product&#39;, ‘2’]&quot;&gt;&#123;&#123;product.name&#125;&#125; &lt;/a&gt;</code></p>
<p>编译为URL &#x2F;product&#x2F;2</p>
<p><code>&lt;a [routerLink]=&quot;[&#39;/Product&#39;, product.productID]&quot;&gt;&#123;&#123;product.name&#125;&#125; &lt;/a&gt;</code></p>
<p>动态地从产品对象中获取id的值。</p>
<p>您也可以使用路由器对象的导航方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">goProduct</span>(<span class="params"></span>) &#123;     </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">router</span>.<span class="title function_">navigate</span>(</span><br><span class="line">        [<span class="string">&#x27;/products&#x27;</span>. product.<span class="property">productID</span>] &#125;</span><br><span class="line">    ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取路由参数"><a href="#获取路由参数" class="headerlink" title="获取路由参数"></a>获取路由参数</h2><h3 id="ActviatedRoute"><a href="#ActviatedRoute" class="headerlink" title="ActviatedRoute"></a>ActviatedRoute</h3><p>ActivatedRoute是一项服务，用于跟踪与加载的组件相关联的当前激活的路由。</p>
<p><code>constructor(private _Activatedroute:ActivatedRoute)</code></p>
<p>ActviatedRoute路由提供了两个属性含Route参数。</p>
<ul>
<li>ParamMap</li>
<li>Params</li>
</ul>
<h4 id="ParamMap"><a href="#ParamMap" class="headerlink" title="ParamMap"></a>ParamMap</h4><p>Angular将所有路由参数的映射添加到ParamMap对象中，该对象可以从ActivatedRoute服务访问</p>
<p>ParamMap有三种方法，可以更容易地使用参数。</p>
<ul>
<li>get方法检索给定参数的值。</li>
<li>getAll方法检索所有参数</li>
<li>has 如果ParamMap包含给定的参数，则has方法返回true，否则返回false</li>
</ul>
<h4 id="Params"><a href="#Params" class="headerlink" title="Params"></a>Params</h4><p>ActviatedRoute还维护“参数数组“Params。Params数组是一个参数值列表，按名称进行索引。</p>
<h2 id="读取参数"><a href="#读取参数" class="headerlink" title="读取参数"></a>读取参数</h2><p>使用ActivatedRoute有两种方法从ParamMap对象获取参数值。</p>
<ul>
<li>使用ActivatedRoute的Snapshot属性</li>
<li>订阅ActivatedRoute的paramMap或params observable属性</li>
</ul>
<h3 id="使用-Snapshot"><a href="#使用-Snapshot" class="headerlink" title="使用 Snapshot"></a>使用 Snapshot</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">id</span>=<span class="variable language_">this</span>.<span class="property">_Activatedroute</span>.<span class="property">snapshot</span>.<span class="property">paramMap</span>.<span class="title function_">get</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">id</span>=<span class="variable language_">this</span>.<span class="property">_Activatedroute</span>.<span class="property">snapshot</span>.<span class="property">params</span>[<span class="string">&quot;id&quot;</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用-Observable"><a href="#使用-Observable" class="headerlink" title="使用 Observable"></a>使用 Observable</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">_Activatedroute</span>.<span class="property">paramMap</span>.<span class="title function_">subscribe</span>(<span class="function"><span class="params">paramMap</span> =&gt;</span> &#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = paramMap.<span class="title function_">get</span>(<span class="string">&#x27;id&#x27;</span>); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">_Activatedroute</span>.<span class="property">params</span>.<span class="title function_">subscribe</span>(<span class="function"><span class="params">params</span> =&gt;</span> &#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = params[<span class="string">&#x27;id&#x27;</span>]; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="ActivatedRoute-1"><a href="#ActivatedRoute-1" class="headerlink" title="ActivatedRoute"></a>ActivatedRoute</h1><p>ActivatedRoute服务提供了大量有用的信息，包括：</p>
<p>url：此属性返回url Segment对象的数组，每个对象描述url中与当前路由匹配的单个段。<br>params：此属性返回一个params对象，该对象描述按名称索引的URL参数。<br>queryParams：此属性返回一个Params对象，该对象描述按名称索引的URL查询参数。<br>fragment：此属性返回一个包含URL片段的字符串。<br>snapshot：此路由的初始快照<br>data：包含为路线提供的数据对象的Observable<br>component：路由的组件。这是一个常数<br>outlet：用于渲染路由的RouterOutlet的名称。对于未命名的出口，为primary。<br>routeConfig：用于包含原始路径的路由的路由配置。<br>parent:ActivatedRoute，包含使用子路由时来自父路由的信息。<br>firstChild：包含子路由列表中的第一个ActivatedRoute。<br>children：包含在当前路线下激活的所有子路线<br>pathFromRoot：从路由器状态树的根到该路由的路径</p>
<h1 id="路由Query参数"><a href="#路由Query参数" class="headerlink" title="路由Query参数"></a>路由Query参数</h1><p>Query参数是在 URL中的 ？右侧的键值对，多个Query参数之间由&amp;分隔。</p>
<p><code>/product?page=2&amp;filter=all</code></p>
<p>在上面的例子中，page&#x3D;2和filter&#x3D;all是Query参数。它包含两个Query参数。一个是Page，其值为2，另一个是Filter，其值是all。</p>
<h2 id="添加Query参数"><a href="#添加Query参数" class="headerlink" title="添加Query参数"></a>添加Query参数</h2><p>Query参数不是路由的一部分。因此，您不会像路由参数那样在 routes 中定义它们。有两种方法可以将Query参数传递给路由</p>
<ul>
<li>使用routerlink指令</li>
<li>使用router.navigation方法。</li>
<li>使用router.navigateByUrl方法</li>
</ul>
<h2 id="在模板中使用-routerlink-指令"><a href="#在模板中使用-routerlink-指令" class="headerlink" title="在模板中使用 routerlink 指令"></a>在模板中使用 routerlink 指令</h2><p>我们使用routerlink指令的queryParams属性来添加Query参数。我们将此指令添加到模板文件中。</p>
<p><code>&lt;a [routerLink]=&quot;[&#39;product&#39;]&quot; [queryParams]=&quot;&#123; page:2 &#125;&quot;&gt;Page 2&lt;/a&gt;</code></p>
<p>路由器将URL构造为</p>
<p><code>/product?page=2</code></p>
<p>您可以传递多个Query参数，如下所示</p>
<p><code>&lt;a [routerLink]=&quot;[&#39;products&#39;]&quot; [queryParams]=&quot;&#123; color:&#39;blue&#39; , sort:&#39;name&#39;&#125;&quot;&gt;Products&lt;/a&gt;</code></p>
<p>路由器将URL构造为</p>
<p><code>/products?color=blue&amp;sort=name</code></p>
<h2 id="在组件中使用-router-navigate"><a href="#在组件中使用-router-navigate" class="headerlink" title="在组件中使用 router.navigate"></a>在组件中使用 router.navigate</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">goTo</span>(<span class="params"></span>) &#123;     </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">router</span>.<span class="title function_">navigate</span>(</span><br><span class="line">        [<span class="string">&#x27;/products&#x27;</span>], </span><br><span class="line">        &#123; <span class="attr">queryParams</span>: &#123; <span class="attr">page</span>: <span class="number">2</span>, <span class="attr">sort</span>:<span class="string">&#x27;name&#x27;</span>&#125; &#125;</span><br><span class="line">    ); </span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>路由器将URL构造为</p>
<p><code>/products?page=2&amp;sort=name</code></p>
<h2 id="在组件中使用-router-navigateByUrl"><a href="#在组件中使用-router-navigateByUrl" class="headerlink" title="在组件中使用 router.navigateByUrl"></a>在组件中使用 router.navigateByUrl</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">router</span>.<span class="title function_">navigateByUrl</span>(<span class="string">&#x27;product?pageNum=2&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="读取-路由Query参数"><a href="#读取-路由Query参数" class="headerlink" title="读取 路由Query参数"></a>读取 路由Query参数</h2><p>读取Query参数类似于读取Router参数。有两种方法可以检索查询参数。</p>
<ul>
<li>订阅queryParamMap或queryParams observable</li>
<li>使用snapshot属性的queryParamMap或queryParams属性</li>
</ul>
<p>以上两项都是ActivatedRoute服务的一部分。因此，我们需要将它注入到我们的组件类中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">sub</span> = <span class="variable language_">this</span>.<span class="property">Activatedroute</span>.<span class="property">queryParamMap</span></span><br><span class="line">       .<span class="title function_">subscribe</span>(<span class="function"><span class="params">params</span> =&gt;</span> &#123;</span><br><span class="line">             <span class="variable language_">this</span>.<span class="property">pageNum</span> = +params.<span class="title function_">get</span>(<span class="string">&#x27;pageNum&#x27;</span>)||<span class="number">0</span>;     </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">sub</span> = <span class="variable language_">this</span>.<span class="property">Activatedroute</span>.<span class="property">queryParams</span></span><br><span class="line">       .<span class="title function_">subscribe</span>(<span class="function"><span class="params">params</span> =&gt;</span> &#123;</span><br><span class="line">             <span class="variable language_">this</span>.<span class="property">pageNum</span> = +params.[<span class="string">&#x27;pageNum&#x27;</span>]||<span class="number">0</span>;     </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">Activatedroute</span>.<span class="property">snapshot</span></span><br><span class="line">       .<span class="property">queryParamMap</span>.<span class="title function_">get</span>(<span class="string">&#x27;pageNum&#x27;</span>)||<span class="number">0</span>;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">Activatedroute</span>.<span class="property">snapshot</span></span><br><span class="line">       .<span class="property">queryParams</span>[<span class="string">&#x27;pageNum&#x27;</span>]||<span class="number">0</span>;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/07/28/css/Grid%E5%B8%83%E5%B1%80%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/28/css/Grid%E5%B8%83%E5%B1%80%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">Grid布局基础概念</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-07-28 11:45:19 / 修改时间：17:48:05" itemprop="dateCreated datePublished" datetime="2023-07-28T11:45:19+08:00">2023-07-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="网格容器"><a href="#网格容器" class="headerlink" title="网格容器"></a>网格容器</h1><p>我们通过在元素上声明 display：grid 或 display：inline-grid 来创建一个网格容器。一旦我们这样做，这个元素的所有直系子元素将成为网格元素。</p>
<h1 id="网格轨道"><a href="#网格轨道" class="headerlink" title="网格轨道"></a>网格轨道</h1><p>我们通过 grid-template-columns 和 grid-template-rows 属性来定义网格中的行和列。这些属性定义了网格的轨道。一个网格轨道就是网格中任意两条线之间的空间。</p>
<h2 id="fr-单位"><a href="#fr-单位" class="headerlink" title="fr 单位"></a>fr 单位</h2><p>轨道可以使用任何长度单位进行定义。网格还引入了一个另外的长度单位来帮助我们创建灵活的网格轨道。新的fr单位代表网格容器中可用空间的一等份。下一个网格定义将创建三个相等宽度的轨道，这些轨道会随着可用空间增长和收缩。</p>
<h1 id="网格线"><a href="#网格线" class="headerlink" title="网格线"></a>网格线</h1><p>应该注意的是，当我们定义网格时，我们定义的是网格轨道，而不是网格线。Grid 会为我们创建编号的网格线来让我们来定位每一个网格元素。</p>
<p>网格线的编号顺序取决于文章的书写模式。在从左至右书写的语言中，编号为 1 的网格线位于最左边。在从右至左书写的语言中，编号为 1 的网格线位于最右边。网格线也可以被命名，我们将在稍后的教程中看到如何完成这一操作。</p>
<h1 id="网格间距"><a href="#网格间距" class="headerlink" title="网格间距"></a>网格间距</h1><p>在两个网格单元之间的 网格横向间距 或 网格纵向间距 可使用 grid-column-gap 和 grid-row-gap  属性来创建，或者直接使用两个合并的缩写形式 grid-gap。间距使用的空间会在 使用弹性长度 fr 的轨道的空间计算前就被留出来，间距的尺寸定义行为和普通轨道一致，但不同的是你不能向其中插入任何内容。</p>
<h1 id="使用-z-index-控制层级"><a href="#使用-z-index-控制层级" class="headerlink" title="使用 z-index 控制层级"></a>使用 z-index 控制层级</h1><p>多个网格项目可以占用同一个网格单位。如果我们回到之前根据网格线编号放置网格项目的话，我们可以更改此项来使两个网格项目重叠，其覆盖顺序遵循文档流的原始顺序（后来居上）。</p>
<p>我们可以在网格项目发生重叠时使用 z-index 属性控制重叠的顺序——就像放置网格项目一样。如果我们给 box2 设定一个低于 box1 的 z-index 值的话，box2 将会显示在 box1 的下方。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/07/26/css/flex%E5%85%83%E7%B4%A0%E5%9C%A8%E4%B8%BB%E8%BD%B4%E4%B8%8A%E7%9A%84%E6%AF%94%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/26/css/flex%E5%85%83%E7%B4%A0%E5%9C%A8%E4%B8%BB%E8%BD%B4%E4%B8%8A%E7%9A%84%E6%AF%94%E4%BE%8B/" class="post-title-link" itemprop="url">flex元素在主轴上的比例</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-07-26 18:57:30" itemprop="dateCreated datePublished" datetime="2023-07-26T18:57:30+08:00">2023-07-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-27 17:40:50" itemprop="dateModified" datetime="2023-07-27T17:40:50+08:00">2023-07-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我们将探索应用于弹性（flex）元素的三个属性，它们能使我们在主轴方向上控制弹性元素的尺寸和伸缩性——flex-grow、flex-shrink 和 flex-basis。</p>
<p>这三个属性控制弹性元素的以下几个方面的灵活性：</p>
<ul>
<li>flex-grow：该元素(拉伸)获得多少正可用空间</li>
<li>flex-shrink：该元素(收缩)要消除多少负可用空间</li>
<li>flex-basis：在该元素未拉伸和收缩之前，它所占空间</li>
</ul>
<p>在考虑 flex 属性如何在主轴方向上控制比率之前，有一些概念值得我们去深究。这涉及到弹性元素在任何伸缩之前的自然尺寸，以及可用空间（free space）的概念。</p>
<h1 id="弹性元素的尺寸"><a href="#弹性元素的尺寸" class="headerlink" title="弹性元素的尺寸"></a>弹性元素的尺寸</h1><p>在 CSS 中还有 min-content 和 max-content 这两个概念；这两个关键字可以用来代替长度单位。</p>
<ul>
<li>min-content：本质上讲，就是字符串中最长的单词长度决定的大小。</li>
<li>max-content：代表了内容的最大宽度或最大高度。对于文本内容而言，这意味着内容即便溢出也不会被换行。</li>
</ul>
<h1 id="正负可用空间"><a href="#正负可用空间" class="headerlink" title="正负可用空间"></a>正负可用空间</h1><p>当一个弹性容器有正可用空间时，它就有更多的空间用于在容器内显示弹性元素。比如说，如果我们有 500px 宽的容器，flex-direction 属性值为 row，三个 100px 宽的弹性元素，那么我们还有 200px 的正可用空间，如果我们想要填充整个容器，则可将其分配到元素中。</p>
<p><img src="/../../../images/013a3fcd15f1a891c7f058aea7734ce4fdaa5e25b84b142c6cf36af095021eee.png" alt="图 0">  </p>
<p>当弹性元素的自然尺寸加起来比弹性容器内的可用空间大时，我们产生了负可用空间。比如我们有一个像上面那样的 500px 宽的容器，但是三个弹性元素每个都为 200px 宽，那我们就一共需要 600px 宽，因此就有了 100px 的负可用空间。这可以从弹性元素中删除以使其能适应容器。</p>
<p><img src="/../../../images/77d3b003f9cdced2c3bc092a7beeb5fcbe5e02dc8af2c236f1423fb1e3c5f030.png" alt="图 1">  </p>
<h1 id="flex-basis-属性"><a href="#flex-basis-属性" class="headerlink" title="flex-basis 属性"></a>flex-basis 属性</h1><p>flex-basis 属性在任何空间分配发生之前初始化弹性元素的尺寸。此属性的初始值为 auto。如果 flex-basis 设置为 auto，浏览器会先检查元素的主尺寸是否设置了绝对值再计算出它们的初始值。比如说你已经给你的元素设置了 200px 的宽，则 200px 就是这个元素的 flex-basis。</p>
<p>如果你的元素为自动调整大小，则 auto 会解析为其内容的大小。此时你所熟知的 min-content 和 max-content 大小会变得有用，弹性盒子会将元素的 max-content 大小作为 flex-basis。</p>
<p>空间分配时，如果你想要弹性盒子完全忽略元素的尺寸就需要设置 flex-basis 为 0。这显式地说明弹性盒子可用抢占所有空间，并按比例进行分配。</p>
<p>flex-basis属性会覆盖项目的width属性（当主轴方向水平时）或height属性（当主轴方向垂直时），然而，flex-basis属性仍然受max-width&#x2F;max-height和min-width&#x2F;min-height属性的约束。</p>
<h1 id="flex-grow-属性"><a href="#flex-grow-属性" class="headerlink" title="flex-grow 属性"></a>flex-grow 属性</h1><p>flex-grow 属性指定了弹性增长因子（flex grow factor），这决定了在分配正可用空间时，弹性元素相对于弹性容器中的其余弹性元素的增长程度。</p>
<p>如果 flex-grow 的值全部相同，并且在弹性容器中还有正可用空间，那么它就会被平均地分配给所有元素。</p>
<h1 id="flex-shrink-属性"><a href="#flex-shrink-属性" class="headerlink" title="flex-shrink 属性"></a>flex-shrink 属性</h1><p>flex-shrink 属性指定了弹性收缩因子（flex shrink factor），它确定在分配负可用空间时，弹性元素相对于弹性容器中其余弹性元素收缩的程度。</p>
<h1 id="掌握弹性元素的大小"><a href="#掌握弹性元素的大小" class="headerlink" title="掌握弹性元素的大小"></a>掌握弹性元素的大小</h1><h2 id="什么设置了元素的基本大小？"><a href="#什么设置了元素的基本大小？" class="headerlink" title="什么设置了元素的基本大小？"></a>什么设置了元素的基本大小？</h2><ol>
<li>flex-basis 设置为 auto，且元素设置了宽度，元素的大小将会基于设置的宽度。</li>
<li>flex-basis 设置为 auto 或 content（在支持的浏览器中），元素的大小为原始大小。</li>
<li>flex-basis 设置为 非0的长度，那这就是元素的大小。</li>
<li>flex-basis 设为了 0，则元素的大小不在空间分配计算的考虑之内。</li>
</ol>
<h2 id="我们有可用空间吗？"><a href="#我们有可用空间吗？" class="headerlink" title="我们有可用空间吗？"></a>我们有可用空间吗？</h2><ol>
<li>元素没有正可用空间就不会增长，没有负可用空间就不会缩小。</li>
<li>如果我们把所有元素的宽度相加（如果在列方向工作则为高度），总和小于容器的总宽度（或高度），那么你有正可用空间，并且 flex-grow 会发挥作用。</li>
<li>如果我们把所有的元素的宽度相加（如果在列方向工作则为高度），总和大于容器的总宽度（或高度），那么你有负可用空间，并且 flex-shrink 会发挥作用。</li>
</ol>
<h2 id="关于flex-grow属性的计算过程为"><a href="#关于flex-grow属性的计算过程为" class="headerlink" title="关于flex-grow属性的计算过程为"></a>关于flex-grow属性的计算过程为</h2><ol>
<li>flex-grow属性小于等于0的项目不受影响，不会伸长。</li>
<li>对剩余项目的flex-grow属性进行求和，将结果记为sum。</li>
<li>分以下情况进行讨论。</li>
</ol>
<p><strong>sum ≥ 1 时 计算过程：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">  <span class="selector-class">.item1</span> &#123;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">50px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.item2</span> &#123;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.item3</span> &#123;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.item4</span> &#123;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">6</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>计算剩余宽度：剩余宽度 &#x3D; 容器宽度 - 项目总宽度，所以：剩余宽度 &#x3D; 800px - 500px &#x3D; 300px。</li>
<li>计算各项目权重占比：权重 &#x3D; <flex-grow>，所以：<ol>
<li>总权重 &#x3D; sum &#x3D; 1 + 3 + 6 &#x3D; 10。</li>
<li>项目2权重 &#x3D; 1，项目2权重占比 &#x3D; 1 &#x2F; 10 &#x3D; 0.1。</li>
<li>项目3权重 &#x3D; 3，项目3权重占比 &#x3D; 3 &#x2F; 10 &#x3D; 0.3。</li>
<li>项目4权重 &#x3D; 6，项目4权重占比 &#x3D; 6 &#x2F; 10 &#x3D; 0.6。</li>
</ol>
</flex-grow></li>
<li>计算各项目伸长宽度：伸长宽度 &#x3D; 权重占比 * 剩余宽度，所以：<ol>
<li>项目2伸长宽度 &#x3D; 0.1 * 300px &#x3D; 30px。</li>
<li>项目3伸长宽度 &#x3D; 0.3 * 300px &#x3D; 90px。</li>
<li>项目4伸长宽度 &#x3D; 0.6 * 300px &#x3D; 180px。</li>
</ol>
</li>
<li>计算各项目伸长后宽度：伸长后宽度 &#x3D; <flex-basis> + 伸长宽度，所以：<ol>
<li>项目2伸长后宽度 &#x3D; 100px + 30px &#x3D; 130px。</li>
<li>项目3伸长后宽度 &#x3D; 150px + 90px &#x3D; 240px。</li>
<li>项目4伸长后宽度 &#x3D; 200px + 180px &#x3D; 380px。</li>
</ol>
</flex-basis></li>
</ol>
<p><strong>sum &lt; 1 时</strong></p>
<blockquote>
<p>计算过程基本与sum &gt; 1时的情况相同，但在第 3 步中，各项目的伸长宽度为sum * 权重占比 * 剩余宽度。</p>
</blockquote>
<h2 id="关于flex-shrink属性的计算过程为"><a href="#关于flex-shrink属性的计算过程为" class="headerlink" title="关于flex-shrink属性的计算过程为"></a>关于flex-shrink属性的计算过程为</h2><ol>
<li>flex-shrink属性小于等于0的项目不受影响，不会缩短。</li>
<li>对剩余项目的flex-shrink属性进行求和，将结果记为sum。</li>
<li>分以下情况进行讨论。</li>
</ol>
<p><strong>sum ≥ 1 时</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">  <span class="selector-class">.item1</span> &#123;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">100px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.item2</span> &#123;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">6</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.item3</span> &#123;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.item4</span> &#123;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>计算溢出宽度：溢出宽度 &#x3D; 项目总宽度 - 容器宽度，所以：溢出宽度 &#x3D; 800px - 1000px &#x3D; 200px。</li>
<li>计算各项目权重占比：权重 &#x3D; <flex-shrink> * <flex-basis>，所以：<ol>
<li>总权重 &#x3D; 1200 + 900 + 400 &#x3D; 2500。</li>
<li>项目2权重 &#x3D; 1200，项目2权重占比 &#x3D; 1200 &#x2F; 2500 &#x3D; 0.48。</li>
<li>项目3权重 &#x3D; 900，项目3权重占比 &#x3D; 900 &#x2F; 2500 &#x3D; 0.36。</li>
<li>项目4权重 &#x3D; 400，项目4权重占比 &#x3D; 400 &#x2F; 2500 &#x3D; 0.16。</li>
</ol>
</flex-basis></flex-shrink></li>
<li>计算各项目缩短宽度：缩短宽度 &#x3D; 权重占比 * 溢出宽度，所以：<ol>
<li>项目2伸长宽度 &#x3D; 0.48 * 200px &#x3D; 96px。</li>
<li>项目3伸长宽度 &#x3D; 0.36 * 200px &#x3D; 72px。</li>
<li>项目4伸长宽度 &#x3D; 0.16 * 200px &#x3D; 32px。</li>
</ol>
</li>
<li>计算各项目缩短后宽度：缩短后宽度 &#x3D; 原始宽度 - 缩短宽度，所以：<ol>
<li>项目2缩短后宽度 &#x3D; 200px - 96px &#x3D; 104px。</li>
<li>项目3缩短后宽度 &#x3D; 300px - 72px &#x3D; 228px。</li>
<li>项目4缩短后宽度 &#x3D; 400px - 32px &#x3D; 368px。</li>
</ol>
</li>
</ol>
<p><strong>sum &lt; 1 时</strong></p>
<blockquote>
<p>计算过程基本与sum &gt; 1时的情况相同，但在第 3 步中，各项目的缩短宽度为sum * 权重占比 * 溢出宽度。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/07/26/css/flex%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/26/css/flex%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">flex容器中的对齐方式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-07-26 11:48:46" itemprop="dateCreated datePublished" datetime="2023-07-26T11:48:46+08:00">2023-07-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-28 11:17:50" itemprop="dateModified" datetime="2023-07-28T11:17:50+08:00">2023-07-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>flexbox 之所以能迅速吸引开发者的注意，其中一个原因就是它首次为网页样式居中提供了合适的方案。得益于它提供的合适的垂直居中能力，我们可以很轻松地把一个盒子居中。</p>
<p>通过align-items属性，可以将交叉轴上的 item 对齐。而使用justify-content则可以对齐主轴上的项目。</p>
<p><img src="1519b53666a0b4c9fa64ef3ea43ed9ee8f50b01cc641c36d6ad07894a581a747.png" alt="图 0">  </p>
<h1 id="控制对齐的属性"><a href="#控制对齐的属性" class="headerlink" title="控制对齐的属性"></a>控制对齐的属性</h1><ul>
<li>justify-content - 控制主轴（横轴）上所有 flex 项目的对齐。</li>
<li>align-items - 控制交叉轴（纵轴）上单行内 flex 项目的对齐。</li>
<li>align-content - 控制“多条主轴”的 flex 项目在交叉轴的对齐。</li>
<li>align-self - 控制交叉轴（纵轴）上的单个 flex 项目的对齐。</li>
</ul>
<h1 id="交叉轴"><a href="#交叉轴" class="headerlink" title="交叉轴"></a>交叉轴</h1><p>如果我们在父级的容器元素上添加display: flex 属性，那么容器里的所有子元素将会变成横向排列的flex项目。所有的flex项目会撑满交叉轴方向的高度，因为display: flex 属性会将 flex 项目的高定义成容器的高度。</p>
<p><img src="b881a8ce38800651a3014c72308e13dc40b351b955624f088e96d56074875d78.png" alt="图 1">  </p>
<p>flex items 的高度全都变成一样的原因是 align-items 属性的初始值默认为 stretch 控制交叉轴对齐。</p>
<p>我们可以使用其他的值来控制 flex items 的对齐方式：</p>
<ul>
<li>align-items: flex-start 单行内flex项目的开始端对齐</li>
<li>align-items: flex-end 单行内flex项目的结束端对齐</li>
<li>align-items: center 单行内flex项目居中对齐</li>
<li>align-items: stretch 单行内flex项目撑满flex容器</li>
<li>align-items: baseline 单行内flex项目的基线对齐</li>
</ul>
<h2 id="align-self-用于对齐单个-flex子项"><a href="#align-self-用于对齐单个-flex子项" class="headerlink" title="align-self 用于对齐单个 flex子项"></a>align-self 用于对齐单个 flex子项</h2><p>align-items 属性是给所有 flex 项目统一设置 align-self 的对齐属性。这意味着你能给单个 flex 项目明确地声明 align-self 属性。align-self 拥有 align-items 的所有属性值，另外还有一个 auto 能重置自身的值为 align-items 定义的值。</p>
<p><img src="0b3129ed666dbe58c1945d8e709a4d631606ec62d8e2b7d31a20f5d7b1314b77.png" alt="图 2">  </p>
<p>在上面的一个例子中，flex 容器为 align-items: flex-start，这意思是所有的 flex 项目都在交叉轴方向的开始端对齐。我用 first-child 选择器给第一个 flex 项目设置了 align-self: stretch ；另外一个selected 项目用设置成 align-self: center 。</p>
<h2 id="改变主轴方向"><a href="#改变主轴方向" class="headerlink" title="改变主轴方向"></a>改变主轴方向</h2><p>flex-direction 是 row,意味着主轴是水平方向，交叉轴对齐则是垂直方向由上至下。</p>
<p><img src="7d9061a996562cb702c28b0c2344f9a9c6941fa15cf822a69976160dffd1fd28.png" alt="图 3">  </p>
<p>flex-direction 为 column ，意味着主轴是垂直方向，交叉轴对齐则是水平方向由左至右。</p>
<p><img src="379a697f65a783c13e5f66cd03f04f3adaf71ce4a9f77d784b214e7658b0338a.png" alt="图 4">  </p>
<h2 id="轴对齐内容——-align-content-属性"><a href="#轴对齐内容——-align-content-属性" class="headerlink" title="轴对齐内容—— align-content 属性"></a>轴对齐内容—— align-content 属性</h2><p>如果你有一个折行的多条 flex 项目的 flex 容器，你可以使用 align-content 来控制每行之间空间的分配，在这种特定的场景叫做packing flex lines。</p>
<p>要使得 align-content 生效，你需要你的 flex 容器的 height 要大于 flex 项目的可视内容。然后它会将所有的 flex 项目打包成一块之后再对齐剩下的空间。</p>
<p><strong>align-content 属性的值如下：</strong></p>
<ul>
<li>align-content: flex-start</li>
<li>align-content: flex-end</li>
<li>align-content: center</li>
<li>align-content: space-between</li>
<li>align-content: space-around</li>
<li>align-content: stretch</li>
<li>align-content: space-evenly （没有在 Flexbox 特性中定义）</li>
</ul>
<p>在下面的例子，有一个 400px 高的 flex 容器，能足够地显示 flex 项目。align-content 的值为 space-between 等同于分配 flex 行之间的空间。</p>
<p><img src="349d24de44ed04ad892b3351953ceabcd79754d37dc95f7e74fd985d5334c7e0.png" alt="图 5">  </p>
<p>在强调一次我们可以切换我们的 flex-direction 为 column 去观察这个属性的行为是怎样的。和之前一样，我们需要足够的交叉轴空间去显示所有的 flex 项目之外还有有一定的自由空间。</p>
<p><img src="8f1b5d22bfbe757ba7cc1a82da5104aa550df363bb713c3338d0571f9e18e231.png" alt="图 6">  </p>
<h1 id="对齐主轴内容"><a href="#对齐主轴内容" class="headerlink" title="对齐主轴内容"></a>对齐主轴内容</h1><p>到目前我们已经看到 flex 项目是如何在交叉轴上对齐的，现在我们可以看一下主轴上的对齐。这里只有一个属性是用于主轴上对齐—— justify-content </p>
<p><img src="718d519a0ef428b424897511611a47456a3b0ddd5ebbffc658b94ed987ff65a6.png" alt="图 7">  </p>
<p><strong>justify-content 属性有和 align-content 一样的属性值：</strong></p>
<ul>
<li>justify-content: flex-start</li>
<li>justify-content: flex-end</li>
<li>justify-content: center</li>
<li>justify-content: space-between</li>
<li>justify-content: space-around</li>
<li>justify-content: stretch</li>
<li>justify-content: space-evenly （没有在 flexbox 特性中定义）</li>
</ul>
<h2 id="对齐和书写模式"><a href="#对齐和书写模式" class="headerlink" title="对齐和书写模式"></a>对齐和书写模式</h2><p>记得这些所有的对齐方法，属性值 flex-start 和 flex-end 是受书写模式的影响的。如果 justify-content 的值是 flex-start 而已你的书写模式是从左到右的话，那么 flex items 就会从 flex container 的左边开始排列。</p>
<p><img src="013a3fcd15f1a891c7f058aea7734ce4fdaa5e25b84b142c6cf36af095021eee.png" alt="图 8">  </p>
<p>反之，则会 flex 项目就会从 flex 容器的右边开始排列。</p>
<p><img src="3171d71c0cdef26a57eda1440d917e17b613714972a9febf065bb7e90b684fca.png" alt="图 9">  </p>
<h2 id="对齐和-flex-direction"><a href="#对齐和-flex-direction" class="headerlink" title="对齐和 flex-direction"></a>对齐和 flex-direction</h2><p>如果你改变 flex-direction 属性，主轴起始线也会改变——例如，使用 row-reverse 代替 row。</p>
<p><img src="a04f8a413e400b2ed43a0b47bedb3002094bb1d974dd0e63ce77819f1a2e559e.png" alt="图 10">  </p>
<p>这似乎有一点令人困惑，需要记住的规则就是，当没有设置 flex-direction 时，flex 项目的排列方向与文档语言的文本沿行内轴的排列方向一致。flex-start 就是一个句子中文本的起始处。</p>
<p><img src="013a3fcd15f1a891c7f058aea7734ce4fdaa5e25b84b142c6cf36af095021eee.png" alt="图 11">  </p>
<p>你可以通过设置 flex-direction: column，使弹性项目沿着文档语言的块级轴方向显示。那样话，flex-start 就是文本第一个段落的顶端起始处。</p>
<p><img src="cdf1a6cdc84760777959a7b4d4b2378d4c675de3d26a56e65e580d89377833e9.png" alt="图 12">  </p>
<p>如果你将 flex-direction 的值改成 row-reverse 或者 column-revers ，那么flex 项目会沿着文档语言的文本书写方向的相反方向，从轴的尾端开始排列。flex-start 就会变为轴的尾端。也就是说，沿着行内轴时，这个位置就是每行文本的换行处；沿着块级轴时，就是文本最后一个段落的底部。</p>
<p><img src="ee5458aeb82c96dfe8c16da3f65ddd6f05034b06b53f8314d5014cbd038d1b41.png" alt="图 13">  </p>
<p><img src="c78fbb2f3c90461f0755b9e0418334e53801afd56c80bf862b0ffb9401a1a54c.png" alt="图 14">  </p>
<h2 id="在主轴上使用margin-对齐"><a href="#在主轴上使用margin-对齐" class="headerlink" title="在主轴上使用margin 对齐"></a>在主轴上使用margin 对齐</h2><p>我们想要处理个别flex 项目在主轴上的对齐，但是没有 justify-items 属性或者 justify-self 属性可用，因为flex 项目会被当成一个组来对齐。然而，我们可以使用 margin 来处理一些flex 项目或者一组flex 项目想和其他flex 项目分离开的对齐情况。</p>
<p>在下面这个在线例子中，flex 项目按默认方式简单地沿行排列，而样式类 push 有设置有 margin-left: auto。你可以尝试删除它，或者把这个类名加到别的flex 项目上，你会看到它是怎样影响flex 项目排列的。<br><img src="ccd12ac430230cac7e845d2f1614c0205d2d507b99c977c081f75505ef745fc5.png" alt="图 15">  </p>
<h1 id="order-属性"><a href="#order-属性" class="headerlink" title="order 属性"></a>order 属性</h1><p>order属性旨在按顺序排列项目。这意味着为项目分配了代表其组的整数。然后，按照该整数（最低的值）首先按照视觉顺序放置项目。如果多个项目具有相同的整数值，则在该组中按照源顺序对项目进行布局。</p>
<p>flex 项目默认 order 值为 0, 因此整数值大于 0 的项目，将会显示在那些未指定 order 值的项目之后。</p>
<p>您还可以使用负值，这很有用。如果要先显示一个项目，并保持所有其他项目的顺序不变，则可以将该项目的顺序设为-1。由于该值小于 0，因此始终会首先显示该项目。</p>
<p><img src="6c655b34cca6b5efb8ed61fd0c48c2ec6fa014bcbb00f1fcfb9e757999c1bcdb.png" alt="图 16">  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>容器属性</li>
</ol>
<ul>
<li><p>dispaly:</p>
</li>
<li><p>flex-direction: 控制主轴方向；</p>
</li>
<li><p>flex-warp：控制主轴是否换行；</p>
</li>
<li><p>flex-flow:</p>
</li>
<li><p>justify-content:控制主轴对齐方式</p>
</li>
<li><p>align-item:控制交叉轴行内元素对齐方式</p>
</li>
<li><p>align-content:控制“多条主轴”的flex项目在交叉轴的对齐</p>
</li>
</ul>
<ol start="2">
<li>flex元素属性</li>
</ol>
<ul>
<li><p>flex-grow:控制元素拉伸</p>
</li>
<li><p>flex-shrink:控制元素压缩</p>
</li>
<li><p>flex-basis:控制元素空间大小</p>
</li>
<li><p>flex</p>
</li>
<li><p>align-self:控制交叉轴上的单个flex项目的对齐</p>
</li>
</ul>
<p><strong>align-items与align-content 的区别</strong></p>
<ol>
<li>align-items：</li>
</ol>
<ul>
<li>作用对象：弹性盒子容器(flex containers)；</li>
<li>描述：该属性可以控制弹性容器中成员在当前行内的对齐方式。当成员设置了align-self 属性时，父容器的 align-items 值则不再对它生效；</li>
</ul>
<ol start="2">
<li>align-content：</li>
</ol>
<ul>
<li>作用对象：弹性盒子容器多行的控制(multi-line flex containers)；</li>
<li>描述：当弹性容器在正交轴方向还存在空白时，该属性可以控制其中所有行的对齐方式。Note：该属性无法作用于单行 (flex-wrap: no-wrap) 弹性盒子；</li>
</ul>
<ol start="3">
<li>对比</li>
</ol>
<ul>
<li>相同点：都被用来设置对齐行为。</li>
<li>不同点：<ul>
<li>align-items 的设置对象是行内成员;</li>
<li>align-content 的设置对象是所有行，且只有在多行弹性盒子容器中才生效。</li>
</ul>
</li>
</ul>
<p>align-content 显示效果<br><img src="4f42bb7e8fc4aa649c46e695b097a06ef549998ce129b492eebe225b3cce8b37.png" alt="图 17">  </p>
<p>默认设置 display:flex后；<br>flex-direction:row<br>flex-warp:nowarp<br>justify-content:flex-start<br>align-item:stretch</p>
<p>flex-basis:auto<br>flex-grow:1<br>flex-shrink:1<br>align-self:stretch</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/07/25/css/flex%E5%B8%83%E5%B1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/25/css/flex%E5%B8%83%E5%B1%80/" class="post-title-link" itemprop="url">flex布局</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-07-25 18:28:29" itemprop="dateCreated datePublished" datetime="2023-07-25T18:28:29+08:00">2023-07-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-28 09:51:33" itemprop="dateModified" datetime="2023-07-28T09:51:33+08:00">2023-07-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>传统的布局方案，基于盒模型，依赖display属性、position属性和float属性。其对于某些特殊的布局（如垂直居中），实现起来比较麻烦。<br>在 2009 年，W3C 提出了一种新的布局方案——Flex 布局（Flexible Box 布局，弹性盒子布局），其相比于传统的布局方案，更为灵活和简便。目前，Flex 布局已经得到了所有浏览器的支持。<br>将元素的display属性设置为flex或inline-flex后，即可开启 Flex 布局：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 块级元素</span><br><span class="line"><span class="selector-class">.block-box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 行内元素</span><br><span class="line"><span class="selector-class">.inline-box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，该元素会自动成为 Flex 容器，简称容器。且容器的所有子元素会自动成为 Flex 容器成员，简称项目。项目的float、clear、vertical-align属性将失效。<br>容器中默认存在两根轴：主轴和交叉轴。主轴和交叉轴互相垂直，类似于平面坐标系中的 x 轴和 y 轴。项目将自动沿着主轴方向排列，排满时将沿交叉轴方向堆砌，即在交叉轴方向上换行（前提是容器flex-wrap属性不为nowrap）。</p>
<h1 id="flexbox-的两根轴线"><a href="#flexbox-的两根轴线" class="headerlink" title="flexbox 的两根轴线"></a>flexbox 的两根轴线</h1><p>当使用 flex 布局时，首先想到的是两根轴线 — 主轴和交叉轴。<strong>主轴由 flex-direction 定义</strong>，另一根轴垂直于它。我们使用 flexbox 的所有属性都跟这两根轴线有关，所以有必要在一开始首先理解它。</p>
<h2 id="主轴"><a href="#主轴" class="headerlink" title="主轴"></a>主轴</h2><p>主轴由 flex-direction 定义，可以取 4 个值：</p>
<ul>
<li>row</li>
<li>row-reverse</li>
<li>column</li>
<li>column-reverse</li>
</ul>
<p>如果你选择了 row 或者 row-reverse，你的主轴将沿着 inline 方向延伸。<br><img src="3e36d0e94c21fe3663a00ab2ff0d7c7cbccb246f897a7e36febc8a50d3bba7a8.png" alt="图 0">  </p>
<p>选择 column 或者 column-reverse 时，你的主轴会沿着上下方向延伸 — 也就是 block 排列的方向。</p>
<p><img src="0234ac4fbb2520dd27a685ad671962718aaf3dcfb37d8af61ebf49a820b057be.png" alt="图 1">  </p>
<h2 id="交叉轴"><a href="#交叉轴" class="headerlink" title="交叉轴"></a>交叉轴</h2><p>交叉轴垂直于主轴，所以如果你的flex-direction (主轴) 设成了 row 或者 row-reverse 的话，交叉轴的方向就是沿着列向下的。</p>
<p><img src="f9c6ce02dca6af6bbd3544a265f4793edbc2e0d28d520880255d6fc3ea44120a.png" alt="图 2">  </p>
<p>如果主轴方向设成了 column 或者 column-reverse，交叉轴就是水平方向。<br><img src="57fc207072143e04b94a6224c9e8ffba413efdacb3d0cc520f6a4baab922d4a9.png" alt="图 3">  </p>
<p>理解主轴和交叉轴的概念对于对齐 flexbox 里面的元素是很重要的；flexbox 的特性是沿着主轴或者交叉轴对齐之中的元素。</p>
<h1 id="起始线和终止线"><a href="#起始线和终止线" class="headerlink" title="起始线和终止线"></a>起始线和终止线</h1><p>过去，CSS 的书写模式主要被认为是水平的，从左到右的。现代的布局方式涵盖了书写模式的范围，所以我们不再假设一行文字是从文档的左上角开始向右书写，新的行也不是必须出现在另一行的下面。</p>
<p>如果 flex-direction 是 row ，并且我是在书写英文，那么主轴的起始线是左边，终止线是右边。<br><img src="013a3fcd15f1a891c7f058aea7734ce4fdaa5e25b84b142c6cf36af095021eee.png" alt="图 4"><br>如果我在书写阿拉伯文，那么主轴的起始线是右边，终止线是左边。</p>
<p>在这两种情况下，交叉轴的起始线是 flex 容器的顶部，终止线是底部，因为两种语言都是水平书写模式。</p>
<h1 id="Flex-容器"><a href="#Flex-容器" class="headerlink" title="Flex 容器"></a>Flex 容器</h1><p>文档中采用了<code>flexbox</code>的区域就叫做<code>flex</code>容器。为了创建 <code>flex</code>容器，我们把一个容器的<code>display</code>属性值改为<code>flex</code> 或者<code>inline-flex</code>。完成这一步之后，容器中的直系子元素就会变为<code>flex</code>元素。所有 CSS 属性都会有一个初始值，所以 flex 容器中的所有 flex 元素都会有下列行为：</p>
<ul>
<li>元素排列为一行 (flex-direction 属性的初始值是 row)。</li>
<li>元素从主轴的起始线开始。</li>
<li>元素不会在主维度方向拉伸，但是可以缩小。</li>
<li>元素被拉伸来填充交叉轴大小。</li>
<li>flex-basis 属性为 auto。</li>
<li>flex-wrap 属性为 nowrap。</li>
</ul>
<p>这会让你的元素呈线形排列，并且把自己的大小作为主轴上的大小。如果有太多元素超出容器，它们会溢出而不会换行。如果一些元素比其他元素高，那么元素会沿交叉轴被拉伸来填满它的大小。</p>
<h2 id="更改-flex-方向-flex-direction"><a href="#更改-flex-方向-flex-direction" class="headerlink" title="更改 flex 方向 flex-direction"></a>更改 flex 方向 flex-direction</h2><p>设置 flex-direction: row-reverse 可以让元素沿着行的方向显示，但是起始线和终止线位置会交换。</p>
<p>把 flex 容器的属性 flex-direction 改为 column ，主轴和交叉轴交换，元素沿着列的方向排列显示。改为 column-reverse ，起始线和终止线交换。</p>
<h2 id="用-flex-wrap-实现多行-Flex-容器"><a href="#用-flex-wrap-实现多行-Flex-容器" class="headerlink" title="用 flex-wrap 实现多行 Flex 容器"></a>用 flex-wrap 实现多行 Flex 容器</h2><p>虽然flexbox是一维模型，但可以使我们的flex项目应用到多行中。在这样做的时候，您应该把每一行看作一个新的flex容器。任何空间分布都将在该行上发生，而不影响该空间分布的其他行。</p>
<p>为了实现多行效果，请为属性flex-wrap添加一个属性值wrap。现在，如果您的项目太大而无法全部显示在一行中，则会换行显示。下面的实时例子包含已给出宽度的项目，对于flex容器，项目的子元素总宽度大于容器最大宽度。由于flex-wrap的值设置为wrap，所以项目的子元素换行显示。若将其设置为nowrap，这也是初始值，它们将会缩小以适应容器，因为它们使用的是允许缩小的初始Flexbox值。如果项目的子元素无法缩小，使用nowrap会导致溢出，或者缩小程度还不够小。</p>
<p><img src="c1e0b2ad4c4da9d3f941bed60cd51d9c1a02169b0d193847cb51e35b8bf63bd7.png" alt="图 5">  </p>
<h1 id="简写属性-flex-flow"><a href="#简写属性-flex-flow" class="headerlink" title="简写属性 flex-flow"></a>简写属性 flex-flow</h1><p>你可以将两个属性 flex-direction 和 flex-wrap 组合为简写属性 flex-flow。第一个指定的值为 flex-direction ，第二个指定的值为 flex-wrap</p>
<p>在下面的例子中，尝试将第一个值修改为 flex-direction 的允许取值之一，即 row, row-reverse, column 或 column-reverse, 并尝试将第二个指定值修改为 wrap 或 nowrap。</p>
<p><img src="77182811930e5556e1e8e1a90dfdbc910a1d2b5024abbf19fcb2b4c5cbb587ff.png" alt="图 6">  </p>
<h1 id="flex-元素上的属性"><a href="#flex-元素上的属性" class="headerlink" title="flex 元素上的属性"></a>flex 元素上的属性</h1><p>为了更好地控制 flex 元素，有三个属性可以作用于它们：</p>
<ul>
<li>flex-grow</li>
<li>flex-shrink</li>
<li>flex-basis</li>
</ul>
<p>在考虑这几个属性的作用之前，需要先了解一下 可用空间 available space 这个概念。这几个 flex 属性的作用其实就是改变了 flex 容器中的可用空间的行为。同时，可用空间对于 flex 元素的对齐行为也是很重要的。</p>
<p>假设在 1 个 500px 的容器中，我们有 3 个 100px 宽的元素，那么这 3 个元素需要占 300px 的宽，剩下 200px 的可用空间。在默认情况下，flexbox 的行为会把这 200px 的空间留在最后一个元素的后面。</p>
<p><img src="a426a1ea867ad32df9dbe25afab2b1122106f66a1d6ca49102f931bc7fe4f90e.png" alt="图 7">  </p>
<h2 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h2><p>flex-basis 定义了该元素的空间大小（the size of that item in terms of the space），flex 容器里除了元素所占的空间以外的富余空间就是可用空间 available space。该属性的默认值是 auto 。此时，浏览器会检测这个元素是否具有确定的尺寸。在上面的例子中，所有元素都设定了宽度（width）为 100px，所以 flex-basis 的值为 100px。</p>
<p>如果没有给元素设定尺寸，flex-basis 的值采用元素内容的尺寸。这就解释了：我们给只要给 Flex 元素的父元素声明 display: flex ，所有子元素就会排成一行，且自动分配小大以充分展示元素的内容。</p>
<h2 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h2><p>flex-grow 若被赋值为一个正整数，flex 元素会以 flex-basis 为基础，沿主轴方向增长尺寸。这会使该元素延展，并占据此方向轴上的可用空间（available space）。如果有其他元素也被允许延展，那么他们会各自占据可用空间的一部分。</p>
<p>如果我们给上例中的所有元素设定 flex-grow 值为 1，容器中的可用空间会被这些元素平分。它们会延展以填满容器主轴方向上的空间。</p>
<p>flex-grow 属性可以按比例分配空间。如果第一个元素 flex-grow 值为 2，其他元素值为 1，则第一个元素将占有 2&#x2F;4（上例中，即为 200px 中的 100px）, 另外两个元素各占有 1&#x2F;4（各 50px）。</p>
<h2 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h2><p>flex-grow属性是处理 flex 元素在主轴上增加空间的问题，相反flex-shrink属性是处理 flex 元素收缩的问题。如果我们的容器中没有足够排列 flex 元素的空间，那么可以把 flex 元素flex-shrink属性设置为正整数来缩小它所占空间到flex-basis以下。与flex-grow属性一样，可以赋予不同的值来控制 flex 元素收缩的程度 —— 给flex-shrink属性赋予更大的数值可以比赋予小数值的同级元素收缩程度更大。</p>
<p>在计算 flex 元素收缩的大小时，它的最小尺寸也会被考虑进去，就是说实际上 flex-shrink 属性可能会和 flex-grow 属性表现的不一致。</p>
<h2 id="Flex-属性的简写"><a href="#Flex-属性的简写" class="headerlink" title="Flex 属性的简写"></a>Flex 属性的简写</h2><p>你可能很少看到 flex-grow，flex-shrink，和 flex-basis 属性单独使用，而是混合着写在 flex 简写形式中。 Flex 简写形式允许你把三个数值按这个顺序书写 — flex-grow，flex-shrink，flex-basis。</p>
<p><img src="218e8a3a66b6b36cbfa4906f454aa314b67233c2ce93b7abe6482d8d1e05d859.png" alt="图 8">  </p>
<p>在这个教程中你可能经常会看到这种写法，许多情况下你都可以这么使用。下面是几种预定义的值：</p>
<ul>
<li>flex: initial（flex: 0 1 auto）不能拉伸但可以缩小 flex 元素来防止它们溢出，flex-basis 的值为 auto. Flex 元素尺寸可以是在主维度上设置的，也可以是根据内容自动得到的</li>
<li>flex: auto（flex: 1 1 auto）flex 元素在需要的时候既可以拉伸也可以收缩</li>
<li>flex: none（flex: 0 0 auto）元素既不能拉伸或者收缩，但是元素会按具有 flex-basis: auto 属性的 flexbox 进行布局</li>
<li>flex: <positive-number> 你在教程中常看到的 flex: 1 或者 flex: 2 等等。它相当于flex: 1 1 0 或者 flex: 2 1 0。元素可以在 flex-basis 为 0 的基础上伸缩</positive-number></li>
</ul>
<h1 id="元素间的对齐和空间分配"><a href="#元素间的对齐和空间分配" class="headerlink" title="元素间的对齐和空间分配"></a>元素间的对齐和空间分配</h1><p>Flexbox 的一个关键特性是能够设置 flex 元素沿主轴方向和交叉轴方向的对齐方式，以及它们之间的空间分配。</p>
<h2 id="align-items-属性可以使元素在交叉轴方向对齐。"><a href="#align-items-属性可以使元素在交叉轴方向对齐。" class="headerlink" title="align-items 属性可以使元素在交叉轴方向对齐。"></a>align-items 属性可以使元素在交叉轴方向对齐。</h2><p>这个属性的初始值为stretch，这就是为什么 flex 元素会默认被拉伸到最高元素的高度。实际上，它们被拉伸来填满 flex 容器 —— 最高的元素定义了容器的高度。</p>
<p>align-items属性的值：</p>
<ul>
<li>stretch</li>
<li>flex-start</li>
<li>flex-end</li>
<li>center</li>
</ul>
<h2 id="justify-content属性用来使元素在主轴方向上对齐"><a href="#justify-content属性用来使元素在主轴方向上对齐" class="headerlink" title="justify-content属性用来使元素在主轴方向上对齐"></a>justify-content属性用来使元素在主轴方向上对齐</h2><p>justify-content属性的值：</p>
<ul>
<li>stretch</li>
<li>flex-start</li>
<li>flex-end</li>
<li>center</li>
<li>space-around</li>
<li>space-between</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24372279">https://zhuanlan.zhihu.com/p/24372279</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/07/12/typescript/JavaScript%E4%B8%AD%E6%A3%80%E6%B5%8B%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9F%90%E4%B8%AA%E5%B1%9E%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/12/typescript/JavaScript%E4%B8%AD%E6%A3%80%E6%B5%8B%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9F%90%E4%B8%AA%E5%B1%9E%E6%80%A7/" class="post-title-link" itemprop="url">JavaScript中检测对象中是否存在某个属性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-07-12 11:37:17 / 修改时间：13:47:21" itemprop="dateCreated datePublished" datetime="2023-07-12T11:37:17+08:00">2023-07-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>检测对象中属性的存在与否可以通过几种方法来判断。</p>
<h1 id="使用in关键字"><a href="#使用in关键字" class="headerlink" title="使用in关键字"></a>使用in关键字</h1><p>如果指定的属性在指定的对象或其原型链中，则 in 运算符返回 true。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> car = &#123; <span class="attr">make</span>: <span class="string">&#x27;Honda&#x27;</span>, <span class="attr">model</span>: <span class="string">&#x27;Accord&#x27;</span>, <span class="attr">year</span>: <span class="number">1998</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;make&#x27;</span> <span class="keyword">in</span> car);</span><br><span class="line"><span class="comment">// Expected output: true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> car.<span class="property">make</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;make&#x27;</span> <span class="keyword">in</span> car);</span><br><span class="line"><span class="comment">// Expected output: false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;make&#x27;</span> <span class="keyword">in</span> car === <span class="literal">false</span>) &#123;</span><br><span class="line">  car.<span class="property">make</span> = <span class="string">&#x27;Suzuki&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(car.<span class="property">make</span>);</span><br><span class="line"><span class="comment">// Expected output: &quot;Suzuki&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;make&#x27;</span> <span class="keyword">in</span> car);</span><br><span class="line"><span class="comment">// Expected output: true</span></span><br></pre></td></tr></table></figure>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>prop in object</p>
<p><strong>参数</strong></p>
<ul>
<li>prop：一个字符串类型或者 symbol 类型的属性名或者数组索引（非 symbol 类型将会强制转为字符串）。</li>
</ul>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>下面的例子演示了一些 in 运算符的用法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">var</span> trees = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;redwood&quot;</span>, <span class="string">&quot;bay&quot;</span>, <span class="string">&quot;cedar&quot;</span>, <span class="string">&quot;oak&quot;</span>, <span class="string">&quot;maple&quot;</span>);</span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> trees        <span class="comment">// 返回 true</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">in</span> trees        <span class="comment">// 返回 true</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">in</span> trees        <span class="comment">// 返回 false</span></span><br><span class="line"><span class="string">&quot;bay&quot;</span> <span class="keyword">in</span> trees    <span class="comment">// 返回 false (必须使用索引号，而不是数组元素的值)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;length&quot;</span> <span class="keyword">in</span> trees <span class="comment">// 返回 true (length 是一个数组属性)</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Symbol</span>.<span class="property">iterator</span> <span class="keyword">in</span> trees <span class="comment">// 返回 true (数组可迭代，只在 ES2015+ 上有效)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置对象</span></span><br><span class="line"><span class="string">&quot;PI&quot;</span> <span class="keyword">in</span> <span class="title class_">Math</span>          <span class="comment">// 返回 true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义对象</span></span><br><span class="line"><span class="keyword">var</span> mycar = &#123;<span class="attr">make</span>: <span class="string">&quot;Honda&quot;</span>, <span class="attr">model</span>: <span class="string">&quot;Accord&quot;</span>, <span class="attr">year</span>: <span class="number">1998</span>&#125;;</span><br><span class="line"><span class="string">&quot;make&quot;</span> <span class="keyword">in</span> mycar  <span class="comment">// 返回 true</span></span><br><span class="line"><span class="string">&quot;model&quot;</span> <span class="keyword">in</span> mycar <span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure>

<p>in右操作数必须是一个对象值。例如，你可以指定使用String构造函数创建的字符串，但不能指定字符串文字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color1 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;green&quot;</span>);</span><br><span class="line"><span class="string">&quot;length&quot;</span> <span class="keyword">in</span> color1 <span class="comment">// 返回 true</span></span><br><span class="line"><span class="keyword">var</span> color2 = <span class="string">&quot;coral&quot;</span>;</span><br><span class="line"><span class="string">&quot;length&quot;</span> <span class="keyword">in</span> color2 <span class="comment">// 报错 (color2 不是对象)</span></span><br></pre></td></tr></table></figure>

<h3 id="对被删除或值为-undefined-的属性使用in"><a href="#对被删除或值为-undefined-的属性使用in" class="headerlink" title="对被删除或值为 undefined 的属性使用in"></a>对被删除或值为 undefined 的属性使用in</h3><p>如果你使用 delete 运算符删除了一个属性，则 in 运算符对所删除属性返回 false。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mycar = &#123;<span class="attr">make</span>: <span class="string">&quot;Honda&quot;</span>, <span class="attr">model</span>: <span class="string">&quot;Accord&quot;</span>, <span class="attr">year</span>: <span class="number">1998</span>&#125;;</span><br><span class="line"><span class="keyword">delete</span> mycar.<span class="property">make</span>;</span><br><span class="line"><span class="string">&quot;make&quot;</span> <span class="keyword">in</span> mycar;  <span class="comment">// 返回 false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> trees = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;redwood&quot;</span>, <span class="string">&quot;bay&quot;</span>, <span class="string">&quot;cedar&quot;</span>, <span class="string">&quot;oak&quot;</span>, <span class="string">&quot;maple&quot;</span>);</span><br><span class="line"><span class="keyword">delete</span> trees[<span class="number">3</span>];</span><br><span class="line"><span class="number">3</span> <span class="keyword">in</span> trees; <span class="comment">// 返回 false</span></span><br></pre></td></tr></table></figure>

<p>如果你只是将一个属性的值赋值为undefined，而没有删除它，则 in 运算仍然会返回true。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mycar = &#123;<span class="attr">make</span>: <span class="string">&quot;Honda&quot;</span>, <span class="attr">model</span>: <span class="string">&quot;Accord&quot;</span>, <span class="attr">year</span>: <span class="number">1998</span>&#125;;</span><br><span class="line">mycar.<span class="property">make</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="string">&quot;make&quot;</span> <span class="keyword">in</span> mycar;  <span class="comment">// 返回 true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> trees = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;redwood&quot;</span>, <span class="string">&quot;bay&quot;</span>, <span class="string">&quot;cedar&quot;</span>, <span class="string">&quot;oak&quot;</span>, <span class="string">&quot;maple&quot;</span>);</span><br><span class="line">trees[<span class="number">3</span>] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="number">3</span> <span class="keyword">in</span> trees; <span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure>

<h3 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h3><p>如果一个属性是从原型链上继承来的，in 运算符也会返回 true。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;toString&quot;</span> <span class="keyword">in</span> &#123;&#125;; <span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure>


<h1 id="使用对象的hasOwn-方法"><a href="#使用对象的hasOwn-方法" class="headerlink" title="使用对象的hasOwn()方法"></a>使用对象的hasOwn()方法</h1><p>如果指定的对象自身有指定的属性，则静态方法 Object.hasOwn() 返回 true。如果属性是继承的或者不存在，该方法返回 false。</p>
<blockquote>
<p>备注： Object.hasOwn() 旨在取代 Object.prototype.hasOwnProperty()。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o=&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line">o.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;x&quot;</span>);    　　 <span class="comment">//true，自有属性中有x</span></span><br><span class="line">o.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;y&quot;</span>);    　　 <span class="comment">//false，自有属性中不存在y</span></span><br><span class="line">o.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;toString&quot;</span>); <span class="comment">//false，这是一个继承属性，但不是自有属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">  <span class="attr">prop</span>: <span class="string">&#x27;exists&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">hasOwn</span>(object1, <span class="string">&#x27;prop&#x27;</span>));</span><br><span class="line"><span class="comment">// Expected output: true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">hasOwn</span>(object1, <span class="string">&#x27;toString&#x27;</span>));</span><br><span class="line"><span class="comment">// Expected output: false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">hasOwn</span>(object1, <span class="string">&#x27;undeclaredPropertyValue&#x27;</span>));</span><br><span class="line"><span class="comment">// Expected output: false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><p>Object.hasOwn(obj, prop)</p>
<ul>
<li>obj：要测试的 JavaScript 实例对象。</li>
<li>prop：要测试属性的 String 类型的名称或者 Symbol。</li>
<li>返回值：如果指定的对象中直接定义了指定的属性，则返回 true；否则返回 false。</li>
</ul>
<p>建议使用此方法替代 Object.hasOwnProperty()，因为它适用于使用 Object.create(null) 创建的对象且重写了继承的 hasOwnProperty() 方法的对象。尽管可以通过在外部对象上调用 Object.prototype.hasOwnProperty() 解决这些问题，但是 Object.hasOwn() 更加直观。</p>
<h2 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h2><h3 id="使用-hasOwn-去测试属性是否存在"><a href="#使用-hasOwn-去测试属性是否存在" class="headerlink" title="使用 hasOwn 去测试属性是否存在"></a>使用 hasOwn 去测试属性是否存在</h3><p>以下代码展示了如何确定 example 对象中是否包含名为 prop 的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> example = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">hasOwn</span>(example, <span class="string">&#x27;prop&#x27;</span>);   <span class="comment">// false——目标对象的属性 &#x27;prop&#x27; 未被定义</span></span><br><span class="line"></span><br><span class="line">example.<span class="property">prop</span> = <span class="string">&#x27;exists&#x27;</span>;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">hasOwn</span>(example, <span class="string">&#x27;prop&#x27;</span>);   <span class="comment">// true——目标对象的属性 &#x27;prop&#x27; 已被定义</span></span><br><span class="line"></span><br><span class="line">example.<span class="property">prop</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">hasOwn</span>(example, <span class="string">&#x27;prop&#x27;</span>);   <span class="comment">// true——目标对象本身的属性存在，值为 null</span></span><br><span class="line"></span><br><span class="line">example.<span class="property">prop</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">hasOwn</span>(example, <span class="string">&#x27;prop&#x27;</span>);   <span class="comment">// true——目标对象本身的属性存在，值为 undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="直接属性和继承属性"><a href="#直接属性和继承属性" class="headerlink" title="直接属性和继承属性"></a>直接属性和继承属性</h2><p>const example &#x3D; {};<br>example.prop &#x3D; ‘exists’;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// `hasOwn` 静态方法只会对目标对象的直接属性返回 true：</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">hasOwn</span>(example, <span class="string">&#x27;prop&#x27;</span>);             <span class="comment">// 返回 true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">hasOwn</span>(example, <span class="string">&#x27;toString&#x27;</span>);         <span class="comment">// 返回 false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">hasOwn</span>(example, <span class="string">&#x27;hasOwnProperty&#x27;</span>);   <span class="comment">// 返回 false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `in` 运算符对目标对象的直接属性或继承属性均会返回 true：</span></span><br><span class="line"><span class="string">&#x27;prop&#x27;</span> <span class="keyword">in</span> example;                          <span class="comment">// 返回 true</span></span><br><span class="line"><span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> example;                      <span class="comment">// 返回 true</span></span><br><span class="line"><span class="string">&#x27;hasOwnProperty&#x27;</span> <span class="keyword">in</span> example;                <span class="comment">// 返回 true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="迭代对象的属性"><a href="#迭代对象的属性" class="headerlink" title="迭代对象的属性"></a>迭代对象的属性</h2><p>要迭代对象的可枚举属性，你应该这样使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> example = &#123; <span class="attr">foo</span>: <span class="literal">true</span>, <span class="attr">bar</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(example)) &#123;</span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是如果你使用 for…in，你应该使用 Object.hasOwn() 跳过继承属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> example = &#123; <span class="attr">foo</span>: <span class="literal">true</span>, <span class="attr">bar</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> example) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="title function_">hasOwn</span>(example, name)) &#123;</span><br><span class="line">    <span class="comment">// …</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="检查数组索引是否存在"><a href="#检查数组索引是否存在" class="headerlink" title="检查数组索引是否存在"></a>检查数组索引是否存在</h2><p>Array 中的元素被定义为直接属性，所以你可以使用 hasOwn() 方法去检查一个指定的索引是否存在：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>,<span class="string">&#x27;Watermelon&#x27;</span>, <span class="string">&#x27;Orange&#x27;</span>];</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">hasOwn</span>(fruits, <span class="number">3</span>);   <span class="comment">// true (&#x27;Orange&#x27;)</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">hasOwn</span>(fruits, <span class="number">4</span>);   <span class="comment">// false——没有定义的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="hasOwnProperty-的问题案例"><a href="#hasOwnProperty-的问题案例" class="headerlink" title="hasOwnProperty 的问题案例"></a>hasOwnProperty 的问题案例</h2><p>本部分证明了影响 hasOwnProperty 的问题对 hasOwn() 是免疫的。首先，它可以与重新实现的 hasOwnProperty() 一起使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  <span class="title function_">hasOwnProperty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">bar</span>: <span class="string">&#x27;The dragons be out of office&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="title function_">hasOwn</span>(foo, <span class="string">&#x27;bar&#x27;</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">bar</span>); <span class="comment">//true——重新实现 hasOwnProperty() 不会影响 Object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它也可以用于测试使用 Object.create(null) 创建的对象。这些对象不会继承自 Object.prototype，因此 hasOwnProperty() 方法是无法访问的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">foo.<span class="property">prop</span> = <span class="string">&#x27;exists&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="title function_">hasOwn</span>(foo, <span class="string">&#x27;prop&#x27;</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">prop</span>); <span class="comment">//true——无论对象是如何创建的，它都可以运行。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="用undefined判断"><a href="#用undefined判断" class="headerlink" title="用undefined判断"></a>用undefined判断</h1><p>自有属性和继承属性均可判断。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o=&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line">o.<span class="property">x</span>!==<span class="literal">undefined</span>;        <span class="comment">//true</span></span><br><span class="line">o.<span class="property">y</span>!==<span class="literal">undefined</span>;        <span class="comment">//false</span></span><br><span class="line">o.<span class="property">toString</span>!==<span class="literal">undefined</span>  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>该方法存在一个问题，如果属性的值就是undefined的话，该方法不能返回想要的结果，如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o=&#123;<span class="attr">x</span>:<span class="literal">undefined</span>&#125;;</span><br><span class="line">o.<span class="property">x</span>!==<span class="literal">undefined</span>;        <span class="comment">//false，属性存在，但值是undefined</span></span><br><span class="line">o.<span class="property">y</span>!==<span class="literal">undefined</span>;        <span class="comment">//false</span></span><br><span class="line">o.<span class="property">toString</span>!==<span class="literal">undefined</span>  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h1 id="在条件语句中直接判断"><a href="#在条件语句中直接判断" class="headerlink" title="在条件语句中直接判断"></a>在条件语句中直接判断</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o=&#123;&#125;;</span><br><span class="line"><span class="keyword">if</span>(o.<span class="property">x</span>) &#123;   <span class="comment">//如果x是undefine,null,false,&quot; &quot;,0或NaN,它将保持不变</span></span><br><span class="line">o.<span class="property">x</span>+=<span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/06/30/cshap/I-O/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/30/cshap/I-O/" class="post-title-link" itemprop="url">I/O</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-30 16:44:23" itemprop="dateCreated datePublished" datetime="2023-06-30T16:44:23+08:00">2023-06-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-20 09:46:18" itemprop="dateModified" datetime="2023-07-20T09:46:18+08:00">2023-07-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="流体系结构"><a href="#流体系结构" class="headerlink" title="流体系结构"></a>流体系结构</h1><p>.NET流体系结构由三个概念组成：后端存储，装饰器以及适配器，如图1所示：</p>
<p> Stream类.NET中用于处理流的基类，Stream公开了一组用于读取、写入和定位的标准方法。与数组(数据同时存在于内存中)不同，流连续处理数据（一次一个字节或以可管理大小的块为单位）。因此，无论其后端存储的大小如何，流都可以使用少量的固定内存处理。</p>
<p><img src="441dba1fea629c0299c8442fe23232dce52948e3c2089cf0e372efdd1bda986c.png" alt="图 0">  </p>
<p><strong>流分为两类：</strong></p>
<ul>
<li>后端存储流：它们是与特定的后台存储类型连接的流，例如FileStream或者NetworkStream</li>
<li>装饰流：这些流会使用其他的流，并以某种方式转换数据。例如DeflateStream或者CryptoStream。</li>
</ul>
<p>后台存储是输入输出的终结点，例如文件或者网络连接。准确地说，它可以是以下的一种或者两种：</p>
<ul>
<li>支持顺序读取字节的源。</li>
<li>支持顺序写入字节的目标。</li>
</ul>
<p>装饰流具有下列的体系结构优点：</p>
<ul>
<li>将原来需要后端存储流自己实现例的功能(如压缩或是加密等)，剥离出来</li>
<li>当后端存储流被装饰后，后端存储流不再忍受接口变化的痛苦</li>
<li>我们在运行时连接到装饰器</li>
<li>我们可以将装饰器链接在一起</li>
</ul>
<p>后端存储与装饰器流以字节为单位进行处理。尽管这比较灵活与高效，但是程序通常在更高的层次上进行文本或XML的处理，因此需要适配器，将流封装到一个具有特定方法的类中，来实现文本或xml的处理。例如，一个文本读取器公开了一个ReadLine方法；一个XML写入器公开了WriteAttributes方法。</p>
<blockquote>
<p>总结起来就是，后端存储流提供了原始数据；装饰器流提供了透明的二进制转换，例如加密；适配器提供了类型方法来以更高级形式处理数据，例如字符串与XML。图1显示他们之间的关系。要形成一个链，我们只需要将一个对象传递给另一个对象的构造函数。</p>
</blockquote>
<h1 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h1><p>抽象的Stream类是所有流的基类。它的方法和属性定义了三种基本的操作：读、写、查找。除此之外，它还定义了一些管理性的任务，例如关闭、刷新（flush）和配置超时时间。</p>
<p><img src="cb397f8378359e0537bd842c3cb975ea276408e279bfae69dc29eea113272d42.png" alt="图 1">  </p>
<p>还有 Read 和 Write 方法的异步版本，它们都返回 Tasks 并可选择接受取消令牌。</p>
<h2 id="读取与写入"><a href="#读取与写入" class="headerlink" title="读取与写入"></a>读取与写入</h2><p>流可以支持读取，写入或者两者都支持。如果CanWrite为true，则流支持写入；如果CanRead为true，则流支持读取。</p>
<p>Read方法支持从流中读取数据块并存入数组。他返回所读取的字节数，返回值总是小于或是等于count参数。</p>
<p>如果返回值小于count，则意味着或者是到达了流的结尾，或者是流以更小的块向我们提供数据（在网络流中经常如此）。以上任何一种情况下，数组中的字节余额将保持未写入状态，保留之前的值。</p>
<p>使用 Read，您可以确定仅当该方法返回 0 时您已到达流的末尾。因此，如果您有一个1,000字节的流，以下代码可能无法将其全部读入内存：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assuming s is a stream:</span></span><br><span class="line"><span class="built_in">byte</span>[] data = <span class="keyword">new</span> <span class="built_in">byte</span> [<span class="number">1000</span>];</span><br><span class="line">s.Read (data, <span class="number">0</span>, data.Length);</span><br></pre></td></tr></table></figure>
<p>Read 方法可以读取 1 到 1,000 字节的任意位置，留下流的剩余部分未读。</p>
<p>下面是读取 1,000 字节流的正确方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">byte</span>[] data = <span class="keyword">new</span> <span class="built_in">byte</span> [<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// bytesRead will always end up at 1000, unless the stream is</span></span><br><span class="line"><span class="comment">// itself smaller in length:</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> bytesRead = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> chunkSize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (bytesRead &lt; data.Length &amp;&amp; chunkSize &gt; <span class="number">0</span>)</span><br><span class="line">    bytesRead +=</span><br><span class="line">		chunkSize = s.Read (data, bytesRead, data.Length - bytesRead);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>幸运的是，BinaryReader 类型提供了一种更简单的方法来实现相同的结果：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">byte</span>[] data = <span class="keyword">new</span> BinaryReader (s).ReadBytes (<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>如果流的长度小于 1,000 字节，则返回的字节数组反映实际的流大小。如果流是可搜索的，您可以通过将 1000 替换为 (int)s.Length 来读取其全部内容。</p>
<p>ReadByte 方法更简单：它只读取一个字节，返回 -1 以指示流的结尾。 ReadByte 实际上返回一个 int 而不是一个 byte，因为后者不能返回 −1。</p>
<p>Write 和 WriteByte 方法将数据发送到流。如果它们无法发送指定的字节，则会抛出异常。</p>
<blockquote>
<p>注意，在Read与Write方法中，offset参数指读取或写在buffer数组中开始的索引，而不是流中的位置。</p>
</blockquote>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>如果CanSeek方法返回true，则流是可定位的。对于可定位的流（例如文件流），我们可以查询或是修改其Length（通过调用SetLenght），并且在任何时刻修改我们正在读取或是写入的Position。</p>
<p>Position属性是相对于流的起始处的；然而，Seek方法可以使得我们相对于当前位置或是文件的结束处进行移动。</p>
<p>注意，在FileStream上改变Position通常会花费几毫秒的时间。如果我们在一个循环中执行几百万次，框架4.0中新的MemoryMappedFile类是比FileStream更好的选择。</p>
<p>对于不可定位的流（例如加密流），确定其长度的唯一方法就是完全读取。而且，如果我们需要重新读取前面的一部分，我们必须关闭流并重新读取。</p>
<h2 id="关闭与输出缓冲"><a href="#关闭与输出缓冲" class="headerlink" title="关闭与输出缓冲"></a>关闭与输出缓冲</h2><p>流在使用之后必须销毁来释放底层资源，例如文件或是套接字句柄。保证关闭流的最简单方法是在using块中实例化流。通常，流遵循标准的销毁语义：</p>
<ul>
<li>Dispose与Close在功能上是相同的</li>
<li>重复销毁或是关闭流不会引起错误</li>
</ul>
<p>关闭一个装饰器流会同时关闭装饰器以及其后端存储流。对于一个装饰器链，关闭最外层的装饰器（位于链的头部）会关闭整个装饰器链。</p>
<p>某些流在内部会缓冲要写入后端存储的数据或是由后端存储读取的数据来减少读取的来回次数从而改进性能（文件流就是一个好例子）。这意味着我们要写入流的数据也许并没有立即写入后端存储；写入会被延迟直到缓冲区被填满。Flush方法会强制在内部缓冲的数据被立即写入。Flush方法在流被关闭时自动调用的，所以我们不需要执行下面的语句：</p>
<p>s.Flush(); s.Close();</p>
<h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p>如果CanTimeout返回true，则流支持读写超时。网络支持超时；文件流与内存流则不支持。对于支持超时的流，ReadTimeout与WriteTimeout属性决定了所需要的超时时间，以毫秒计，0则为不超时。Read与Write方法通过抛出异常来表明发生了超时。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>作为一条规则，流不是线程安全的，意味着两个线程不能同时读取或是写入相同的流，以避免错误。Stream类通过静态的Synchronized方法提供了一个简单的解决办法。这个方法接受一个任意类型的流并返回一个线程安全的包装器。包装器通过获取读取，写入或是定位上的一个排他锁来进行工作，从而保证在任意时刻只有一个线程可以执行这样的操作。</p>
<h2 id="后端存储流"><a href="#后端存储流" class="headerlink" title="后端存储流"></a>后端存储流</h2><p>图2显示了.NET框架所提供的关键后端存储流。同时还有一个“空流”，是通过Stream的静态Null域来提供的。</p>
<p><img src="3dc184edab65c04d5ad20fc7a71555f6440068f641d92a4f76368fc075f7fd1c.png" alt="图 2">  </p>
<p>在以下部分中，我们将描述FileStream与MemoryStream；在本章的最后一部分，我们描述IsolatedStorageStream。</p>
<h2 id="FileStream"><a href="#FileStream" class="headerlink" title="FileStream"></a>FileStream</h2><h3 id="创建-FileStream"><a href="#创建-FileStream" class="headerlink" title="创建 FileStream"></a>创建 FileStream</h3><p>实例化FileStream的最简单的方法是使用File类型中的静态方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileStream fs1 = File.OpenRead  (<span class="string">&quot;readme.bin&quot;</span>);            <span class="comment">// Read-only</span></span><br><span class="line">FileStream fs2 = File.OpenWrite (<span class="string">@&quot;c:\temp\writeme.tmp&quot;</span>);  <span class="comment">// Write-only</span></span><br><span class="line">FileStream fs3 = File.Create    (<span class="string">@&quot;c:\temp\writeme.tmp&quot;</span>);  <span class="comment">// Read/write</span></span><br></pre></td></tr></table></figure>

<p>如果文件已经存在，那么OpenWrite和Create的行为是不同的。Create方法会删除其全部内容，而OpenWrite则会保留流中全部已有内容并将流的起始位置设置为0。如果我们写入的内容比原始文件内容长度还短，则OpenWrite执行之后其文件内容会同时包含新旧内容。</p>
<p>还可以直接实例化一个FileStream。它的构造器支持所有特性，例如允许指定文件名或者底层文件句柄、文件创建和访问模式、共享选项、缓冲选项以及安全性。例如，以下代码会直接打开一个已有文件进行读、写操作，而不会覆盖这个文件：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="keyword">new</span> FileStream(<span class="string">&quot;readwrite.tmp&quot;</span>, FileMode.Open);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下的静态方法能够将一个文件一次性读到内存中：</p>
<p>File.ReadAllText（返回字符串）<br>File.ReadAllLines（返回一个字符串数组）<br>File.ReadAllBytes（返回一个字节数组）</p>
<p>以下的静态方法能够一次性地写入一个完整的文件：<br>File.WriteAllText<br>File.WriteAllLines<br>File.WriteAllBytes<br>File.AppendAllText（适用于向日志文件中追加内容）</p>
</blockquote>
<h3 id="指定文件名"><a href="#指定文件名" class="headerlink" title="指定文件名"></a>指定文件名</h3><p>文件名可以是绝对路径（例如c:\temp\test.txt）也可以是相对当前目录的路径（例如，test.txt或者temp\test.txt）。可以访问Environment.CurrentDirectory属性来获得或者更改当前目录。</p>
<p>AppDomain.CurrentDomain.BaseDirectory属性会返回应用程序的基础目录（base directony），正常情况下它就是可执行文件所在的文件夹。结合使用Path.Combine方法就可以定位该目录下的文件名。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">string</span> baseFolder = AppDomain.CurrentDomain.BaseDirectory;</span><br><span class="line"><span class="built_in">string</span> tmp = Path.Combine(baseFolder, <span class="string">&quot;readwrite.tmp&quot;</span>);</span><br><span class="line">Console.WriteLine(File.Exists(tmp));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="指定FileMode"><a href="#指定FileMode" class="headerlink" title="指定FileMode"></a>指定FileMode</h3><p>FileStream类型每一个接受文件名的构造器都需要提供FileMode枚举参数。</p>
<p><img src="c229f7d8378c038fd944267998044bceff517a0017ac8118bf6e88d15cbdff1f.png" alt="图 3">  </p>
<p>如果用于隐藏文件，File.Create 和 FileMode.Create 将抛出异常。要覆盖隐藏文件，您必须删除并重新创建它：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File.Delete (<span class="string">&quot;hidden.txt&quot;</span>);</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> file = File.Create (<span class="string">&quot;hidden.txt&quot;</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在创建FileStream时若只提供文件名和FileMode将会得到一个可读可写的流（但有一种例外）。而如果传入了FileAccess参数，就可以对读写模式进行取舍了：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> FileAccess&#123;Read = <span class="number">1</span>, Write = <span class="number">2</span>, ReadWrite = <span class="number">3</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以下返回一个只读流，相当于调用 File.OpenRead：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> fs = <span class="keyword">new</span> FileStream (<span class="string">&quot;x.bin&quot;</span>, FileMode.Open, FileAccess.Read);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>FileMode.Append则是一个例外。这个模式只会得到只读的流。相反，如果既要追加内容，又希望支持读写的话，就需要使用FileMode.Open或者FileMode. OpenOrCreate，打开文件，并定位到流的结尾处：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> fs = <span class="keyword">new</span> FileStream(<span class="string">&quot;myFile.bin&quot;</span>, FileMode.Open))</span><br><span class="line">&#123;</span><br><span class="line">    fs.Seek(<span class="number">0</span>, SeekOrign.End);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FileStream的高级特性"><a href="#FileStream的高级特性" class="headerlink" title="FileStream的高级特性"></a>FileStream的高级特性</h3><p>创建FileSteam时可选的其他参数：</p>
<ul>
<li><p>FileShare枚举：描述了在完成文件处理之前，若其他进程希望访问该文件，则可以给其他进程授予的访问权限（None、Read、ReadWrite或者Write，其中Read为默认权限）。</p>
</li>
<li><p>内部缓冲区的大小（字节为单位，默认大小为4KB）。</p>
</li>
<li><p>是否由操作系统管理异步I&#x2F;O的标志。</p>
</li>
<li><p>FileSecurity对象，描述给新文件分配的用户角色和权限。</p>
</li>
<li><p>FileOptions标志枚举值，其中包括：请求操作系统加密（Encrypted），在文件关闭时自动删除临时文件（DeleteOnClose），以及优化提示（RandomAccess和SequentialScan）。此外还有一个WriteThrough标志可以要求操作系统禁用写后缓存，这适用于事物文件或日志文件的处理。</p>
</li>
</ul>
<p>使用FileShare.ReadWrite打开一个文件可以允许其他进程或用户读写同一个文件。为了避免混乱，我们可以使用以下方法在读或者写之前锁定文件的特定部分。</p>
<ul>
<li>public virtual void Lock (long postion, long length);</li>
<li>public virtual void Unlock (long postion, long length);</li>
</ul>
<p>如果所请求的文件部分已经被锁定了，Lock则抛出异常。这为系统用于基于文件的数据库，例如Access与FoxPro。</p>
<h2 id="MemoryStream"><a href="#MemoryStream" class="headerlink" title="MemoryStream"></a>MemoryStream</h2><p>MemoryStream使用数组作为后端存储。这在某种程度上破坏了拥有流的目的，因为整个的后端存储只在内存中存在一次。然而，MemoryStream依然有用；当我们需要随机访问一个不可定位的流时就是一个好例子。如果我们知道源流将是可管理尺寸的，那么我们就可以将其拷贝到MemoryStream中，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ms = <span class="keyword">new</span> MemoryStream();</span><br><span class="line">sourceStream.CopyTo (ms);</span><br></pre></td></tr></table></figure>
<p>我们可以通过调用ToArray将一个MemoryStream转换为一个字节数组。</p>
<p>GetBuffer方法通过直接引用底层存储数组可以高效的完成相同的工作；不幸的是，这个数组通常要长于流的实际长度。</p>
<h2 id="PipeStream"><a href="#PipeStream" class="headerlink" title="PipeStream"></a>PipeStream</h2><p>PipeStream 可以使用Windows管道协议与另一个进程进行通信。</p>
<p>管道类型有两种：</p>
<ul>
<li><p>匿名管道（速度快）：支持在同一个计算机中的父进程和子进程之间进行单向通信。</p>
</li>
<li><p>命名管道（更加灵活）：允许同一台计算机的任意两个进程之间，或者不同计算机（使用Windows网络）的两个进程间进行双向通信。</p>
</li>
</ul>
<p>管道很适合在同一台计算机进行进程间通信（IPC）：它不依赖于任何网络传输（因此没有网络协议开销），性能更好，也不会有防火墙问题。</p>
<blockquote>
<p>管道是基于流实现的，因此一个进程会等待接收字节，而另一个进程则负责发送字节。</p>
</blockquote>
<p>PipeStream是一个抽象类，它有4个子类。其中两个用于匿名管道而另外两个用于命名管道。</p>
<blockquote>
<p>匿名管道：AnonymousPipeServerStream和AnonymousPipeClientStream。</p>
</blockquote>
<blockquote>
<p>命名管道：NamedPipeServerStream和NamedPipeClientStream。</p>
</blockquote>
<h3 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h3><p>命管道可以让通信各方使用名称相同的管道进行通信。其协议定义了两种不同的角色：客户端与服务器。客户端和服务器之间的通信采用以下方式：</p>
<ul>
<li><p>服务器实例化一个NamedPipeServerStream，然后调用WaitForConnection方法。</p>
</li>
<li><p>客户端实例化一个NamedPipeClientStream，然后调用Connect（可提供可选的超时时间）。此后，双方就可以通过读写流进行通信了。</p>
</li>
</ul>
<p>服务端：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server pipe</span></span><br><span class="line">    <span class="keyword">using</span>(<span class="keyword">var</span> ns = <span class="keyword">new</span> NamedPipeServerStream(<span class="string">&quot;pipedream&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        ns.WaitForConnection();</span><br><span class="line">        ns.WriteByte(<span class="number">100</span>);</span><br><span class="line">        Console.WriteLine(ns.ReadByte());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client pipe</span></span><br><span class="line">   <span class="keyword">using</span> (<span class="keyword">var</span> ns = <span class="keyword">new</span> NamedPipeClientStream(<span class="string">&quot;pipedream&quot;</span>))</span><br><span class="line">   &#123;</span><br><span class="line">       ns.Connect();</span><br><span class="line">       Console.WriteLine(ns.ReadByte());</span><br><span class="line">       ns.WriteByte(<span class="number">200</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>命名管道流默认是双向通信的，因此任何一方都可以读或者写它们的流。这意味着客户端和服务器都必须统一使用一种协议来协调它们的操作，因此双方不能同时发送或者接收消息。</p>
<p>通信双方需要统一每一次传输的数据长度。上面的例子只传输了一个字节，如果要传输更长的数据，管道提供了一种消息传输模式。如果启用了这个模式，调用read的一方可以检查IsMessageComplete来确定消息是否传输完毕。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取pipstream中的完整消息</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">byte</span>[] <span class="title">ReadMessage</span>(<span class="params">PipeStream s</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MemoryStream ms = <span class="keyword">new</span> MemoryStream();</span><br><span class="line">    <span class="built_in">byte</span>[] buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        ms.Write(buffer, <span class="number">0</span>, s.Read(buffer, <span class="number">0</span>, buffer.Length));</span><br><span class="line">    &#125; <span class="keyword">while</span> (!s.IsMessageComplete);</span><br><span class="line">    <span class="keyword">return</span> ms.ToArray();</span><br><span class="line">&#125;         </span><br></pre></td></tr></table></figure>
<p>在服务器端，在创建流时指定PipeTransm-issionMode.Message就可以激活消息传输(这里还需要传入最大服务端数量)：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server pipe</span></span><br><span class="line"><span class="keyword">using</span>(<span class="keyword">var</span> ns = <span class="keyword">new</span> NamedPipeServerStream(<span class="string">&quot;pipedream&quot;</span>, PipeDirection.InOut, <span class="number">2</span>, PipeTransmissionMode.Message))</span><br><span class="line">&#123;</span><br><span class="line">    ns.WaitForConnection();</span><br><span class="line">    <span class="built_in">byte</span>[] msg = Encoding.UTF8.GetBytes(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    ns.Write(msg, <span class="number">0</span>, msg.Length);</span><br><span class="line">    Console.WriteLine(Encoding.UTF8.GetString(ReadMessage(ns)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在客户端，调用Connect之后设置ReadMode即可激活消息传输模式：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client pipe</span></span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> ns = <span class="keyword">new</span> NamedPipeClientStream(<span class="string">&quot;pipedream&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    ns.Connect();</span><br><span class="line">    ns.ReadMode = PipeTransmissionMode.Message;</span><br><span class="line">    Console.WriteLine(Encoding.UTF8.GetString(ReadMessage(ns)));</span><br><span class="line">    <span class="built_in">byte</span>[] msg = Encoding.UTF8.GetBytes(<span class="string">&quot;Hello right back!&quot;</span>);</span><br><span class="line">    ns.Write(msg, <span class="number">0</span>, msg.Length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="BufferedStream"><a href="#BufferedStream" class="headerlink" title="BufferedStream"></a>BufferedStream</h2><p>BufferedStream 装饰或包装另一个具有缓冲功能的流，它是 .NET 中的许多装饰器流类型之一，所有这些都在图 4 中进行了说明。</p>
<p><img src="8617d9de7bd400ac307cb25266a24acd8fedc3ee22928e8feb36e772371ccf3a.png" alt="图 4">  </p>
<p>缓冲通过减少到后备存储的往返行程来提高性能。以下是我们如何将 FileStream 包装在 20 KB BufferedStream 中：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write 100K to a file:</span></span><br><span class="line">File.WriteAllBytes (<span class="string">&quot;myFile.bin&quot;</span>, <span class="keyword">new</span> <span class="built_in">byte</span> [<span class="number">100000</span>]);</span><br><span class="line"><span class="keyword">using</span> (FileStream fs = File.OpenRead (<span class="string">&quot;myFile.bin&quot;</span>))</span><br><span class="line"><span class="keyword">using</span> (BufferedStream bs = <span class="keyword">new</span> BufferedStream (fs, <span class="number">20000</span>))  <span class="comment">//20K buffer</span></span><br><span class="line">&#123;</span><br><span class="line">  bs.ReadByte();</span><br><span class="line">  Console.WriteLine (fs.Position);         <span class="comment">// 20000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，由于读取缓冲(bs)，底层流(fs)在仅读取1个字节之后读取了20000个字节。我们可以在与FileStream再次交互之前调用ReadByte 19999次。</p>
<p>类似于这个示例，将BufferedStream与FileStream组合并没有太大我价值，因为FileStream已经具有内建的缓冲。他唯一的用处也许就是在已经构建的FileStream上增大缓冲。</p>
<p>关闭BufferedStream会自动关闭底层的后端存储流。</p>
<h1 id="流适配器"><a href="#流适配器" class="headerlink" title="流适配器"></a>流适配器</h1><p>Stream只能以字节方式进行处理；要读取或是写入例如字符串，整数或是XML元素这样的数据类型，我们必须借助于适配器。下面是框架所提供的适配：</p>
<ul>
<li>文本适配器（用于字符串与字符数据）：TextReader，TextWriter，StreamReader，StreamWriter，StringReader，StringWriter</li>
<li>二进制适配器（用于基础数据类型，例如int，bool，string与float）：BinaryReader，BinaryWriter</li>
<li>XML适配器：XmlReader，XmlWriter</li>
</ul>
<p><img src="a7d6931ec14582d1ec0e74381fc8e28a8f9933931e7d1ca4c3985e9a396a0349.png" alt="图 5">  </p>
<h2 id="TextReader与TextWriter"><a href="#TextReader与TextWriter" class="headerlink" title="TextReader与TextWriter"></a>TextReader与TextWriter</h2><p>TextReader与TextWriter是用于处理字符与字符串的适配器的抽象基类。在框架中，每一个都有两个通用目的的实现：</p>
<ul>
<li>StreamReader&#x2F;StreamWriter：使用Stream作为原始的数据源，将流字节转换为字符或是字符串</li>
<li>StringReader&#x2F;StringWriter：使用内存字符串实现了TextReader&#x2F;TextWriter</li>
</ul>
<p><img src="9bf9ea60c016c1bd0aae8a3defc296c332f856fb0bdffb3d6b5e1ed0422054e5.png" alt="图 6">  </p>
<p>表 15-2 按类别列出了 TextReader 的成员。 </p>
<ul>
<li>Peek 返回流中的下一个字符而不前进位置。如果在流的末尾，Peek 和 Read 的零参数版本都返回 -1；否则，它们返回一个可以直接转换为 char 的整数。</li>
<li>接受 char[] 缓冲区的 Read 重载在功能上与 ReadBlock 方法相同。 </li>
<li>ReadLine 读取直到到达 CR（字符 13）或 LF（字符 10），或顺序到达 CR+LF 对。然后它返回一个字符串，丢弃 CR&#x2F;LF 字符。</li>
</ul>
<p><img src="5226f8fac2ad929f6b2fe36fc9bb6b4225d3f15e4fbc8cf3ff20d4b8c2c54d48.png" alt="图 7">  </p>
<p>TextWriter 具有类似的写入方法，如表 15-3 所示。 </p>
<ul>
<li><p>Write 和 WriteLine 方法被额外重载以接受每个基本类型以及对象类型。这些方法只是对传入的任何内容调用 ToString 方法（可选地通过在调用方法或构造 TextWriter 时指定的 IFormatProvider）。</p>
</li>
<li><p>WriteLine 只是在给定文本后附加 Environment.NewLine。您可以通过 NewLine 属性更改它（这对于与 Unix 文件格式的互操作性很有用）。</p>
</li>
</ul>
<h2 id="StreamReader与StreamWriter"><a href="#StreamReader与StreamWriter" class="headerlink" title="StreamReader与StreamWriter"></a>StreamReader与StreamWriter</h2><p>在下面的示例中，StreamWriter向文件写入两行许可证，然后StreamReader读取这个文件：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (FileStream fs = File.Create (<span class="string">&quot;test.txt&quot;</span>))</span><br><span class="line"><span class="keyword">using</span> (TextWriter writer = <span class="keyword">new</span> StreamWriter (fs))</span><br><span class="line">&#123;</span><br><span class="line">  writer.WriteLine (<span class="string">&quot;Line1&quot;</span>);</span><br><span class="line">  writer.WriteLine (<span class="string">&quot;Line2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> (FileStream fs = File.OpenRead (<span class="string">&quot;test.txt&quot;</span>))</span><br><span class="line"><span class="keyword">using</span> (TextReader reader = <span class="keyword">new</span> StreamReader (fs))</span><br><span class="line">&#123;</span><br><span class="line">  Console.WriteLine (reader.ReadLine());       <span class="comment">// Line1</span></span><br><span class="line">  Console.WriteLine (reader.ReadLine());       <span class="comment">// Line2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为文本适配器经常与文件进行交互，File提供了静态的CreateText，AppendText以及OpenText来简化处理：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (TextWriter writer = File.CreateText (<span class="string">&quot;test.txt&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">  writer.WriteLine (<span class="string">&quot;Line1&quot;</span>);</span><br><span class="line">  writer.WriteLine (<span class="string">&quot;Line2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> (TextWriter writer = File.AppendText (<span class="string">&quot;test.txt&quot;</span>))</span><br><span class="line">  writer.WriteLine (<span class="string">&quot;Line3&quot;</span>);</span><br><span class="line"><span class="keyword">using</span> (TextReader reader = File.OpenText (<span class="string">&quot;test.txt&quot;</span>))</span><br><span class="line">  <span class="keyword">while</span> (reader.Peek() &gt; <span class="number">-1</span>)</span><br><span class="line">    Console.WriteLine (reader.ReadLine()); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Line1</span></span><br><span class="line">    <span class="comment">// Line2</span></span><br><span class="line">   <span class="comment">// Line3</span></span><br></pre></td></tr></table></figure>
<p>这同时演示了如何测试文件的结尾（通过reader.Peek()）。另一种方法就是一直读取直到reader.ReadLine返回null。</p>
<p>我们也可以读取或是写入其他的类型，例如整数，但是因为TextWriter在我们的类型上调用ToString方法，当我们重新读取时必须分析字符串：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (TextWriter w = File.CreateText (<span class="string">&quot;data.txt&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">  w.WriteLine (<span class="number">123</span>);          <span class="comment">// Writes &quot;123&quot;</span></span><br><span class="line">  w.WriteLine (<span class="literal">true</span>);         <span class="comment">// Writes the word &quot;true&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> (TextReader r = File.OpenText (<span class="string">&quot;data.txt&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span> myInt = <span class="built_in">int</span>.Parse (r.ReadLine());     <span class="comment">// myInt == 123</span></span><br><span class="line">  <span class="built_in">bool</span> yes = <span class="built_in">bool</span>.Parse (r.ReadLine());     <span class="comment">// yes == true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>TextReader与TextWriter仅是不具有到流或是后端存储连接的抽象类。然而，StreamReader与StreamWriter类型则连接到底层面向字节的流，所以他们必须在字符与字节之间进行转换。他们是通过System.Text名字空间听 Encoding类来完成的，我们可以在构建StreamReader或是StreamWriter时选择。如果我们没有选择，则使用默认的UTF-8编码。</p>
<p>最简单的编码是ASCII编码，因为每一个字符由一个字节表示。ASCII编码将Unicode集合中的前127个字符映射为单个字节，转换我们在US风格的键盘上所看到的字符。大多数其他的字符，包括特殊符号以及非英语字符不能被表示，并被转换为□字符。默认的UTF-8编码可以映射所有的Unicode字符，但是他更为复杂。为了与ASCII兼容，前127个字符被编码为单个字节；其余的字符被编码为变化的字节数（通常是两个或是三个）。例如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (TextWriter w = File.CreateText (<span class="string">&quot;but.txt&quot;</span>))    <span class="comment">// Use default UTF-8</span></span><br><span class="line">  w.WriteLine (<span class="string">&quot;but-&quot;</span>);                               <span class="comment">// encoding.</span></span><br><span class="line"><span class="keyword">using</span> (Stream s = File.OpenRead (<span class="string">&quot;but.txt&quot;</span>))</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> b; (b = s.ReadByte()) &gt; ?<span class="number">1</span>;)</span><br><span class="line">    Console.WriteLine (b);</span><br></pre></td></tr></table></figure>

<p>单词“but”之后并不是一个标准的连字符，而是一个更长的em dash字符(—)，U+2014。这不会使得我们的书本编辑器遇到麻烦。让我们看一下其输出：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">98</span>     <span class="comment">// b</span></span><br><span class="line"><span class="number">117</span>    <span class="comment">// u</span></span><br><span class="line"><span class="number">116</span>    <span class="comment">// t</span></span><br><span class="line"><span class="number">226</span>    <span class="comment">// em dash byte 1       Note that the byte values</span></span><br><span class="line"><span class="number">128</span>    <span class="comment">// em dash byte 2       are &gt;= 128 for each part</span></span><br><span class="line"><span class="number">148</span>    <span class="comment">// em dash byte 3       of the multibyte sequence.</span></span><br><span class="line"><span class="number">13</span>     <span class="comment">// &lt;CR&gt;</span></span><br><span class="line"><span class="number">10</span>     <span class="comment">// &lt;LF&gt;</span></span><br></pre></td></tr></table></figure>
<p>由于em dash位于Unicode集合中前127个字符之外，他要求更多个的字节来进行UTF-8编码（在这个示例中为三个）。</p>
<p>UTF-8足够表示西方字符，因为大多数字符仅需要一个字节。通过简单的忽略127以上的字符，他可以很容易的转换为ASCII字符。其缺点是在流中定位比较麻烦，因为一个字符的位置并不与流中其字节位置相对应。</p>
<p>另一种方法是UTF-16。下面是我们使用UTF-16编写相同的字符串：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (Stream s = File.Create (<span class="string">&quot;but.txt&quot;</span>))</span><br><span class="line"><span class="keyword">using</span> (TextWriter w = <span class="keyword">new</span> StreamWriter (s, Encoding.Unicode))</span><br><span class="line">    w.WriteLine (<span class="string">&quot;but-&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">byte</span> b <span class="keyword">in</span> File.ReadAllBytes (<span class="string">&quot;but.txt&quot;</span>))</span><br><span class="line">    Console.WriteLine (b);</span><br><span class="line"></span><br><span class="line">输出如下：</span><br><span class="line"></span><br><span class="line"><span class="number">255</span> <span class="comment">// Byte-order mark 1</span></span><br><span class="line"><span class="number">254</span> <span class="comment">// Byte-order mark 2</span></span><br><span class="line"><span class="number">98</span>  <span class="comment">// &#x27;b&#x27; byte 1</span></span><br><span class="line"><span class="number">0</span>   <span class="comment">// &#x27;b&#x27; byte 2</span></span><br><span class="line"><span class="number">117</span> <span class="comment">// &#x27;u&#x27; byte 1</span></span><br><span class="line"><span class="number">0</span>   <span class="comment">// &#x27;u&#x27; byte 2</span></span><br><span class="line"><span class="number">116</span> <span class="comment">// &#x27;t&#x27; byte 1</span></span><br><span class="line"><span class="number">0</span>   <span class="comment">// &#x27;t&#x27; byte 2</span></span><br><span class="line"><span class="number">20</span>  <span class="comment">// &#x27;--&#x27; byte 1</span></span><br><span class="line"><span class="number">32</span>  <span class="comment">// &#x27;--&#x27; byte 2</span></span><br><span class="line"><span class="number">13</span>  <span class="comment">// &lt;CR&gt; byte 1</span></span><br><span class="line"><span class="number">0</span>   <span class="comment">// &lt;CR&gt; byte 2</span></span><br><span class="line"><span class="number">10</span>  <span class="comment">// &lt;LF&gt; byte 1</span></span><br><span class="line"><span class="number">0</span>   <span class="comment">// &lt;LF&gt; byte 2</span></span><br></pre></td></tr></table></figure>

<p>从技术上讲，UTF-16 每个字符使用两个或四个字节（分配或保留了近一百万个 Unicode 字符，因此两个字节并不总是足够的）。但是，由于 C# char 类型本身只有 16 位宽，UTF-16 编码将始终为每个 .NET char 使用恰好两个字节。这使得跳转到流中的特定字符索引变得容易。</p>
<p>UTF-16 使用双字节前缀来标识字节对是以“小端”还是“大端”顺序写入的（最低有效字节在前或最高有效字节在前）。默认的小端顺序是基于 Windows 的系统的标准顺序。</p>
<h2 id="StringReader与StringWriter"><a href="#StringReader与StringWriter" class="headerlink" title="StringReader与StringWriter"></a>StringReader与StringWriter</h2><p>StringReader与StringWriter并没有封装流；相反，他们使用字符串或是StringBuilder作为底层数据存储。这就意味着并不需要字节转换－事实上，除了我们使用字符串或是StringBuilder结合索引变量很容易实现的事情以外，这个类并不能做其他事情。他们的优点是与StreamReader&#x2F;StringWriter共享相同的基类。例如，假设我们有一个包含XML的字符串，并且希望使用XmlReader进行分析。XmlReader.Create可以接受下列中的一个：</p>
<ul>
<li>URI</li>
<li>流</li>
<li>TextReader</li>
</ul>
<p>那么，我们如何对字符串进行 XML 解析？因为 StringReader 是 TextReader 的子类，所以我们很幸运。我们可以实例化并传入一个 StringReader，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XmlReader r = XmlReader.Create (<span class="keyword">new</span> StringReader (myString));</span><br></pre></td></tr></table></figure>

<h2 id="二进制适配器"><a href="#二进制适配器" class="headerlink" title="二进制适配器"></a>二进制适配器</h2><p>BinaryReader与BinaryWriter可以读取与写入本地数据类型：bool，byte，char，decimal，float，double，short，int，long，sbyte，ushort，unit与ulong，以及string和基础数据类型的数组。</p>
<p>与 StreamReader 和 StreamWriter 不同，二进制适配器有效地存储原始数据类型，因为它们在内存中表示。因此，一个 int 使用四个字节； double 使用八个字节。字符串是通过文本编码（与 StreamReader 和 StreamWriter 一样）写入的，但带有长度前缀，这样就可以在不需要特殊分隔符的情况下读回一系列字符串。</p>
<p>假定我们有一个简单的类型，定义如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以将以下方法添加到 Person 以使用二进制适配器将其数据保存到流中&#x2F;从流中加载数据：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveData</span> (<span class="params">Stream s</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> w = <span class="keyword">new</span> BinaryWriter (s);</span><br><span class="line">    w.Write (Name);</span><br><span class="line">    w.Write (Age);</span><br><span class="line">    w.Write (Height);</span><br><span class="line">    w.Flush(); <span class="comment">// Ensure the BinaryWriter buffer is cleared.</span></span><br><span class="line">               <span class="comment">// We won&#x27;t dispose/close it, so more data</span></span><br><span class="line">&#125; <span class="comment">// can be written to the stream.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadData</span> (<span class="params">Stream s</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> r = <span class="keyword">new</span> BinaryReader (s);</span><br><span class="line">    Name = r.ReadString();</span><br><span class="line">    Age = r.ReadInt32();</span><br><span class="line">    Height = r.ReadDouble();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BinaryReader 也可以读入字节数组。下面读取一个可搜索流的全部内容：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">byte</span>[] data = <span class="keyword">new</span> BinaryReader (s).ReadBytes ((<span class="built_in">int</span>) s.Length);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这比直接从流中读取更方便，因为它不需要循环来确保所有数据都已被读取。</p>
<h2 id="关闭与销毁流适配器"><a href="#关闭与销毁流适配器" class="headerlink" title="关闭与销毁流适配器"></a>关闭与销毁流适配器</h2><p>关闭流适配器时我们下列四个选择：</p>
<ul>
<li>仅关闭适配器</li>
<li>关闭适配器，然后关闭流</li>
<li>（对于写入）调用适配器的Flush（）方法（输出缓冲），然后关闭流</li>
<li>（对于读取）仅关闭流</li>
</ul>
<p>选项1与2在语义是上相同的，因为关闭适配器会自动关闭底层流。当我们嵌入using语句时，我们隐式的选择了选项2：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (FileStream fs = File.Create (<span class="string">&quot;test.txt&quot;</span>))</span><br><span class="line"><span class="keyword">using</span> (TextWriter writer = <span class="keyword">new</span> StreamWriter (fs))</span><br><span class="line">  writer.WriteLine (<span class="string">&quot;Line&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>由于嵌入语句是由里向外销毁，所以适配器被首先关闭，然后是流。而且，如果在适配器的构造器中抛出异常，流仍然关闭。嵌入的using语句很难遇到错误。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (FileStream fs = <span class="keyword">new</span> FileStream (<span class="string">&quot;test.txt&quot;</span>, FileMode.Create))</span><br><span class="line">&#123;</span><br><span class="line">  StreamWriter writer = <span class="keyword">new</span> StreamWriter (fs);</span><br><span class="line">  writer.WriteLine (<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  writer.Flush();</span><br><span class="line">  fs.Position = <span class="number">0</span>;</span><br><span class="line">  Console.WriteLine (fs.ReadByte());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们写入文件，重新定位流，并且在关闭流之前读取第一个字节。如果我们销毁StreamWriter，他也会关闭底层的FileStream，从而例程后续的读取操作失败。这样做的限制则是我们调用Flush来保证StreamWriter的缓冲被写入底层流中。</p>
<p>StreamReader&#x2F;StreamWriter 上还有一个构造函数，指示它在处理后保持流打开。因此，我们可以将前面的例子重写如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> fs = <span class="keyword">new</span> FileStream (<span class="string">&quot;test.txt&quot;</span>, FileMode.Create))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> writer = <span class="keyword">new</span> StreamWriter (fs, <span class="keyword">new</span> UTF8Encoding (<span class="literal">false</span>, <span class="literal">true</span>), <span class="number">0x400</span>, <span class="literal">true</span>))</span><br><span class="line">    writer.WriteLine (<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    fs.Position = <span class="number">0</span>;</span><br><span class="line">    Console.WriteLine (fs.ReadByte());</span><br><span class="line">    Console.WriteLine (fs.Length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>FileSteam：内部缓冲区的大小（字节为单位，默认大小为4KB）</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
