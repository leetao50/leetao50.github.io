<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"leetao50.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
<meta property="og:type" content="website">
<meta property="og:title" content="InfoPool">
<meta property="og:url" content="https://leetao50.github.io/page/5/index.html">
<meta property="og:site_name" content="InfoPool">
<meta property="og:description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
<meta property="og:locale" content="zh_CN">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://leetao50.github.io/page/5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>InfoPool</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">InfoPool</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">私人信息记录</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">记录信息来源网络，内容只为方便查找，非公开信息，非请勿入</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2022/12/14/ABP/abp-%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%8EABP%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/14/ABP/abp-%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%8EABP%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">abp-现代软件开发与ABP框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-14 17:36:00" itemprop="dateCreated datePublished" datetime="2022-12-14T17:36:00+08:00">2022-12-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-11 17:56:10" itemprop="dateModified" datetime="2023-03-11T17:56:10+08:00">2023-03-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>构建软件系统一直很复杂。尤其是在现代，即使是创建一个基本的业务解决方案，也面临着许多挑战。您通常会发现自己实现了标准的非业务需求，并深入研究了基础架构问题，而不是实现了业务代码（这是您试图构建的系统中真正有价值的部分）。</p>
<p>ABP框架通过提供强大的软件架构、自动化重复的细节以及提供必要的基础设施来帮助构建现代web解决方案，帮助您专注于为利益相关者增加价值的代码。它提供了端到端、一致的开发体验，并提高了您的生产力。ABP帮助您和您的团队<br>加快所有预先应用的现代软件开发最佳实践。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2022/12/14/ABP/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/14/ABP/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">数据传输对象</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-14 13:52:12" itemprop="dateCreated datePublished" datetime="2022-12-14T13:52:12+08:00">2022-12-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-11 17:56:10" itemprop="dateModified" datetime="2023-03-11T17:56:10+08:00">2023-03-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>数据传输对象(DTO)用于在应用层和表示层或其他类型的客户端之间传输数据.</p>
<p>通常用DTO作为参数在表示层(可选)调用应用服务. 它使用领域对象执行某些特定的业务逻辑,并(可选)将DTO返回到表示层.因此表示层与领域层完全隔离.</p>
<h2 id="数据隐藏"><a href="#数据隐藏" class="headerlink" title="数据隐藏"></a>数据隐藏</h2><p>假设你有一个具有属性Id,名称,电子邮件地址和密码的 User 实体. 如果 UserAppService 的 GetAllUsers() 方法返回 List<User>,任何人都可以访问你所有用户的密码,即使你没有在屏幕上显示它. 这不仅关乎安全,还关乎数据隐藏. 应用程序服务应该只返回表示层(或客户端)所需要的内容,不多也不少.</User></p>
<h2 id="序列化和延迟加载问题"><a href="#序列化和延迟加载问题" class="headerlink" title="序列化和延迟加载问题"></a>序列化和延迟加载问题</h2><p>当你将数据(一个对象)返回到表示层时,它很可能是序列化的. 例如在返回JSON的REST API中,你的对象将被序列化为JSON并发送给客户端. 在这方面将实体返回到表示层可能会有问题,尤其是在使用关系数据库和像Entity Framework Core这样的ORM提供者时.</p>
<p>在真实的应用程序中你的实体可以相互引用. User 实体可以引用它的角色. 如果你想序列化用户,它的角色也必须是序列化的. Role 类可以有 List <Permission>,而 Permission 类可以有一个对 PermissionGroup 类的引用,依此类推…想象一下所有这些对象都被立即序列化了. 你可能会意外地序列化整个数据库! 同样,如果你的对象具有循环引用,则它们可能根本不会序列化成功.</Permission></p>
<p>几乎所有的O&#x2F;RM框架都支持延迟加载. 此功能可在需要时从数据库加载实体. 假设 User 类具有对 Role 类的引用. 当你从数据库中获取用户时,Role 属性(或集合)不会被立即填充. 首次读取 Role 属性时,它是从数据库加载的. 因此如果将这样的实体返回到表示层,它将通过执行额外的查询从数据库中检索额外的实体. 如果序列化工具读取实体,它会递归读取所有属性,并且可以再次检索整个数据库(如果实体之间存在关系).</p>
<p>如果在表示层中使用实体,可能会出现更多问题.最好不要在表示层中引用领域&#x2F;业务层程序集.</p>
<p>ABP并不强迫你使用DTO,但是强烈建议将DTO作为最佳实践.</p>
<h2 id="标准接口和基类"><a href="#标准接口和基类" class="headerlink" title="标准接口和基类"></a>标准接口和基类</h2><p>DTO是一个没有依赖性的简单类,你可以用任何方式进行设计. 但是ABP引入了一些接口来确定命名标准属性和基类的约定,以免在声明公共属性时重复工作.</p>
<h3 id="实体相关DTO"><a href="#实体相关DTO" class="headerlink" title="实体相关DTO"></a>实体相关DTO</h3><p>通常你需要创建与你的实体相对应的DTO,从而生成与实体类似的类. ABP框架在创建DTO时提供了一些基类来简化.</p>
<h3 id="EntityDto"><a href="#EntityDto" class="headerlink" title="EntityDto"></a>EntityDto</h3><p>IEntityDto<TKey> 是一个只定义 Id 属性的简单接口. 你可以实现它或从 EntityDto<TKey> 继承.</TKey></TKey></p>
<h3 id="审计DTO"><a href="#审计DTO" class="headerlink" title="审计DTO"></a>审计DTO</h3><p>如果你的实体继承自被审计的实体类(或实现审计接口)可以使用以下基类来创建DTO:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CreationAuditedEntityDto</span><br><span class="line">CreationAuditedEntityWithUserDto</span><br><span class="line">AuditedEntityDto</span><br><span class="line">AuditedEntityWithUserDto</span><br><span class="line">FullAuditedEntityDto</span><br><span class="line">FullAuditedEntityWithUserDto</span><br></pre></td></tr></table></figure>
<h3 id="可扩展的DTO"><a href="#可扩展的DTO" class="headerlink" title="可扩展的DTO"></a>可扩展的DTO</h3><p>如果你想为你的DTO使用对象扩展系统,你可以使用或继承以下DTO类:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ExtensibleObject 实现 IHasExtraProperties (其它类继承这个类).</span><br><span class="line">ExtensibleEntityDto</span><br><span class="line">ExtensibleCreationAuditedEntityDto</span><br><span class="line">ExtensibleCreationAuditedEntityWithUserDto</span><br><span class="line">ExtensibleAuditedEntityDto</span><br><span class="line">ExtensibleAuditedEntityWithUserDto</span><br><span class="line">ExtensibleFullAuditedEntityDto</span><br><span class="line">ExtensibleFullAuditedEntityWithUserDto</span><br></pre></td></tr></table></figure>
<h3 id="列表结果"><a href="#列表结果" class="headerlink" title="列表结果"></a>列表结果</h3><p>通常将DTO列表返回给客户端. IListResult<T> 接口和 ListResultDto<T> 类用于使其成为标准.</T></T></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">AbpDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProductAppService</span> : <span class="title">ApplicationService</span>, <span class="title">IProductAppService</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IRepository&lt;Product, Guid&gt; _productRepository;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ProductAppService</span>(<span class="params">IRepository&lt;Product, Guid&gt; productRepository</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _productRepository = productRepository;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ListResultDto&lt;ProductDto&gt;&gt; GetListAsync()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Get entities from the repository</span></span><br><span class="line">            List&lt;Product&gt; products = <span class="keyword">await</span> _productRepository.GetListAsync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Map entities to DTOs</span></span><br><span class="line">            List&lt;ProductDto&gt; productDtos =</span><br><span class="line">                ObjectMapper.Map&lt;List&lt;Product&gt;, List&lt;ProductDto&gt;&gt;(products);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Return the result</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ListResultDto&lt;ProductDto&gt;(productDtos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以简单地返回 productDtos 对象(并更改方法的返回类型), 这也没有错. 返回一个 ListResultDto 会使List<ProductDto> 做为 Item 属性包装到另一个对象中. 这具有一个优点:以后可以在不破坏远程客户端的情况下(当它们作为JSON结果获得值时)在返回值中添加更多属性. 在开发可重用的应用程序模块时特别建议使用这种方式.</ProductDto></p>
<h3 id="分页-amp-排序列表结果"><a href="#分页-amp-排序列表结果" class="headerlink" title="分页 &amp; 排序列表结果"></a>分页 &amp; 排序列表结果</h3><p>从服务器请求分页列表并将分页列表返回给客户端是更常见的情况. ABP定义了一些接口和类来对其进行标准化:</p>
<h4 id="输入-请求-类型"><a href="#输入-请求-类型" class="headerlink" title="输入 (请求) 类型"></a>输入 (请求) 类型</h4><p>建议你继承以下基类DTO类之一,而不是手动实现接口:</p>
<ul>
<li>LimitedResultRequestDto 实现了 ILimitedResultRequest.</li>
<li>PagedResultRequestDto 实现了 IPagedResultRequest (和继承自 LimitedResultRequestDto).</li>
<li>PagedAndSortedResultRequestDto 实现了 IPagedAndSortedResultRequest (和继承自 PagedResultRequestDto).</li>
</ul>
<h4 id="最大返回数量"><a href="#最大返回数量" class="headerlink" title="最大返回数量"></a>最大返回数量</h4><p>LimitedResultRequestDto(和其它固有的)通过以下规则限制和验证 MaxResultCount;</p>
<p>最大返回数量<br>LimitedResultRequestDto(和其它固有的)通过以下规则限制和验证 MaxResultCount;</p>
<ul>
<li>如果客户端未设置 MaxResultCount,则假定为10(默认页面大小). 可以通过设置 LimitedResultRequestDto.DefaultMaxResultCount 静态属性来更改此值.</li>
<li>如果客户端发送的 MaxResultCount 大于1,000,则会产生验证错误. 保护服务器免受滥用服务很重要. 如果需要可以通过设置 LimitedResultRequestDto.MaxMaxResultCount 静态属性来更改此值.</li>
</ul>
<p>建议在应用程序启动时设置静态属性,因为它们是静态的(全局).</p>
<h4 id="输出-响应-类型"><a href="#输出-响应-类型" class="headerlink" title="输出 (响应) 类型"></a>输出 (响应) 类型</h4><p>以下接口和类用于标准化发送给客户端的输出.</p>
<p>建议你继承以下基类DTO类之一,而不是手动实现接口:</p>
<ul>
<li>PagedResultDto<T> 继承自 ListResultDto<T> 和实现了 IPagedResult<T>.</T></T></T></li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>你可以自由设计DTO类,然而这里有一些你可能想要遵循的最佳实践和建议.</p>
<h3 id="共同原则"><a href="#共同原则" class="headerlink" title="共同原则"></a>共同原则</h3><ul>
<li><p>DTO应该是可序列化的,因为它们通常是序列化和反序列化的(JSON或其他格式). 如果你有另一个带参数的构造函数,建议使用空(无参数)的公共构造函数.</p>
</li>
<li><p>除某些验证代码外,DTO不应包含任何业务逻辑.</p>
</li>
<li><p>DTO不要继承实体,也不要引用实体. 应用程序启动模板已经通过分隔项目来阻止它.</p>
</li>
<li><p>如果你使用自动对象到对象映射库,如AutoMapper,请启用映射配置验证以防止潜在的错误.</p>
</li>
<li><h3 id="输入DTO原则"><a href="#输入DTO原则" class="headerlink" title="输入DTO原则"></a>输入DTO原则</h3></li>
<li><p>只定义用例所需的属性. 不要包含不用于用例的属性,这样做会使开发人员感到困惑.</p>
</li>
<li><p>不要在不同的应用程序服务方法之间重用输入DTO. 因为不同的用例将需要和使用DTO的不同属性.</p>
</li>
</ul>
<h3 id="输出DTO原则"><a href="#输出DTO原则" class="headerlink" title="输出DTO原则"></a>输出DTO原则</h3><p>如果在所有情况下填充所有属性,就可以重用输出DTO.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2022/12/14/ABP/%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/14/ABP/%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1/" class="post-title-link" itemprop="url">应用服务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-14 13:33:08" itemprop="dateCreated datePublished" datetime="2022-12-14T13:33:08+08:00">2022-12-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-11 17:56:10" itemprop="dateModified" datetime="2023-03-11T17:56:10+08:00">2023-03-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>应用服务实现应用程序的用例, 将领域层逻辑公开给表示层.</p>
<p>假设你有一个Book实体(聚合根), 如下所示:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Book</span> : <span class="title">AggregateRoot</span>&lt;<span class="title">Guid</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> MaxNameLength = <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> BookType Type &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">float</span>? Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Book</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span>(<span class="params">Guid id, [NotNull] <span class="built_in">string</span> name, BookType type, <span class="built_in">float</span>? price = <span class="number">0</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Id = id;</span><br><span class="line">        Name = CheckName(name);</span><br><span class="line">        Type = type;</span><br><span class="line">        Price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ChangeName</span>(<span class="params">[NotNull] <span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = CheckName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">CheckName</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrWhiteSpace(name))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">$&quot;name can not be empty or white space!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (name.Length &gt; MaxNameLength)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">$&quot;name can not be longer than <span class="subst">&#123;MaxNameLength&#125;</span> chars!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IBookAppService接口"><a href="#IBookAppService接口" class="headerlink" title="IBookAppService接口"></a>IBookAppService接口</h2><p>在ABP中应用程序服务应该实现IApplicationService接口. 推荐每个应用程序服务创建一个接口:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IBookAppService</span> : <span class="title">IApplicationService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Task <span class="title">CreateAsync</span>(<span class="params">CreateBookDto input</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将实现Create方法作为示例. CreateBookDto定义如下:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CreateBookDto</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Required</span>]</span><br><span class="line">    [<span class="meta">StringLength(Book.MaxNameLength)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BookType Type &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span>? Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BookAppService-实现"><a href="#BookAppService-实现" class="headerlink" title="BookAppService(实现)"></a>BookAppService(实现)</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BookAppService</span> : <span class="title">ApplicationService</span>, <span class="title">IBookAppService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IRepository&lt;Book, Guid&gt; _bookRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookAppService</span>(<span class="params">IRepository&lt;Book, Guid&gt; bookRepository</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _bookRepository = bookRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">CreateAsync</span>(<span class="params">CreateBookDto input</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> book = <span class="keyword">new</span> Book(</span><br><span class="line">            GuidGenerator.Create(),</span><br><span class="line">            input.Name,</span><br><span class="line">            input.Type,</span><br><span class="line">            input.Price</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> _bookRepository.InsertAsync(book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>BookAppService继承了基类ApplicationService· 这不是必需的, 但是ApplicationService提供了应用服务常见的需求(比如本示例服务中使用的GuidGenerator). 如果不继承它, 我们需要在服务中手动注入IGuidGenerator</li>
<li>BookAppService按照预期实现了IBookAppService</li>
<li>BookAppService 注入了 IRepository&lt;Book, Guid&gt;(请参见仓储)在CreateAsync方法内部使用仓储将新实体插入数据库.</li>
<li>CreateAsync使用Book实体的构造函数从给定的Input值创建新的Book对象</li>
</ul>
<h2 id="数据传输对象"><a href="#数据传输对象" class="headerlink" title="数据传输对象"></a>数据传输对象</h2><p>应用服务使用并返回DTO而不是实体. ABP不会强制执行此规则. 但是将实体暴露给表示层(或远程客户端)存在重大问题, 所以不建议返回实体.</p>
<h2 id="CRUD应用服务"><a href="#CRUD应用服务" class="headerlink" title="CRUD应用服务"></a>CRUD应用服务</h2><p>如果需要创建具有Create,Update,Delete和Get方法的简单CRUD应用服务,则可以使用ABP的基类轻松构建服务. 你可以继承CrudAppService.</p>
<p>创建继承ICrudAppService接口的IBookAppService接口.</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IBookAppService</span> : </span><br><span class="line">    <span class="title">ICrudAppService</span>&lt; //<span class="title">Defines</span> <span class="title">CRUD</span> <span class="title">methods</span></span><br><span class="line">        <span class="title">BookDto</span>, //<span class="title">Used</span> <span class="title">to</span> <span class="title">show</span> <span class="title">books</span></span><br><span class="line">        <span class="title">Guid</span>, //<span class="title">Primary</span> <span class="title">key</span> <span class="title">of</span> <span class="title">the</span> <span class="title">book</span> <span class="title">entity</span></span><br><span class="line">        <span class="title">PagedAndSortedResultRequestDto</span>, //<span class="title">Used</span> <span class="title">for</span> <span class="title">paging</span>/<span class="title">sorting</span> <span class="title">on</span> <span class="title">getting</span> <span class="title">a</span> <span class="title">list</span> <span class="title">of</span> <span class="title">books</span></span><br><span class="line">        <span class="title">CreateUpdateBookDto</span>, //<span class="title">Used</span> <span class="title">to</span> <span class="title">create</span> <span class="title">a</span> <span class="title">new</span> <span class="title">book</span></span><br><span class="line">        <span class="title">CreateUpdateBookDto</span>&gt; <span class="comment">//Used to update a book</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ICrudAppService 有泛型参数来获取实体的主键类型和CRUD操作的DTO类型(它不获取实体类型,因为实体类型未向客户端公开使用此接口).</p>
<p>最后BookAppService实现非常简单:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BookAppService</span> : </span><br><span class="line">    <span class="title">CrudAppService</span>&lt;<span class="title">Book</span>, <span class="title">BookDto</span>, <span class="title">Guid</span>, <span class="title">PagedAndSortedResultRequestDto</span>,</span><br><span class="line">                        <span class="title">CreateUpdateBookDto</span>, <span class="title">CreateUpdateBookDto</span>&gt;,</span><br><span class="line">    <span class="title">IBookAppService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookAppService</span>(<span class="params">IRepository&lt;Book, Guid&gt; repository</span>) </span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">repository</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CrudAppService实现了ICrudAppService接口中声明的所有方法. 然后,你可以添加自己的自定义方法或重写和自定义实现.</p>
<h2 id="AbstractKeyCrudAppService"><a href="#AbstractKeyCrudAppService" class="headerlink" title="AbstractKeyCrudAppService"></a>AbstractKeyCrudAppService</h2><p>CrudAppService 要求你的实体拥有一个Id属性做为主键. 如果你使用的是复合主键,那么你无法使用它.</p>
<p>AbstractKeyCrudAppService 实现了相同的 ICrudAppService 接口,但它没有要求实体有主键.</p>
<p>假设你有实体 District,它的CityId 和 Name 做为复合主键,使用 AbstractKeyCrudAppService 时需要你自己实现 DeleteByIdAsync 和 GetEntityByIdAsync 方法:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DistrictAppService</span></span><br><span class="line">    : <span class="title">AbstractKeyCrudAppService</span>&lt;<span class="title">District</span>, <span class="title">DistrictDto</span>, <span class="title">DistrictKey</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DistrictAppService</span>(<span class="params">IRepository&lt;District&gt; repository</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">repository</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">async</span> <span class="keyword">override</span> Task <span class="title">DeleteByIdAsync</span>(<span class="params">DistrictKey id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> Repository.DeleteAsync(d =&gt; d.CityId == id.CityId &amp;&amp; d.Name == id.Name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">async</span> <span class="keyword">override</span> Task&lt;District&gt; <span class="title">GetEntityByIdAsync</span>(<span class="params">DistrictKey id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> AsyncQueryableExecuter.FirstOrDefaultAsync(</span><br><span class="line">            Repository.Where(d =&gt; d.CityId == id.CityId &amp;&amp; d.Name == id.Name)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个实现需要你创建一个类做为复合键:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DistrictKey</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Guid CityId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>应用服务的生命周期是transient的,它们会自动注册到依赖注入系统.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>将实体对象作为方法参数，而不是其id值。如果接受其id值，则需要从领域服务内的数据库中检索实体。这种方法使应用程序代码在同一请求（用例）的不同位置多次加载同一实体，这是低效的，并导致错误。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2022/12/14/ABP/%E8%A7%84%E7%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/14/ABP/%E8%A7%84%E7%BA%A6/" class="post-title-link" itemprop="url">规约</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-14 11:11:18" itemprop="dateCreated datePublished" datetime="2022-12-14T11:11:18+08:00">2022-12-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-11 17:56:10" itemprop="dateModified" datetime="2023-03-11T17:56:10+08:00">2023-03-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>规约模式用于为实体和其他业务对象定义 命名、可复用、可组合和可测试的过滤器 .<br>规约是领域层的一部分.</p>
<h2 id="定义规约"><a href="#定义规约" class="headerlink" title="定义规约"></a>定义规约</h2><p>你可以创建一个由 Specification<Customer> 派生的新规约类.</Customer></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Age18PlusCustomerSpecification</span> : <span class="title">Specification</span>&lt;<span class="title">Customer</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> Expression&lt;Func&lt;Customer, <span class="built_in">bool</span>&gt;&gt; ToExpression()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> c =&gt; c.Age &gt;= <span class="number">18</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以直接实现ISpecification<T>接口,但是基类Specification<T>做了大量简化.</T></T></p>
<h2 id="使用规约"><a href="#使用规约" class="headerlink" title="使用规约"></a>使用规约</h2><p>这里有两种常见的规约用例.</p>
<h3 id="IsSatisfiedBy"><a href="#IsSatisfiedBy" class="headerlink" title="IsSatisfiedBy"></a>IsSatisfiedBy</h3><p>IsSatisfiedBy 方法可以用于检查单个对象是否满足规约.</p>
<p>例如:如果顾客不满足年龄规定,则抛出异常</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomerService</span> : <span class="title">ITransientDependency</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">BuyAlcohol</span>(<span class="params">Customer customer</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">new</span> Age18PlusCustomerSpecification().IsSatisfiedBy(customer))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(</span><br><span class="line">                    <span class="string">&quot;这位顾客不满足年龄规定!&quot;</span></span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//TODO...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ToExpression-amp-Repositories"><a href="#ToExpression-amp-Repositories" class="headerlink" title="ToExpression &amp; Repositories"></a>ToExpression &amp; Repositories</h3><p>ToExpression() 方法可用于将规约转化为表达式.通过这种方式,你可以使用规约在数据库查询时过滤实体.</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomerManager</span> : <span class="title">DomainService</span>, <span class="title">ITransientDependency</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IRepository&lt;Customer, Guid&gt; _customerRepository;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomerManager</span>(<span class="params">IRepository&lt;Customer, Guid&gt; customerRepository</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _customerRepository = customerRepository;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">async</span> Task&lt;List&lt;Customer&gt;&gt; GetCustomersCanBuyAlcohol()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> queryable = <span class="keyword">await</span> _customerRepository.GetQueryableAsync();</span><br><span class="line">            <span class="keyword">var</span> query = queryable.Where(</span><br><span class="line">                <span class="keyword">new</span> Age18PlusCustomerSpecification().ToExpression()</span><br><span class="line">            );</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> AsyncExecuter.ToListAsync(query);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>规约被正确地转换为SQL&#x2F;数据库查询语句,并且在DBMS端高效执行.虽然它与规约无关,但如果你想了解有关 AsyncExecuter 的更多信息,请参阅仓储文档.</p>
<p>实际上,没有必要使用 ToExpression() 方法,因为规约会自动转换为表达式.这也会起作用:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> queryable = <span class="keyword">await</span> _customerRepository.GetQueryableAsync();</span><br><span class="line"><span class="keyword">var</span> query = queryable.Where(</span><br><span class="line">    <span class="keyword">new</span> Age18PlusCustomerSpecification()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="编写规约"><a href="#编写规约" class="headerlink" title="编写规约"></a>编写规约</h2><p>规约有一个强大的功能是,它们可以与And、Or、Not以及AndNot扩展方法组合使用.</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PremiumCustomerSpecification</span> : <span class="title">Specification</span>&lt;<span class="title">Customer</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> Expression&lt;Func&lt;Customer, <span class="built_in">bool</span>&gt;&gt; ToExpression()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (customer) =&gt; (customer.Balance &gt;= <span class="number">100000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">你可以将 PremiumCustomerSpecification 和 Age18PlusCustomerSpecification 结合起来,查询优质成人顾客的数量,如下所示:</span><br><span class="line"></span><br><span class="line">~~~C<span class="meta">#</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomerManager</span> : <span class="title">DomainService</span>, <span class="title">ITransientDependency</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IRepository&lt;Customer, Guid&gt; _customerRepository;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomerManager</span>(<span class="params">IRepository&lt;Customer, Guid&gt; customerRepository</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _customerRepository = customerRepository;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">GetAdultPremiumCustomerCountAsync</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> _customerRepository.CountAsync(</span><br><span class="line">                <span class="keyword">new</span> Age18PlusCustomerSpecification()</span><br><span class="line">                .And(<span class="keyword">new</span> PremiumCustomerSpecification()).ToExpression()</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你想让这个组合成为一个可复用的规约,你可以创建这样一个组合的规约类,它派生自AndSpecification:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Volo.Abp.Specifications;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AdultPremiumCustomerSpecification</span> : <span class="title">AndSpecification</span>&lt;<span class="title">Customer</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AdultPremiumCustomerSpecification</span>() </span></span><br><span class="line"><span class="function">            : <span class="title">base</span>(<span class="params"><span class="keyword">new</span> Age18PlusCustomerSpecification(</span>),</span></span><br><span class="line"><span class="function">                   <span class="keyword">new</span> <span class="title">PremiumCustomerSpecification</span>())</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="何时使用规约"><a href="#何时使用规约" class="headerlink" title="何时使用规约"></a>何时使用规约</h2><p>使用规约的一些好处:</p>
<ul>
<li>可复用:假设你在代码库的许多地方都需要用到优质顾客过滤器.如果使用表达式而不创建规约,那么如果以后更改“优质顾客”的定义会发生什么?假设你想将最低余额从100000美元更改为250000美元,并添加另一个条件,成为顾客超过3年.如果使用了规约,只需修改一个类.如果在任何其他地方重复（复制&#x2F;粘贴）相同的表达式,则需要更改所有的表达式.</li>
<li>可组合:可以组合多个规约来创建新规约.这是另一种可复用性.</li>
<li>可命名:PremiumCustomerSpecification 更好地解释了为什么使用规约,而不是复杂的表达式.因此,如果在你的业务中使用了一个有意义的表达式,请考虑使用规约.</li>
<li>可测试:规约是一个单独（且易于）测试的对象.</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2022/12/14/ABP/%E9%A2%86%E5%9F%9F%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/14/ABP/%E9%A2%86%E5%9F%9F%E6%9C%8D%E5%8A%A1/" class="post-title-link" itemprop="url">领域服务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-14 09:33:25" itemprop="dateCreated datePublished" datetime="2022-12-14T09:33:25+08:00">2022-12-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-11 17:56:10" itemprop="dateModified" datetime="2023-03-11T17:56:10+08:00">2023-03-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在<code>领域驱动设计(DDD)</code> 解决方案中,核心业务逻辑通常在聚合 (实体) 和领域服务中实现. 在以下情况下特别需要创建领域服务</p>
<ul>
<li>你实现了依赖于某些服务（如存储库或其他外部服务）的核心域逻辑.</li>
<li>你需要实现的逻辑与多个聚合&#x2F;实体相关,因此它不适合任何聚合.<h2 id="ABP-领域服务基础设施"><a href="#ABP-领域服务基础设施" class="headerlink" title="ABP 领域服务基础设施"></a>ABP 领域服务基础设施</h2>领域服务是简单的无状态类. 虽然你不必从任何服务或接口派生,但 ABP 框架提供了一些有用的基类和约定.</li>
</ul>
<h3 id="DomainService-和-IDomainService"><a href="#DomainService-和-IDomainService" class="headerlink" title="DomainService 和 IDomainService"></a>DomainService 和 IDomainService</h3><p>从 DomainService 基类派生领域服务或直接实现 IDomainService 接口.</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Volo.Abp.Domain.Services;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject.Issues</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IssueManager</span> : <span class="title">DomainService</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你这样做时:</p>
<ul>
<li>ABP 框架自动将类注册为瞬态生命周期到依赖注入系统.</li>
<li>你可以直接使用一些常用服务作为基础属性,而无需手动注入 (例如 ILogger and IGuidGenerator).</li>
</ul>
<p>建议使用 Manager 或 Service 后缀命名领域服务. 我们通常使用如上面示例中的 Manager 后缀. 示例: 实现将问题分配给用户的领域逻辑</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IssueManager</span> : <span class="title">DomainService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IRepository&lt;Issue, Guid&gt; _issueRepository;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IssueManager</span>(<span class="params">IRepository&lt;Issue, Guid&gt; issueRepository</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _issueRepository = issueRepository;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">AssignAsync</span>(<span class="params">Issue issue, AppUser user</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> currentIssueCount = <span class="keyword">await</span> _issueRepository</span><br><span class="line">            .CountAsync(i =&gt; i.AssignedUserId == user.Id);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Implementing a core business validation</span></span><br><span class="line">        <span class="keyword">if</span> (currentIssueCount &gt;= <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IssueAssignmentException(user.UserName);</span><br><span class="line">        &#125;</span><br><span class="line">        issue.AssignedUserId = user.Id;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题是定义如下所示的 聚合根:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Issue</span> : <span class="title">AggregateRoot</span>&lt;<span class="title">Guid</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Guid? AssignedUserId &#123; <span class="keyword">get</span>; <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 internal 的 set 确保外层调用者不能直接在调用 set ,并强制始终使用 IssueManager 为 User 分配 Issue.</p>
<h3 id="应用程序服务与领域服务"><a href="#应用程序服务与领域服务" class="headerlink" title="应用程序服务与领域服务"></a>应用程序服务与领域服务</h3><p>虽然 应用服务 和领域服务都实现了业务规则,但他们存在根本的逻辑和形式差异:</p>
<ul>
<li>应用程序服务实现应用程序的 用例 (典型 Web 应用程序中的用户交互), 而领域服务实现 核心的、用例独立的领域逻辑.</li>
<li>应用程序服务获取&#x2F;返回 数据传输对象（Dto）, 领域服务方法通常获取和返回 领域对象 (实体, 值对象).</li>
<li>领域服务通常由应用程序服务或其他领域服务使用,而应用程序服务由表示层或客户端应用程序使用.</li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>领域服务的生命周期是 瞬态 的,它们会自动注册到依赖注入服务.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>不要在领域层，持久化实体数据到数据库中。应该在应用服务层持久化数据。</li>
<li>将实体对象作为方法参数，而不是其id值。如果接受其id值，则需要从领域服务内的数据库中检索实体。这种方法使应用程序代码在同一请求（用例）的不同位置多次加载同一实体，这是低效的，并导致错误。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2022/12/13/ABP/%E4%BB%93%E5%82%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/13/ABP/%E4%BB%93%E5%82%A8/" class="post-title-link" itemprop="url">仓储</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-13 22:50:27" itemprop="dateCreated datePublished" datetime="2022-12-13T22:50:27+08:00">2022-12-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-11 17:56:10" itemprop="dateModified" datetime="2023-03-11T17:56:10+08:00">2023-03-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="仓储"><a href="#仓储" class="headerlink" title="仓储"></a>仓储</h1><p>在领域层和数据映射层之间进行中介,使用类似集合的接口来操作领域对象。<br>实际上,仓储用于领域对象对数据库的操作, 通常每个 聚合根 或实体会创建各自对应的仓储.</p>
<h2 id="通用仓储"><a href="#通用仓储" class="headerlink" title="通用仓储"></a>通用仓储</h2><p>ABP为每个聚合根和实体提供了默认的仓储。 你可以在服务中注入<code>IRepository&lt;TEntity, TKey&gt;</code>执行标准的<code>CRUD</code>操作。<br>默认通用仓储用法示例:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PersonAppService</span> : <span class="title">ApplicationService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IRepository&lt;Person, Guid&gt; _personRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonAppService</span>(<span class="params">IRepository&lt;Person, Guid&gt; personRepository</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _personRepository = personRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">CreateAsync</span>(<span class="params">CreatePersonDto input</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> person = <span class="keyword">new</span> Person(input.Name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> _personRepository.InsertAsync(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">GetCountAsync</span>(<span class="params"><span class="built_in">string</span> filter</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> _personRepository.CountAsync(p =&gt; p.Name.Contains(filter));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中;</p>
<ul>
<li><code>PersonAppService</code> 在它的构造函数中注入了<code>IRepository&lt;Person, Guid&gt;</code> 。</li>
<li><code>CreateAsync</code> 方法使用了 InsertAsync 创建并保存新的实体。</li>
<li><code>GetCountAsync</code> 方法用来从数据库中获取符合指定条件的的人员的数量。</li>
</ul>
<h3 id="标准仓储方法"><a href="#标准仓储方法" class="headerlink" title="标准仓储方法"></a>标准仓储方法</h3><p>通用仓储提供了一些开箱即用的标准CRUD功能:</p>
<ul>
<li>GetAsync: 根据指定的Id或断言(lambda表达式)返回实体。<ul>
<li>将在指定的实体不存在时，抛出异常 EntityNotFoundException</li>
<li>如果指定的条件存在多个实体时，抛出异常 InvalidOperationException</li>
</ul>
</li>
<li>FindAsync: 根据指定的Id或断言(lambda表达式)返回实体。<ul>
<li>如果指定的实体不存在时，返回 null 。</li>
<li>如果指定的条件存在多个实体时，抛出异常 InvalidOperationException</li>
</ul>
</li>
<li>InsertAsync: 在数据库里插入一个新的实体。</li>
<li>UpdateAsync: 在数据库里更新一个已经存在的实体。</li>
<li>DeleteAsync: 从数据库里删除指定的实体。<ul>
<li>这个方法还有一个重载根据指定的断言(lambda表达式)来删除满足条件的多个实体。</li>
</ul>
</li>
<li>GetListAsync: 返回数据库里的所有实体。</li>
<li>GetPagedListAsync: 返回一个指定长度的实体列表。 他拥有 skipCount, maxResultCount and sorting 参数.</li>
<li>GetCountAsync: 获取数据库里所有实体的数量</li>
</ul>
<p>这些方法还有还一些重载。</p>
<ul>
<li>提供 UpdateAsync 和 DeleteAsync 方法根据实体对象或者id来更新或者删除实体。</li>
<li>提供 DeleteAsync 方法用来删除符合指定条件的多个实体。</li>
</ul>
<h3 id="在存储上使用LINQ"><a href="#在存储上使用LINQ" class="headerlink" title="在存储上使用LINQ"></a>在存储上使用<code>LINQ</code></h3><p>仓储提供了一个<code>GetQueryableAsync</code>方法来获取一个<code>IQueryable&lt;TEntity&gt;</code>对象。你可以通过这个对象来对实体执行<code>LINQ</code>查询以操作数据库。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;List&lt;PersonDto&gt;&gt; GetListAsync(<span class="built_in">string</span> filter)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取 IQueryable&lt;Person&gt;</span></span><br><span class="line">            IQueryable&lt;Person&gt; queryable = <span class="keyword">await</span> _personRepository.GetQueryableAsync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建一个查询</span></span><br><span class="line">            <span class="keyword">var</span> query = <span class="keyword">from</span> person <span class="keyword">in</span> queryable</span><br><span class="line">                <span class="keyword">where</span> person.Name == filter</span><br><span class="line">                <span class="keyword">orderby</span> person.Name</span><br><span class="line">                <span class="keyword">select</span> person;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行查询</span></span><br><span class="line">            <span class="keyword">var</span> people = query.ToList();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 转DTO并返回给客户端</span></span><br><span class="line">            <span class="keyword">return</span> people.Select(p =&gt; <span class="keyword">new</span> PersonDto &#123;Name = p.Name&#125;).ToList();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>你也可以使用LINQ扩展方法:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;List&lt;PersonDto&gt;&gt; GetListAsync(<span class="built_in">string</span> filter)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取 IQueryable&lt;Person&gt;</span></span><br><span class="line">    IQueryable&lt;Person&gt; queryable = <span class="keyword">await</span> _personRepository.GetQueryableAsync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个查询</span></span><br><span class="line">    <span class="keyword">var</span> people = queryable</span><br><span class="line">        .Where(p =&gt; p.Name.Contains(filter))</span><br><span class="line">        .OrderBy(p =&gt; p.Name)</span><br><span class="line">        .ToList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转DTO并返回给客户端</span></span><br><span class="line">    <span class="keyword">return</span> people.Select(p =&gt; <span class="keyword">new</span> PersonDto &#123;Name = p.Name&#125;).ToList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以使用仓储返回的IQueryable 配合标准LINQ方法自由查询。</p>
<h3 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h3><p>下面这些方法可以用来对数据库执行批量操作;</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InsertManyAsync</span><br><span class="line">UpdateManyAsync</span><br><span class="line">DeleteManyAsync</span><br></pre></td></tr></table></figure>
<p>这些方法可以操作多个实体，如果底层数据库提供程序支持，则可以进行批量操作。</p>
<h3 id="软-x2F-硬删除"><a href="#软-x2F-硬删除" class="headerlink" title="软&#x2F;硬删除"></a>软&#x2F;硬删除</h3><p>如果一个实体是软删除实体（即实现了ISoftDelete接口），则仓储的DeleteSync方法不会删除该实体，而是在数据库中标记为“已删除”。数据过滤器系统确保不会从数据库中正常检索软删除的实体。</p>
<p>如果您的实体是软删除实体，如果您需要物理删除这个实体，您可以使用HardDeleteAsync方法强制删除。</p>
<h3 id="确保实体存在"><a href="#确保实体存在" class="headerlink" title="确保实体存在"></a>确保实体存在</h3><p><code>EnsureExistsAsync</code>扩展方法通过实体id或实体查询表达式来确保实体存在，如果其不存在，它将抛出<code>EntityNotFoundException</code>异常。</p>
<h2 id="其他通用仓储类型"><a href="#其他通用仓储类型" class="headerlink" title="其他通用仓储类型"></a>其他通用仓储类型</h2><p><code>IRepository&lt;TEntity, TKey&gt;</code> 接口 导出 了标准 <code>IQueryable&lt;TEntity&gt;</code> 你可以使用标准<code>LINQ</code>方法自由查询。这对于大多数应用程序都很好。但是，某些ORM提供程序或数据库系统可能不支持<code>IQueryable</code>接口。如果您想使用这样的提供者，就不能依赖<code>IQueryable</code>。</p>
<h3 id="基础仓储"><a href="#基础仓储" class="headerlink" title="基础仓储"></a>基础仓储</h3><p>ABP提供了<code>IBasicRepository&lt;TEntity, TPrimaryKey&gt;</code> 和 <code>IBasicRepository&lt;TEntity&gt;</code> 接口来支持这样的场景. 你可以扩展这些接口（并可选择性地从<code>BasicRepositoryBase</code>派生）为你的实体创建自定义存储库.</p>
<p>依赖于 <code>IBasicRepository</code> 而不是依赖 <code>IRepository</code>有一个优点, 即使它们不支持 <code>IQueryable</code> 也可以使用所有的数据源。</p>
<p>但主要的供应商, 像 <code>Entity Framework, NHibernate 或 MongoDb</code> 已经支持了 <code>IQueryable</code>.</p>
<p>因此, 使用 <code>IRepository</code> 是典型应用程序的 建议方法. 但是可重用的模块开发人员可能会考虑使用 <code>IBasicRepository</code> 来支持广泛的数据源.</p>
<h3 id="只读仓储"><a href="#只读仓储" class="headerlink" title="只读仓储"></a>只读仓储</h3><p>对于想要使用只读仓储的开发者,我们提供了<code>IReadOnlyRepository&lt;TEntity, TKey&gt;</code> 与 <code>IReadOnlyBasicRepository&lt;Tentity, TKey&gt;</code>接口。</p>
<h3 id="无主键的通用-泛型-仓储"><a href="#无主键的通用-泛型-仓储" class="headerlink" title="无主键的通用(泛型)仓储"></a>无主键的通用(泛型)仓储</h3><p>如果你的实体没有id主键 (例如, 它可能具有复合主键) 那么你不能使用上面定义的 <code>IRepository&lt;TEntity, TKey&gt;</code>, 在这种情况下你可以仅使用实体(类型)注入 <code>IRepository&lt;TEntity&gt;</code>。</p>
<p><code>IRepository&lt;TEntity&gt;</code> 有一些缺失的方法, 通常与实体的 Id 属性一起使用. 由于实体在这种情况下没有 Id 属性, 因此这些方法不可用. 比如 Get 方法通过id获取具有指定id的实体. 不过, 你仍然可以使用<code>IQueryable&lt;TEntity&gt;</code>的功能通过标准LINQ方法查询实体。</p>
<h3 id="自定义仓储"><a href="#自定义仓储" class="headerlink" title="自定义仓储"></a>自定义仓储</h3><p>ABP不会强制你实现任何接口或从存储库的任何基类继承。它可以只是一个简单的POCO类。 但是建议继承现有的仓储接口和类，获得开箱即用的标准方法使你的工作更轻松。<br>首先在领域层定义一个仓储接口:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPersonRepository</span> : <span class="title">IRepository</span>&lt;<span class="title">Person</span>, <span class="title">Guid</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Task&lt;Person&gt; <span class="title">FindByNameAsync</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此接口扩展了 IRepository&lt;Person, Guid&gt; 以使用已有的通用仓储功能。<br>自定义存储库依赖于你使用的数据访问工具。 在此示例中, 我们将使用Entity Framework Core:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PersonRepository</span> : <span class="title">EfCoreRepository</span>&lt;<span class="title">MyDbContext</span>, <span class="title">Person</span>, <span class="title">Guid</span>&gt;, <span class="title">IPersonRepository</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonRepository</span>(<span class="params">IDbContextProvider&lt;TestAppDbContext&gt; dbContextProvider</span>) </span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">dbContextProvider</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;Person&gt; <span class="title">FindByNameAsync</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> dbContext = <span class="keyword">await</span> GetDbContextAsync();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> dbContext.Set&lt;Person&gt;()</span><br><span class="line">            .Where(p =&gt; p.Name == name)</span><br><span class="line">            .FirstOrDefaultAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IQueryable-amp-异步操作"><a href="#IQueryable-amp-异步操作" class="headerlink" title="IQueryable &amp; 异步操作"></a>IQueryable &amp; 异步操作</h2><p><code>IRepository</code>提供<code>GetQueryableAsync()</code>来获取<code>IQueryable</code>，这意味着您可以直接在其上使用<code>LINQ</code>扩展方法</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> queryable = <span class="keyword">await</span> _personRepository.GetQueryableAsync();</span><br><span class="line"><span class="keyword">var</span> people = queryable</span><br><span class="line">    .Where(p =&gt; p.Name.Contains(nameFilter))</span><br><span class="line">    .ToList();</span><br></pre></td></tr></table></figure>
<p>.ToList, Count()… 是在 System.Linq 命名空间下定义的扩展方法.<br>你通常想要使用 .ToListAsync(), .CountAsync()…. 来编写真正的异步代码.</p>
<p>但在你使用标准的应用程序启动模板时会发现无法在应用层或领域层使用这些异步扩展方法,因为:</p>
<ul>
<li><p>这里异步方法不是标准LINQ方法,它们定义在Microsoft.EntityFrameworkCoreNuget包中.</p>
</li>
<li><p>标准模板应用层与领域层不引用EF Core 包以实现数据库提供程序独立.<br>强烈建议使用异步方法! 在执行数据库查询时不要使用同步LINQ方法,以便能够开发可伸缩的应用程序.</p>
<h3 id="选项-1-引用EF-Core"><a href="#选项-1-引用EF-Core" class="headerlink" title="选项-1: 引用EF Core"></a>选项-1: 引用EF Core</h3><p>最简单的方法是在你想要使用异步方法的项目直接引用EF Core包.<br>添加Volo.Abp.EntityFrameworkCoreNuGet包到你的项目间接引用EF Core包. 这可以确保你的应用程序其余部分兼容正确版本的EF Core.</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> queryable = <span class="keyword">await</span> _personRepository.GetQueryableAsync();</span><br><span class="line"><span class="keyword">var</span> people = queryable</span><br><span class="line">    .Where(p =&gt; p.Name.Contains(nameFilter))</span><br><span class="line">    .ToListAsync();</span><br></pre></td></tr></table></figure>
<p>当以下情况时，这个方法是推荐的：</p>
</li>
<li><p>如果你正在开发一个应用程序并且不打算在将来 更新FE Core，或者如果以后真的需要更改，你也能容忍它。我们认为，如果您正在开发最终应用程序，这是合理的。</p>
<h3 id="选项-2-使用IRepository异步扩展方法"><a href="#选项-2-使用IRepository异步扩展方法" class="headerlink" title="选项-2: 使用IRepository异步扩展方法"></a>选项-2: 使用IRepository异步扩展方法</h3><p>ABP框架为仓储提供异步扩展方法，与异步LINQ扩展方法类似。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> countAll = <span class="keyword">await</span> _personRepository</span><br><span class="line">    .CountAsync();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="keyword">await</span> _personRepository</span><br><span class="line">    .CountAsync(x =&gt; x.Name.StartsWith(<span class="string">&quot;A&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> book1984 = <span class="keyword">await</span> _bookRepository</span><br><span class="line">    .FirstOrDefaultAsync(x =&gt; x.Name == <span class="string">&quot;John&quot;</span>);    </span><br></pre></td></tr></table></figure>
<p>这种方法仍有局限性。您需要直接在存储库对象上调用扩展方法。例如，以下用法不受支持：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> queryable = <span class="keyword">await</span> _bookRepository.GetQueryableAsync();</span><br><span class="line"><span class="keyword">var</span> count = <span class="keyword">await</span> queryable.Where(x =&gt; x.Name.Contains(<span class="string">&quot;A&quot;</span>)).CountAsync();</span><br></pre></td></tr></table></figure>
<p>这是因为本例中的CountAsync()方法是在IQueryable接口上调用的，而不是在存储库对象上调用的。请参见此类情况的其他选项。</p>
<h3 id="选项-3-IAsyncQueryableExecuter"><a href="#选项-3-IAsyncQueryableExecuter" class="headerlink" title="选项-3: IAsyncQueryableExecuter"></a>选项-3: IAsyncQueryableExecuter</h3><p>IAsyncQueryableExecuter 是一个用于异步执行 IQueryable<T> 对象的服务,不依赖于实际的数据库提供程序.</T></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">AbpDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProductAppService</span> : <span class="title">ApplicationService</span>, <span class="title">IProductAppService</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IRepository&lt;Product, Guid&gt; _productRepository;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IAsyncQueryableExecuter _asyncExecuter;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ProductAppService</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">            IRepository&lt;Product, Guid&gt; productRepository,</span></span></span><br><span class="line"><span class="params"><span class="function">            IAsyncQueryableExecuter asyncExecuter</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _productRepository = productRepository;</span><br><span class="line">            _asyncExecuter = asyncExecuter;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ListResultDto&lt;ProductDto&gt;&gt; GetListAsync(<span class="built_in">string</span> name)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Obtain the IQueryable&lt;T&gt;</span></span><br><span class="line">            <span class="keyword">var</span> queryable = <span class="keyword">await</span> _productRepository.GetQueryableAsync();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//Create the query</span></span><br><span class="line">            <span class="keyword">var</span> query = queryable</span><br><span class="line">                .Where(p =&gt; p.Name.Contains(name))</span><br><span class="line">                .OrderBy(p =&gt; p.Name);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Run the query asynchronously</span></span><br><span class="line">            List&lt;Product&gt; products = <span class="keyword">await</span> _asyncExecuter.ToListAsync(query);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ApplicationService 和 DomainService 基类已经预属性注入了 AsyncExecuter 属性,所以你可直接使用.</p>
</li>
</ul>
<p>ABP框架使用实际数据库提供程序的API异步执行查询。虽然这不是执行查询的常见方式，但它是使用异步API而不依赖于数据库提供者的最佳方式。</p>
<p>当以下情况时，这个方法是推荐的：</p>
<ul>
<li>如果您想开发应用程序代码而不依赖数据库提供程序。</li>
<li>如果你正在构建一个没有数据库提供程序集成包的可重用库,但是在某些情况下需要执行 IQueryable<T>对象.<br>例如,ABP框架在 CrudAppService 基类中(参阅应用程序文档)使用 IAsyncQueryableExecuter.</T></li>
</ul>
<h3 id="选项-4-自定义仓储方法"><a href="#选项-4-自定义仓储方法" class="headerlink" title="选项-4: 自定义仓储方法"></a>选项-4: 自定义仓储方法</h3><p>当以下情况时，这个方法是推荐的：</p>
<ul>
<li>如果你想完全隔离你的领域和应用层和数据库提供程序.</li>
<li>如果你开发可重用的应用模块,并且不想强制使用特定的数据库提供程序,这应该作为一种最佳实践.</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2022/12/13/ABP/%E5%AE%9E%E4%BD%93%E4%B8%8E%E8%81%9A%E5%90%88%E6%A0%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/13/ABP/%E5%AE%9E%E4%BD%93%E4%B8%8E%E8%81%9A%E5%90%88%E6%A0%B9/" class="post-title-link" itemprop="url">实体与聚合根</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-13 15:56:39" itemprop="dateCreated datePublished" datetime="2022-12-13T15:56:39+08:00">2022-12-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-11 17:56:10" itemprop="dateModified" datetime="2023-03-11T17:56:10+08:00">2023-03-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h1><p>实体通常映射成关系数据库中的表。</p>
<h2 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h2><p>实体派生于<code>Entity&lt;TKey&gt;</code>类，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Book</span> : <span class="title">Entity</span>&lt;<span class="title">Guid</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你不想从基类<code>Entity&lt;TKey&gt;</code>派生你自己的实体，你也可以直接实现<code>IEntity&lt;TKey&gt;</code>接口。</p>
<p><code>Entity&lt;TKey&gt;</code>类只定义了一个Id属性，用作主键。在上面的例子中是<code>Guid</code>。主键也可以是其他类型，比如<code>string, int, long</code>，或者任何你需要的类型。</p>
<h3 id="Guid主键的实体"><a href="#Guid主键的实体" class="headerlink" title="Guid主键的实体"></a>Guid主键的实体</h3><p>如果你的实体主键是Guid，这里有一些好的实践方法</p>
<ul>
<li>创建一个构造函数，将Id作为参数获取并传递给基类。<ul>
<li>如果你没有设置Guid主键值，ABP框架在保存时设置。但是在将实体保存到数据库之前，最好在实体上有一个有效的Id值。</li>
</ul>
</li>
<li>如果你的实体创建了带有参数的构造函数，也要创建私有或受保护的空构造函数。空构造函数在您的数据库提供者从数据库(反序列化)读取您的实体时使用。</li>
<li>不要使用Guid.NewGuid()来设置Id值!使用IGuidGenerator服务来为实体创建Id值。通过优化IGuidGenerator，他可以生成连续的Guid值，这对于关系数据库中的聚集索引至关重要。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Book</span> : <span class="title">Entity</span>&lt;<span class="title">Guid</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Book</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span>(<span class="params">Guid id</span>)</span></span><br><span class="line"><span class="function">     : <span class="title">base</span>(<span class="params">id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="具有复合键的实体"><a href="#具有复合键的实体" class="headerlink" title="具有复合键的实体"></a>具有复合键的实体</h3><p>有些实体可能需要 复合键 .在这种情况下,可以从非泛型Entity类派生实体.如:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserRole</span> : <span class="title">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Guid UserId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Guid RoleId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> DateTime CreationTime &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserRole</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span>[] <span class="title">GetKeys</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; UserId, RoleId &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中,复合键由UserId和RoleId组成.在关系数据库中,它是相关表的复合主键. 具有复合键的实体应当实现上面代码中所示的GetKeys()方法.</p>
<h2 id="聚合根"><a href="#聚合根" class="headerlink" title="聚合根"></a>聚合根</h2><p>“聚合是域驱动设计中的一种模式.DDD的聚合是一组可以作为一个单元处理的域对象.例如,订单及订单系列的商品,这些是独立的对象,但将订单(连同订单系列的商品)视为一个聚合通常是很有用的”</p>
<p><code>AggregateRoot&lt;TKey&gt;</code>类继承自<code>Entity&lt;TKey&gt;</code>类,所以默认有<code>Id</code>这个属性.</p>
<p><strong>注意ABP框架只为聚合根创建默认的存储，当然也可以手动为所有实体创建存储</strong></p>
<p>ABP不强制你使用聚合根,实际上你可以使用上面定义的Entity类,当然,如果你想实现领域驱动设计并且创建聚合根,这里有一些最佳实践仅供参考:</p>
<ul>
<li>聚合根需要维护自身的完整性,所有的实体也是这样.但是聚合根也要维护子实体的完整性.所以,聚合根必须一直有效。</li>
<li>使用Id引用聚合根,而不使用导航属性</li>
<li>聚合根被视为一个单元.它是作为一个单元检索和更新的.它通常被认为是一个交易边界.</li>
<li>不单独修改聚合根中的子实体<h3 id="聚合根例子"><a href="#聚合根例子" class="headerlink" title="聚合根例子"></a>聚合根例子</h3>这是一个具有子实体集合的聚合根例子:<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Order</span> : <span class="title">AggregateRoot</span>&lt;<span class="title">Guid</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> ReferenceNo &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">int</span> TotalItemCount &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> DateTime CreationTime &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> List&lt;OrderLine&gt; OrderLines &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Order</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span>(<span class="params">Guid id, <span class="built_in">string</span> referenceNo</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Check.NotNull(referenceNo, <span class="keyword">nameof</span>(referenceNo));</span><br><span class="line">        </span><br><span class="line">        Id = id;</span><br><span class="line">        ReferenceNo = referenceNo;</span><br><span class="line">        </span><br><span class="line">        OrderLines = <span class="keyword">new</span> List&lt;OrderLine&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddProduct</span>(<span class="params">Guid productId, <span class="built_in">int</span> count</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(</span><br><span class="line">                <span class="string">&quot;You can not add zero or negative count of products!&quot;</span>,</span><br><span class="line">                <span class="keyword">nameof</span>(count)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> existingLine = OrderLines.FirstOrDefault(ol =&gt; ol.ProductId == productId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (existingLine == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            OrderLines.Add(<span class="keyword">new</span> OrderLine(<span class="keyword">this</span>.Id, productId, count));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            existingLine.ChangeCount(existingLine.Count + count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TotalItemCount += count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderLine</span> : <span class="title">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> Guid OrderId &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> Guid ProductId &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">int</span> Count &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">OrderLine</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="title">OrderLine</span>(<span class="params">Guid orderId, Guid productId, <span class="built_in">int</span> count</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        OrderId = orderId;</span><br><span class="line">        ProductId = productId;</span><br><span class="line">        Count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">ChangeCount</span>(<span class="params"><span class="built_in">int</span> newCount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Count = newCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span>[] <span class="title">GetKeys</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Object[] &#123;OrderId, ProductId&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果你不想你的聚合根继承AggregateRoot<TKey>类,你可以直接实现IAggregateRoot<TKey>接口</TKey></TKey></li>
</ul>
<p>Order是一个具有Guid类型Id属性的 聚合根.它有一个OrderLine实体集合.OrderLine是一个具有组合键(OrderId和 ProductId)的实体.</p>
<p>虽然这个示例可能无法实现聚合根的所有最佳实践,但它仍然遵循良好的实践:</p>
<ul>
<li>Order有一个公共的构造函数,它需要 minimal requirements 来构造一个”订单”实例.因此,在没有Id和referenceNo的时候是无法创建订单的.protected&#x2F;private的构造函数只有从数据库读取对象时 反序列化 才需要.</li>
<li>OrderLine的构造函数是internal的,所以它只能由领域层来创建.在Order.AddProduct这个方法的内部被使用.</li>
<li>Order.AddProduct实现了业务规则将商品添加到订单中</li>
<li>所有属性都有protected的set.这是为了防止实体在实体外部任意改变.因此,在没有向订单中添加新产品的情况下设置 TotalItemCount将是危险的.它的值由AddProduct方法维护.</li>
</ul>
<h3 id="带有组合键的聚合根"><a href="#带有组合键的聚合根" class="headerlink" title="带有组合键的聚合根"></a>带有组合键的聚合根</h3><p>虽然这种聚合根并不常见(也不建议使用),但实际上可以按照与上面提到的跟实体相同的方式定义复合键.在这种情况下,要使用非泛型的AggregateRoot基类.</p>
<h3 id="BasicAggregateRoot类"><a href="#BasicAggregateRoot类" class="headerlink" title="BasicAggregateRoot类"></a>BasicAggregateRoot类</h3><p>AggregateRoot 类实现了 IHasExtraProperties 和 IHasConcurrencyStamp 接口,这为派生类带来了两个属性. IHasExtraProperties 使实体可扩展(请参见下面的 额外的属性部分) 和 IHasConcurrencyStamp 添加了由ABP框架管理的 ConcurrencyStamp 属性实现乐观并发. 在大多数情况下,这些是聚合根需要的功能.</p>
<p>但是,如果你不需要这些功能,你的聚合根可以继承 BasicAggregateRoot<TKey>(或BasicAggregateRoot).</TKey></p>
<h2 id="额外的属性"><a href="#额外的属性" class="headerlink" title="额外的属性"></a>额外的属性</h2><p>ABP定义了 IHasExtraProperties 接口,可以由实体实现,以便能够动态地设置和获取的实体属性. AggregateRoot 基类已经实现了 IHasExtraProperties 接口. 如果你从这个类(或者上面定义的一个相关审计类)派生,那么你可以直接使用API​.</p>
<h3 id="GetProperty-和-SetProperty-扩展方法"><a href="#GetProperty-和-SetProperty-扩展方法" class="headerlink" title="GetProperty 和 SetProperty 扩展方法"></a>GetProperty 和 SetProperty 扩展方法</h3><p>这些扩展方法是获取和设置实体数据的推荐方法. 例:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExtraPropertiesDemoService</span> : <span class="title">ITransientDependency</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IIdentityUserRepository _identityUserRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExtraPropertiesDemoService</span>(<span class="params">IIdentityUserRepository identityUserRepository</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _identityUserRepository = identityUserRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">SetTitle</span>(<span class="params">Guid userId, <span class="built_in">string</span> title</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> user = <span class="keyword">await</span> _identityUserRepository.GetAsync(userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//SET A PROPERTY</span></span><br><span class="line">        user.SetProperty(<span class="string">&quot;Title&quot;</span>, title);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> _identityUserRepository.UpdateAsync(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">GetTitle</span>(<span class="params">Guid userId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> user = <span class="keyword">await</span> _identityUserRepository.GetAsync(userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//GET A PROPERTY</span></span><br><span class="line">        <span class="keyword">return</span> user.GetProperty&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Title&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="值对象"><a href="#值对象" class="headerlink" title="值对象"></a>值对象</h1><p>一个对象,表示领域的描述方面,没有概念上的身份被称为 值对象.</p>
<p>两个具有相同属性但id不同的实体被认为是不同的实体。但是，值对象没有id，如果它们具有相同的属性值，则它们被视为相等的。</p>
<h2 id="值对象的类"><a href="#值对象的类" class="headerlink" title="值对象的类"></a>值对象的类</h2><p>值对象是一个抽象类,可以继承它来创建值对象类</p>
<p>示例: An Address class</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Address</span> : <span class="title">ValueObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Guid CityId &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Street &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Number &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Address</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Address</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        Guid cityId,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> street,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">int</span> number</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        CityId = cityId;</span><br><span class="line">        Street = street;</span><br><span class="line">        Number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> IEnumerable&lt;<span class="built_in">object</span>&gt; <span class="title">GetAtomicValues</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> Street;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> CityId;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> Number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>值对象类必须实现 GetAtomicValues()方法来返回原始值</li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul>
<li>如果没有充分的理由将值对象设计为可变的,则将其设计为不可变（如上面的地址）.</li>
<li>构成一个值对象的属性应该形成一个概念整体.例如：CityId,Street和Number不应是个人实体的单独属性.这也使Person实体更简</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>当实体属性，没有业务规则或其他限制条件时，属性应该设置为 public；</li>
<li>当实体属性，只有简单的限制条件时(不需要根据数据库或其他实体判断)，属性应该设置为 private；在实体上创建修改方法，不要在领域层中创建；</li>
<li>当实体属性，有复杂业务规则限制时，属性应该设置为 interal；在领域层，创建修改方法；</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2022/12/12/ABP/%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E7%AB%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/12/ABP/%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E7%AB%AF/" class="post-title-link" itemprop="url">创建服务端</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-12 16:00:09" itemprop="dateCreated datePublished" datetime="2022-12-12T16:00:09+08:00">2022-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-11 17:56:10" itemprop="dateModified" datetime="2023-03-11T17:56:10+08:00">2023-03-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="创建服务端"><a href="#创建服务端" class="headerlink" title="创建服务端"></a>创建服务端</h1><h2 id="创建领域层"><a href="#创建领域层" class="headerlink" title="创建领域层"></a>创建领域层</h2><p>启动模板中的领域层分为两个项目:</p>
<ul>
<li><code>XXX.Domain</code>包含你的实体, 领域服务和其他核心域对象.</li>
<li><code>XXX.Domain.Shared</code>包含可与客户共享的常量,枚举或其他域相关对象.</li>
</ul>
<p>在解决方案的<code>领域层</code>(<code>XXX.Domain</code>项目)中定义你的实体.</p>
<p>该应用程序的主要实体是<code>Book</code>. 在<code>XXX.Domain</code>项目中创建一个<code>Books</code>文件夹(命名空间),并在其中添加名为<code>Book</code>的类,如下所示:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Volo.Abp.Domain.Entities.Auditing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Acme.BookStore.Books</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Book</span> : <span class="title">AuditedAggregateRoot</span>&lt;<span class="title">Guid</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> BookType Type &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> DateTime PublishDate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">float</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ABP</code>为实体提供了两个基本的基类:<code>AggregateRoot</code>和<code>Entity</code>.<code>Aggregate Root</code>是领域驱动设计概念之一. 可以视为直接查询和处理的根实体(请参阅实体文档).</li>
<li><code>Book</code>实体继承了<code>AuditedAggregateRoot</code>,<code>AuditedAggregateRoot</code>类在<code>AggregateRoot</code>类的基础上添加了一些基础审计属性(例如<code>CreationTime, CreatorId, LastModificationTime</code>等).<code>ABP</code>框架自动为你管理这些属性.</li>
<li><code>Guid</code>是<code>Book</code>实体的主键类型.</li>
</ul>
<h3 id="BookType枚举"><a href="#BookType枚举" class="headerlink" title="BookType枚举"></a>BookType枚举</h3><p><code>Book</code>实体使用了<code>BookType</code>枚举. 在<code>XXX.Domain.Shared</code>项目中创建<code>Books</code>文件夹(命名空间),并在其中添加<code>BookType</code>:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Acme.BookStore.Books</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">enum</span> BookType</span><br><span class="line">    &#123;</span><br><span class="line">        Undefined,</span><br><span class="line">        Adventure,</span><br><span class="line">        Biography,</span><br><span class="line">        Dystopia,</span><br><span class="line">        Fantastic,</span><br><span class="line">        Horror,</span><br><span class="line">        Science,</span><br><span class="line">        ScienceFiction,</span><br><span class="line">        Poetry</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="将Book实体添加到DbContext中"><a href="#将Book实体添加到DbContext中" class="headerlink" title="将Book实体添加到DbContext中"></a>将Book实体添加到DbContext中</h3><p><code>EF Core</code>需要你将实体和<code>DbContext</code>建立关联.最简单的做法是在<code>XXX.EntityFrameworkCore</code>项目的<code>BookStoreDbContext</code>类中添加<code>DbSet</code>属性.如下所示:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BookStoreDbContext</span> : <span class="title">AbpDbContext</span>&lt;<span class="title">BookStoreDbContext</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Book&gt; Books &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建应用程序"><a href="#创建应用程序" class="headerlink" title="创建应用程序"></a>创建应用程序</h2><p>应用程序层由两个分离的项目组成:<br><code>XXX.Application.Contracts</code>包含你的<code>DTO</code>和应用服务接口.<br><code>XXX.Application</code>包含你的应用服务实现.<br>在本部分中,你将创建一个应用程序服务,使用<code>ABP Framework</code>的<code>CrudAppService</code>基类来获取,创建,更新和删除书籍.</p>
<h3 id="BookDto"><a href="#BookDto" class="headerlink" title="BookDto"></a>BookDto</h3><p><code>CrudAppService</code> 基类需要定义实体的基本<code>DTO</code>. 在 <code>XXX.Application.Contracts</code>项目中创建<code>Books</code>文件夹(命名空间), 并在其中添加名为<code>BookDto</code>的DTO类:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Volo.Abp.Application.Dtos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Acme.BookStore.Books</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BookDto</span> : <span class="title">AuditedEntityDto</span>&lt;<span class="title">Guid</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> BookType Type &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> DateTime PublishDate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">float</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>DTO</code>类被用来在<code>表示层</code>和<code>应用层</code>传递数据.参阅DTO文档.</li>
<li>为了在用户界面上展示书籍信息,<code>BookDto</code>被用来将书籍数据传递到表示层.</li>
<li><code>BookDto</code>继承自<code>AuditedEntityDto&lt;Guid&gt;</code>.与上面定义的<code>Book</code>实体一样具有一些审计属性.</li>
</ul>
<h3 id="IBookAppService"><a href="#IBookAppService" class="headerlink" title="IBookAppService"></a>IBookAppService</h3><p>下一步是为应用程序定义接口,在<code>XXX.Application.Contracts</code>项目创建<code>Books</code>文件夹(命名空间),并在其中添加名为<code>IBookAppService</code>的接口:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Acme.BookStore.Books</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IBookAppService</span> :</span><br><span class="line">        <span class="title">ICrudAppService</span>&lt; //<span class="title">Defines</span> <span class="title">CRUD</span> <span class="title">methods</span></span><br><span class="line">            <span class="title">BookDto</span>, //<span class="title">Used</span> <span class="title">to</span> <span class="title">show</span> <span class="title">books</span></span><br><span class="line">            <span class="title">Guid</span>, //<span class="title">Primary</span> <span class="title">key</span> <span class="title">of</span> <span class="title">the</span> <span class="title">book</span> <span class="title">entity</span></span><br><span class="line">            <span class="title">PagedAndSortedResultRequestDto</span>, //<span class="title">Used</span> <span class="title">for</span> <span class="title">paging</span>/<span class="title">sorting</span></span><br><span class="line">            <span class="title">CreateUpdateBookDto</span>&gt; <span class="comment">//Used to create/update a book</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>框架定义应用程序服务的接口不是必需的. 但是,它被建议作为最佳实践.</li>
<li><code>ICrudAppService</code>定义了常见的<code>CRUD</code>方法:<code>GetAsync,GetListAsync,CreateAsync,UpdateAsync和DeleteAsync</code>. 从这个接口扩展不是必需的,你可以从空的<code>IApplicationService</code>接口继承并手动定义自己的方法(将在下一部分中完成).</li>
<li><code>ICrudAppService</code>有一些变体, 你可以在每个方法中使用单独的<code>DTO</code>(例如使用不同的<code>DTO</code>进行创建和更新).</li>
</ul>
<h3 id="BookAppService"><a href="#BookAppService" class="headerlink" title="BookAppService"></a>BookAppService</h3><p>是时候实现<code>IBookAppService</code>接口了在<code>XXX.Application</code>项目中创建<code>Books</code>文件夹(命名空间),并在其中添加名为 <code>BookAppService</code>的类:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BookAppService</span> :</span><br><span class="line">        <span class="title">CrudAppService</span>&lt;</span><br><span class="line">            <span class="title">Book</span>, //<span class="title">The</span> <span class="title">Book</span> <span class="title">entity</span></span><br><span class="line">            <span class="title">BookDto</span>, //<span class="title">Used</span> <span class="title">to</span> <span class="title">show</span> <span class="title">books</span></span><br><span class="line">            <span class="title">Guid</span>, //<span class="title">Primary</span> <span class="title">key</span> <span class="title">of</span> <span class="title">the</span> <span class="title">book</span> <span class="title">entity</span></span><br><span class="line">            <span class="title">PagedAndSortedResultRequestDto</span>, //<span class="title">Used</span> <span class="title">for</span> <span class="title">paging</span>/<span class="title">sorting</span></span><br><span class="line">            <span class="title">CreateUpdateBookDto</span>&gt;, <span class="comment">//Used to create/update a book</span></span><br><span class="line">        <span class="title">IBookAppService</span> <span class="comment">//implement the IBookAppService</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BookAppService</span>(<span class="params">IRepository&lt;Book, Guid&gt; repository</span>)</span></span><br><span class="line"><span class="function">            : <span class="title">base</span>(<span class="params">repository</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>BookAppService</code>继承了<code>CrudAppService&lt;...&gt;</code>.它实现了<code>ICrudAppService</code>定义的<code>CRUD</code>方法.</li>
<li><code>BookAppService</code>注入<code>IRepository &lt;Book,Guid&gt;</code>,这是<code>Book</code>实体的默认仓储.<code>ABP</code>自动为每个聚合根(或实体)创建默认仓储. 请参阅仓储文档</li>
<li><code>BookAppService</code>使用<code>IObjectMapper</code>将<code>Book</code>对象转换为<code>BookDto</code>对象, 将<code>CreateUpdateBookDto</code>对象转换为<code>Book</code>对象. 启动模板使用<code>AutoMapper</code>库作为对象映射提供程序. 我们之前定义了映射, 因此它将按预期工作.</li>
</ul>
<h3 id="自动生成API-Controllers"><a href="#自动生成API-Controllers" class="headerlink" title="自动生成API Controllers"></a>自动生成API Controllers</h3><p>在典型的<code>ASP.NET Core</code>应用程序中,你创建<code>API Controller</code>以将应用程序服务公开为<code>HTTP API</code>端点. 这将允许浏览器或第三方客户端通过<code>HTTP</code>调用它们.</p>
<p><code>ABP</code>可以自动按照约定将你的应用程序服务配置为<code>MVC API</code>控制器.</p>
<h1 id="图书列表页面"><a href="#图书列表页面" class="headerlink" title="图书列表页面"></a>图书列表页面</h1><h2 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h2><p>本地化文本位于<code>XXX.Domain.Shared</code>项目的<code>Localization/BookStore</code>文件夹下:</p>
<p><strong>简体中文翻译请打开zh-Hans.json文件 ,并将”Texts”对象中对应的值替换为中文.</strong></p>
<ul>
<li>本地化关键字名称是任意的. 你可以设置任何名称. 对于特定的文本类型,我们更喜欢遵循一些约定:</li>
<li>为按钮项添加 Menu: 前缀.</li>
<li>使用 Enum:<enum-type>:<enum-name> 或 <enum-type>.<enum-name> 或 <enum-name> 命名约定来本地化枚举成员. 当您这样做时ABP可以在某些适当的情况下自动将枚举本地化.</enum-name></enum-name></enum-type></enum-name></enum-type></li>
<li>如果未在本地化文件中定义文本,则文本将回退到本地化键(ASP.NET Core的标准行为).</li>
</ul>
<h2 id="生成服务代理"><a href="#生成服务代理" class="headerlink" title="生成服务代理"></a>生成服务代理</h2><p><code>ABP CLI</code> 提供 <code>generate-proxy</code> 命令为<code>HTTP APIs</code>生成客户端代理.有了这些代理,在客户端使用<code>HTTP APIs</code>变得更加方便. 运行<code>generate-proxy</code>命令前, 你的<code>host</code>必须正在运行.<br>启动host应用程序后,在 angular 文件夹下运行以下命令:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abp generate-proxy -t ng</span><br></pre></td></tr></table></figure>

<h2 id="创建新书籍"><a href="#创建新书籍" class="headerlink" title="创建新书籍"></a>创建新书籍</h2><h1 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h1><h1 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2022/11/19/EFCore/%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9E%8B(%E4%BA%8C)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/19/EFCore/%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9E%8B(%E4%BA%8C)/" class="post-title-link" itemprop="url">创建模型(二)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-11-19 17:19:56" itemprop="dateCreated datePublished" datetime="2022-11-19T17:19:56+08:00">2022-11-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-20 12:16:29" itemprop="dateModified" datetime="2023-03-20T12:16:29+08:00">2023-03-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="值转换"><a href="#值转换" class="headerlink" title="值转换"></a>值转换</h1><p>值转换器可在从数据库读取或向其中写入属性值时转换属性值。 此转换可以是从同一类型的一个值转换为另一个值（例如加密字符串），也可以是从一种类型的值转换为另一种类型的值（例如数据库中枚举值和字符串的相互转换）。</p>
<p>值转换器的指定涉及 ModelClrType 和 ProviderClrType。 ModelClrType是实体类型中的属性的 .NET 类型。 ProviderClrType是数据库提供程序理解的 .NET 类型。 例如，若要在数据库中将枚举保存为字符串，模型类型(ModelClrType)是枚举的类型，而提供程序类型(ProviderClrType)是 String。 </p>
<p>使用两个 Func 表达式树定义转换：一个从 ModelClrType 转换为 ProviderClrType，另一个从 ProviderClrType 转换为 ModelClrType。 使用表达式树的目的是使它们可被编译到数据库访问委托中，以便进行高效转换。 表达式树可能包含对复杂转换的转换方法的简单调用。</p>
<h2 id="配置值转换器"><a href="#配置值转换器" class="headerlink" title="配置值转换器"></a>配置值转换器</h2><p>值转换在 中 DbContext.OnModelCreating配置。 例如，假设将一个枚举和实体类型定义为：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Rider</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> EquineBeast Mount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> EquineBeast</span><br><span class="line">&#123;</span><br><span class="line">    Donkey,</span><br><span class="line">    Mule,</span><br><span class="line">    Horse,</span><br><span class="line">    Unicorn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在 中 OnModelCreating 配置转换，以将枚举值作为字符串（如“Donkey”、“Mule”等）存储在数据库中;只需提供一个从 ModelClrType 转换为 ProviderClrType的函数，为相反的转换提供另一个函数：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder</span><br><span class="line">        .Entity&lt;Rider&gt;()</span><br><span class="line">        .Property(e =&gt; e.Mount)</span><br><span class="line">        .HasConversion(</span><br><span class="line">            v =&gt; v.ToString(),</span><br><span class="line">            v =&gt; (EquineBeast)Enum.Parse(<span class="keyword">typeof</span>(EquineBeast), v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="批量配置值转换器"><a href="#批量配置值转换器" class="headerlink" title="批量配置值转换器"></a>批量配置值转换器</h2><p>为使用相关 CLR 类型的每个属性配置相同的值转换器很常见。 可以使用 预约定模型配置 为整个模型执行此操作一次，而不是为每个属性手动执行此操作。 因为它在允许运行模型生成约定之前配置模型的各个方面。 通过重写 ConfigureConventions 派生自 DbContext的类型来应用此类配置。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CurrencyConverter</span> : <span class="title">ValueConverter</span>&lt;<span class="title">Currency</span>, <span class="title">decimal</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CurrencyConverter</span>()</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">            v =&gt; v.Amount,</span></span></span><br><span class="line"><span class="params"><span class="function">            v =&gt; <span class="keyword">new</span> Currency(v</span>))</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在上下文类型中重写 ConfigureConventions 并配置转换器，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">ConfigureConventions</span>(<span class="params">ModelConfigurationBuilder configurationBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    configurationBuilder</span><br><span class="line">        .Properties&lt;Currency&gt;()</span><br><span class="line">        .HaveConversion&lt;CurrencyConverter&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此示例演示如何在 类型 string的所有属性上配置一些方面：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">configurationBuilder</span><br><span class="line">    .Properties&lt;<span class="built_in">string</span>&gt;()</span><br><span class="line">    .AreUnicode(<span class="literal">false</span>)</span><br><span class="line">    .HaveMaxLength(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>

<h2 id="预定义的转换"><a href="#预定义的转换" class="headerlink" title="预定义的转换"></a>预定义的转换</h2><p>EF Core 含有许多预定义转换，不需要手动编写转换函数。 而是根据模型中的属性类型和请求的数据库提供程序类型选取要使用的转换。</p>
<p>例如，枚举到字符串的转换用作上面的示例，但当提供程序类型配置为 string 使用 的泛型类型 HasConversion时，EF Core 实际上会自动执行此操作：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder</span><br><span class="line">        .Entity&lt;Rider&gt;()</span><br><span class="line">        .Property(e =&gt; e.Mount)</span><br><span class="line">        .HasConversion&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可通过显式地指定数据库列类型实现相同的操作。 例如，如果实体类型的定义如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Rider2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Column(TypeName = <span class="string">&quot;nvarchar(24)&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> EquineBeast Mount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后枚举值将保存为数据库中的字符串，而无需在 中 OnModelCreating进行任何进一步配置。</p>
<h2 id="ValueConverter-类"><a href="#ValueConverter-类" class="headerlink" title="ValueConverter 类"></a>ValueConverter 类</h2><p>如上所示调用 HasConversion 将创建一个 ValueConverter&lt;TModel,TProvider&gt; 实例并在 属性上设置它。 可改为显式地创建 ValueConverter。 例如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> converter = <span class="keyword">new</span> ValueConverter&lt;EquineBeast, <span class="built_in">string</span>&gt;(</span><br><span class="line">        v =&gt; v.ToString(),</span><br><span class="line">        v =&gt; (EquineBeast)Enum.Parse(<span class="keyword">typeof</span>(EquineBeast), v));</span><br><span class="line"></span><br><span class="line">    modelBuilder</span><br><span class="line">        .Entity&lt;Rider&gt;()</span><br><span class="line">        .Property(e =&gt; e.Mount)</span><br><span class="line">        .HasConversion(converter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个属性使用同一个转换时，这非常有用。</p>
<h2 id="内置转换器"><a href="#内置转换器" class="headerlink" title="内置转换器"></a>内置转换器</h2><p>如上所述，EF Core 附带了一组预定义 ValueConverter&lt;TModel,TProvider&gt; 的类，这些类位于 命名空间中 Microsoft.EntityFrameworkCore.Storage.ValueConversion 。 在许多情况下，EF 将根据模型中属性的类型和在数据库中请求的类型，选择适当的内置转换器，正如上面的枚举转换示例所示。 例如，对 bool 属性使用 .HasConversion<int>() 会使 EF Core 将布尔值转换为数值零和一：</int></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder</span><br><span class="line">        .Entity&lt;User&gt;()</span><br><span class="line">        .Property(e =&gt; e.IsActive)</span><br><span class="line">        .HasConversion&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这在功能上与创建内置 BoolToZeroOneConverter<TProvider> 实例并显式设置它相同：</TProvider></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> converter = <span class="keyword">new</span> BoolToZeroOneConverter&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    modelBuilder</span><br><span class="line">        .Entity&lt;User&gt;()</span><br><span class="line">        .Property(e =&gt; e.IsActive)</span><br><span class="line">        .HasConversion(converter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果默认情况下所有 EquineBeast 列都应为 varchar(20)，则可以将此信息作为 提供给值转换器 ConverterMappingHints。 例如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> converter = <span class="keyword">new</span> ValueConverter&lt;EquineBeast, <span class="built_in">string</span>&gt;(</span><br><span class="line">        v =&gt; v.ToString(),</span><br><span class="line">        v =&gt; (EquineBeast)Enum.Parse(<span class="keyword">typeof</span>(EquineBeast), v),</span><br><span class="line">        <span class="keyword">new</span> ConverterMappingHints(size: <span class="number">20</span>, unicode: <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    modelBuilder</span><br><span class="line">        .Entity&lt;Rider&gt;()</span><br><span class="line">        .Property(e =&gt; e.Mount)</span><br><span class="line">        .HasConversion(converter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在只要使用此转换器，数据库列就不能采用 unicode，且最长为 20 个字符。 但是，这些只是提示，因为它们被映射属性上显式设置的任何方面覆盖。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="简单值对象"><a href="#简单值对象" class="headerlink" title="简单值对象"></a>简单值对象</h3><p>此示例使用简单类型来包装基元类型。 希望模型中的类型比基元类型更具体（因而更具类型安全性）时，这很有用。 在此示例中，该类型为 Dollars，它包装小数基元：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">struct</span> Dollars</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dollars</span>(<span class="params"><span class="built_in">decimal</span> amount</span>)</span> </span><br><span class="line">        =&gt; Amount = amount;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Amount &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span> </span><br><span class="line">        =&gt; <span class="string">$&quot;$<span class="subst">&#123;Amount&#125;</span>&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这可用于实体类型中：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Order</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Dollars Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可在存储到数据库中时被转换为基本 decimal：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Order&gt;()</span><br><span class="line">    .Property(e =&gt; e.Price)</span><br><span class="line">    .HasConversion(</span><br><span class="line">        v =&gt; v.Amount,</span><br><span class="line">        v =&gt; <span class="keyword">new</span> Dollars(v));</span><br></pre></td></tr></table></figure>

<h3 id="值对象的集合"><a href="#值对象的集合" class="headerlink" title="值对象的集合"></a>值对象的集合</h3><p>我们可以创建一个值对象集合。 例如，假设有一个 AnnualFinance 类型，它为博客一年的财务状况建模：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">struct</span> AnnualFinance</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">JsonConstructor</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnnualFinance</span>(<span class="params"><span class="built_in">int</span> year, Money income, Money expenses</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Year = year;</span><br><span class="line">        Income = income;</span><br><span class="line">        Expenses = expenses;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Year &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Money Income &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Money Expenses &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Money Revenue =&gt; <span class="keyword">new</span> Money(Income.Amount - Expenses.Amount, Income.Currency);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此类型构成几个我们先前创建的 Money 类型：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">struct</span> Money</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">JsonConstructor</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Money</span>(<span class="params"><span class="built_in">decimal</span> amount, Currency currency</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Amount = amount;</span><br><span class="line">        Currency = currency;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">        =&gt; (Currency == Currency.UsDollars ? <span class="string">&quot;$&quot;</span> : <span class="string">&quot;£&quot;</span>) + Amount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Amount &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Currency Currency &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Currency</span><br><span class="line">&#123;</span><br><span class="line">    UsDollars,</span><br><span class="line">    PoundsSterling</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们可以向实体类型添加一个 AnnualFinance 集合：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IList&lt;AnnualFinance&gt; Finances &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来再次使用序列化来进行存储：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">    .Property(e =&gt; e.Finances)</span><br><span class="line">    .HasConversion(</span><br><span class="line">        v =&gt; JsonSerializer.Serialize(v, (JsonSerializerOptions)<span class="literal">null</span>),</span><br><span class="line">        v =&gt; JsonSerializer.Deserialize&lt;List&lt;AnnualFinance&gt;&gt;(v, (JsonSerializerOptions)<span class="literal">null</span>),</span><br><span class="line">        <span class="keyword">new</span> ValueComparer&lt;IList&lt;AnnualFinance&gt;&gt;(</span><br><span class="line">            (c1, c2) =&gt; c1.SequenceEqual(c2),</span><br><span class="line">            c =&gt; c.Aggregate(<span class="number">0</span>, (a, v) =&gt; HashCode.Combine(a, v.GetHashCode())),</span><br><span class="line">            c =&gt; (IList&lt;AnnualFinance&gt;)c.ToList()));</span><br></pre></td></tr></table></figure>
<h3 id="使用不区分大小写的字符串键"><a href="#使用不区分大小写的字符串键" class="headerlink" title="使用不区分大小写的字符串键"></a>使用不区分大小写的字符串键</h3><p>一些数据库（包括 SQL Server）默认执行不区分大小写的字符串比较。 另一方面，.NET 默认执行区分大小写的字符串比较。 这意味着，“DotNet”之类的外键值将与 SQL Server 上的主键值“dotnet”匹配，但与 EF Core 中的该值不匹配。 键的值比较器可用于强制 EF Core 执行不区分大小写的字符串比较，就像在数据库中那样。 例如，请考虑使用拥有字符串键的博客&#x2F;文章模型：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ICollection&lt;Post&gt; Posts &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Blog Blog &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果某些 Post.BlogId 值具有不同的大小写，此模型不会按预期工作。 此问题造成的错误取决于应用程序正在执行的操作，通常都涉及未正确修复的对象图和&#x2F;或由于 FK 值错误而失败的更新。 值比较器可用于更正这种情况：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> comparer = <span class="keyword">new</span> ValueComparer&lt;<span class="built_in">string</span>&gt;(</span><br><span class="line">        (l, r) =&gt; <span class="built_in">string</span>.Equals(l, r, StringComparison.OrdinalIgnoreCase),</span><br><span class="line">        v =&gt; v.ToUpper().GetHashCode(),</span><br><span class="line">        v =&gt; v);</span><br><span class="line"></span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(e =&gt; e.Id)</span><br><span class="line">        .Metadata.SetValueComparer(comparer);</span><br><span class="line"></span><br><span class="line">    modelBuilder.Entity&lt;Post&gt;(</span><br><span class="line">        b =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            b.Property(e =&gt; e.Id).Metadata.SetValueComparer(comparer);</span><br><span class="line">            b.Property(e =&gt; e.BlogId).Metadata.SetValueComparer(comparer);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>.NET 字符串比较和数据库字符串比较的区别不仅限于大小写敏感性。 此模式适用于简单的 ASCII 键，但对于具有任意一种区域性特定字符的键，可能会失败。</p>
</blockquote>
<h3 id="处理定长的数据库字符串"><a href="#处理定长的数据库字符串" class="headerlink" title="处理定长的数据库字符串"></a>处理定长的数据库字符串</h3><p>前一个示例不需要值转换器。 但是，对于定长数据库字符串类型（如 char(20) 或 nchar(20)），转换器很有用。 每当向数据库插入值时，都会将定长字符串填充到完整长度。 这意味着键值“dotnet”在从数据库中读回时将为“dotnet…………..”，其中 . 表示空格字符。 这样将不能与未填充的键值正确地进行比较。</p>
<p>值转换器可用于在读取键值时剪裁填充。 可将此与上一个示例中的值比较器结合，以正确比较定长的不区分大小写的 ASCII 键。 例如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> converter = <span class="keyword">new</span> ValueConverter&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;(</span><br><span class="line">        v =&gt; v,</span><br><span class="line">        v =&gt; v.Trim());</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">var</span> comparer = <span class="keyword">new</span> ValueComparer&lt;<span class="built_in">string</span>&gt;(</span><br><span class="line">        (l, r) =&gt; <span class="built_in">string</span>.Equals(l, r, StringComparison.OrdinalIgnoreCase),</span><br><span class="line">        v =&gt; v.ToUpper().GetHashCode(),</span><br><span class="line">        v =&gt; v);</span><br><span class="line"></span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(e =&gt; e.Id)</span><br><span class="line">        .HasColumnType(<span class="string">&quot;char(20)&quot;</span>)</span><br><span class="line">        .HasConversion(converter, comparer);</span><br><span class="line"></span><br><span class="line">    modelBuilder.Entity&lt;Post&gt;(</span><br><span class="line">        b =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            b.Property(e =&gt; e.Id).HasColumnType(<span class="string">&quot;char(20)&quot;</span>).HasConversion(converter, comparer);</span><br><span class="line">            b.Property(e =&gt; e.BlogId).HasColumnType(<span class="string">&quot;char(20)&quot;</span>).HasConversion(converter, comparer);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加密属性值"><a href="#加密属性值" class="headerlink" title="加密属性值"></a>加密属性值</h3><p>值转换器可用于在将属性值发送到数据库之前对其加密，再在发送回来时解密。例如，使用字符串反转替代实际加密算法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;User&gt;().Property(e =&gt; e.Password).HasConversion(</span><br><span class="line">    v =&gt; <span class="keyword">new</span> <span class="built_in">string</span>(v.Reverse().ToArray()),</span><br><span class="line">    v =&gt; <span class="keyword">new</span> <span class="built_in">string</span>(v.Reverse().ToArray()));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>目前没有任何方法可以从值转换器内获取对当前 DbContext 或其他会话状态的引用。 这限制了可以使用的加密类型。</p>
</blockquote>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>目前，值转换系统存在一些已知的限制：</p>
<ul>
<li>如上所述，不能转换 null。</li>
<li>目前没有办法将一个属性的转换扩展到多个列，反之亦然。</li>
<li>对于通过值转换器映射的大多数键，不支持值生成。</li>
<li>值转换无法引用当前的 DbContext 实例。</li>
<li>使用值转换类型的参数当前不能在原始 SQL API 中使用。</li>
</ul>
<h1 id="值比较器"><a href="#值比较器" class="headerlink" title="值比较器"></a>值比较器</h1><p>EF Core 内置有用于快照截取和比较数据库中使用的大多数标准类型的逻辑，所以用户通常不需要担心这个问题。 但是，当通过值转换器映射属性时，EF Core 需要对任意用户类型执行比较，这可能很复杂。 默认情况下，EF Core 使用类型定义的默认相等比较， (例如 Equals 方法) ;对于快照， 将复制值类型 以生成快照，而对于 引用类型 ，不进行复制，并将同一实例用作快照。</p>
<p>如果内置比较行为不合适，用户可以提供值比较器，其中包含用于快照截取、比较和计算哈希代码的逻辑。 例如，下面将 List<int> 属性的值转换设置为将值转换为数据库中的 JSON 字符串，并定义适当的值比较器：</int></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder</span><br><span class="line">    .Entity&lt;EntityType&gt;()</span><br><span class="line">    .Property(e =&gt; e.MyListProperty)</span><br><span class="line">    .HasConversion(</span><br><span class="line">        v =&gt; JsonSerializer.Serialize(v, (JsonSerializerOptions)<span class="literal">null</span>),</span><br><span class="line">        v =&gt; JsonSerializer.Deserialize&lt;List&lt;<span class="built_in">int</span>&gt;&gt;(v, (JsonSerializerOptions)<span class="literal">null</span>),</span><br><span class="line">        <span class="keyword">new</span> ValueComparer&lt;List&lt;<span class="built_in">int</span>&gt;&gt;(</span><br><span class="line">            (c1, c2) =&gt; c1.SequenceEqual(c2),</span><br><span class="line">            c =&gt; c.Aggregate(<span class="number">0</span>, (a, v) =&gt; HashCode.Combine(a, v.GetHashCode())),</span><br><span class="line">            c =&gt; c.ToList()));</span><br></pre></td></tr></table></figure>

<h3 id="简单的不可变类"><a href="#简单的不可变类" class="headerlink" title="简单的不可变类"></a>简单的不可变类</h3><p>考虑一个使用值转换器映射简单的不可变类的属性。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ImmutableClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImmutableClass</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Value = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Value &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params">ImmutableClass other</span>)</span></span><br><span class="line">        =&gt; Value == other.Value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params"><span class="built_in">object</span> obj</span>)</span></span><br><span class="line">        =&gt; ReferenceEquals(<span class="keyword">this</span>, obj) || obj <span class="keyword">is</span> ImmutableClass other &amp;&amp; Equals(other);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">GetHashCode</span>()</span></span><br><span class="line">        =&gt; Value.GetHashCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">modelBuilder</span><br><span class="line">    .Entity&lt;MyEntityType&gt;()</span><br><span class="line">    .Property(e =&gt; e.MyProperty)</span><br><span class="line">    .HasConversion(</span><br><span class="line">        v =&gt; v.Value,</span><br><span class="line">        v =&gt; <span class="keyword">new</span> ImmutableClass(v));</span><br></pre></td></tr></table></figure>
<p>此类型的属性不需要特殊比较或快照，原因如下：</p>
<ul>
<li>相等性被覆盖，以便不同的实例可以正确比较</li>
<li>类型是不可变的，所以不可能改变快照值<br>因此，在这种情况下，EF Core 的默认行为本身就是正常的。</li>
</ul>
<h3 id="可变类"><a href="#可变类" class="headerlink" title="可变类"></a>可变类</h3><p>建议尽可能将不可变类型（类或结构）与值转换器一起使用。 这通常比使用可变类型更有效，语义更清晰。 但是，话虽如此，使用应用程序无法更改的类型的属性是很常见的。 例如，映射包含数字列表的属性：<br><code>public List&lt;int&gt; MyListProperty &#123; get; set; &#125;</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder</span><br><span class="line">    .Entity&lt;EntityType&gt;()</span><br><span class="line">    .Property(e =&gt; e.MyListProperty)</span><br><span class="line">    .HasConversion(</span><br><span class="line">        v =&gt; JsonSerializer.Serialize(v, (JsonSerializerOptions)<span class="literal">null</span>),</span><br><span class="line">        v =&gt; JsonSerializer.Deserialize&lt;List&lt;<span class="built_in">int</span>&gt;&gt;(v, (JsonSerializerOptions)<span class="literal">null</span>),</span><br><span class="line">        <span class="keyword">new</span> ValueComparer&lt;List&lt;<span class="built_in">int</span>&gt;&gt;(</span><br><span class="line">            (c1, c2) =&gt; c1.SequenceEqual(c2),</span><br><span class="line">            c =&gt; c.Aggregate(<span class="number">0</span>, (a, v) =&gt; HashCode.Combine(a, v.GetHashCode())),</span><br><span class="line">            c =&gt; c.ToList()));</span><br></pre></td></tr></table></figure>
<p>构造 ValueComparer<T> 函数接受三个表达式：</T></p>
<ul>
<li>用于检查相等性的表达式</li>
<li>用于生成哈希代码的表达式</li>
<li>用于截取值的快照的表达式<br>在这种情况下，比较是通过检查数字序列是否相同来完成的。</li>
</ul>
<p>同样，哈希代码也是基于相同的序列构建的。 (请注意，这是可变值的哈希代码，因此 可能会导致问题。如果可以，则不可变。)</p>
<p>快照是通过使用 ToList 克隆列表来创建的。 同样，仅当要转变列表时，才需要这样做。 如果可以，请改为不可变。</p>
<h1 id="高级表映射"><a href="#高级表映射" class="headerlink" title="高级表映射"></a>高级表映射</h1><h2 id="表拆分"><a href="#表拆分" class="headerlink" title="表拆分"></a>表拆分</h2><p>EF Core 允许将两个或多个实体映射到一个表。 这称为“表拆分”或“表共享”。</p>
<p>若要使用表拆分，需将实体类型映射到同一个表，将主键映射到相同的列，并且在同一个表中的一种实体类型的主键和另一种实体类型的主键之间至少配置一种关系。</p>
<p>表拆分的一个常见场景是仅使用表中的部分列，以提高性能或实现封装。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Order</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> OrderStatus? Status &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DetailedOrder DetailedOrder &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DetailedOrder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> OrderStatus? Status &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> BillingAddress &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> ShippingAddress &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">byte</span>[] Version &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">modelBuilder.Entity&lt;DetailedOrder&gt;(</span><br><span class="line">    dob =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        dob.ToTable(<span class="string">&quot;Orders&quot;</span>);</span><br><span class="line">        dob.Property(o =&gt; o.Status).HasColumnName(<span class="string">&quot;Status&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">modelBuilder.Entity&lt;Order&gt;(</span><br><span class="line">    ob =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        ob.ToTable(<span class="string">&quot;Orders&quot;</span>);</span><br><span class="line">        ob.Property(o =&gt; o.Status).HasColumnName(<span class="string">&quot;Status&quot;</span>);</span><br><span class="line">        ob.HasOne(o =&gt; o.DetailedOrder).WithOne()</span><br><span class="line">            .HasForeignKey&lt;DetailedOrder&gt;(o =&gt; o.Id);</span><br><span class="line">        ob.Navigation(o =&gt; o.DetailedOrder).IsRequired();</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="实体拆分"><a href="#实体拆分" class="headerlink" title="实体拆分"></a>实体拆分</h2><p>EF Core 允许将实体映射到两个或多个表中的行。 这称为 实体拆分。</p>
<p>例如，假设有一个数据库，其中包含三个保存客户数据的表：</p>
<ul>
<li>Customers客户信息的表</li>
<li>PhoneNumbers客户的电话号码表</li>
<li>Addresses客户地址表<br>下面是SQL Server中这些表的定义：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [Customers] (</span><br><span class="line">    [Id] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">IDENTITY</span>,</span><br><span class="line">    [Name] nvarchar(max) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_Customers] <span class="keyword">PRIMARY</span> KEY ([Id])</span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [PhoneNumbers] (</span><br><span class="line">    [CustomerId] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    [PhoneNumber] nvarchar(max) <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_PhoneNumbers] <span class="keyword">PRIMARY</span> KEY ([CustomerId]),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [FK_PhoneNumbers_Customers_CustomerId] <span class="keyword">FOREIGN</span> KEY ([CustomerId]) <span class="keyword">REFERENCES</span> [Customers] ([Id]) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [Addresses] (</span><br><span class="line">    [CustomerId] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    [Street] nvarchar(max) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    [City] nvarchar(max) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    [PostCode] nvarchar(max) <span class="keyword">NULL</span>,</span><br><span class="line">    [Country] nvarchar(max) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_Addresses] <span class="keyword">PRIMARY</span> KEY ([CustomerId]),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [FK_Addresses_Customers_CustomerId] <span class="keyword">FOREIGN</span> KEY ([CustomerId]) <span class="keyword">REFERENCES</span> [Customers] ([Id]) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
这些表中的每个表通常映射到自己的实体类型，并具有类型之间的关系。 但是，如果所有三个表始终一起使用，则将它们全部映射到单个实体类型会更方便。 例如：<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Customer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> street, <span class="built_in">string</span> city, <span class="built_in">string</span>? postCode, <span class="built_in">string</span> country</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">        Street = street;</span><br><span class="line">        City = city;</span><br><span class="line">        PostCode = postCode;</span><br><span class="line">        Country = country;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>? PhoneNumber &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Street &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> City &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>? PostCode &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Country &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这是在 EF7 中通过为实体类型中的每个拆分调用 SplitToTable 来实现的。 例如，以下代码将 Customer 实体类型拆分为上面所示的 Customers、 PhoneNumbers和 Addresses 表：<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Customer&gt;(</span><br><span class="line">    entityBuilder =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        entityBuilder</span><br><span class="line">            .ToTable(<span class="string">&quot;Customers&quot;</span>)</span><br><span class="line">            .SplitToTable(</span><br><span class="line">                <span class="string">&quot;PhoneNumbers&quot;</span>,</span><br><span class="line">                tableBuilder =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    tableBuilder.Property(customer =&gt; customer.Id).HasColumnName(<span class="string">&quot;CustomerId&quot;</span>);</span><br><span class="line">                    tableBuilder.Property(customer =&gt; customer.PhoneNumber);</span><br><span class="line">                &#125;)</span><br><span class="line">            .SplitToTable(</span><br><span class="line">                <span class="string">&quot;Addresses&quot;</span>,</span><br><span class="line">                tableBuilder =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    tableBuilder.Property(customer =&gt; customer.Id).HasColumnName(<span class="string">&quot;CustomerId&quot;</span>);</span><br><span class="line">                    tableBuilder.Property(customer =&gt; customer.Street);</span><br><span class="line">                    tableBuilder.Property(customer =&gt; customer.City);</span><br><span class="line">                    tableBuilder.Property(customer =&gt; customer.PostCode);</span><br><span class="line">                    tableBuilder.Property(customer =&gt; customer.Country);</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h3></li>
<li>实体拆分不能用于继承结构中的实体类型。</li>
<li>对于主表中的任何行，每个拆分表中都必须有一行。</li>
</ul>
<h3 id="TPT继承映射"><a href="#TPT继承映射" class="headerlink" title="TPT继承映射"></a>TPT继承映射</h3><p>例如，假设有一个简单的继承层次结构：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Breed &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="literal">null</span>!;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>? EducationalLevel &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>? FavoriteToy &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 TPT 继承映射策略，这些类型将映射到三个表。 但是，每个表中的主键列可能具有不同的名称。 例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [Animals] (</span><br><span class="line">    [Id] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">IDENTITY</span>,</span><br><span class="line">    [Breed] nvarchar(max) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_Animals] <span class="keyword">PRIMARY</span> KEY ([Id])</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [Cats] (</span><br><span class="line">    [CatId] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    [EducationalLevel] nvarchar(max) <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_Cats] <span class="keyword">PRIMARY</span> KEY ([CatId]),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [FK_Cats_Animals_CatId] <span class="keyword">FOREIGN</span> KEY ([CatId]) <span class="keyword">REFERENCES</span> [Animals] ([Id]) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [Dogs] (</span><br><span class="line">    [DogId] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    [FavoriteToy] nvarchar(max) <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_Dogs] <span class="keyword">PRIMARY</span> KEY ([DogId]),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [FK_Dogs_Animals_DogId] <span class="keyword">FOREIGN</span> KEY ([DogId]) <span class="keyword">REFERENCES</span> [Animals] ([Id]) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>EF7 允许使用嵌套表生成器配置此映射：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Animal&gt;().ToTable(<span class="string">&quot;Animals&quot;</span>);</span><br><span class="line"></span><br><span class="line">modelBuilder.Entity&lt;Cat&gt;()</span><br><span class="line">    .ToTable(</span><br><span class="line">        <span class="string">&quot;Cats&quot;</span>,</span><br><span class="line">        tableBuilder =&gt; tableBuilder.Property(cat =&gt; cat.Id).HasColumnName(<span class="string">&quot;CatId&quot;</span>));</span><br><span class="line"></span><br><span class="line">modelBuilder.Entity&lt;Dog&gt;()</span><br><span class="line">    .ToTable(</span><br><span class="line">        <span class="string">&quot;Dogs&quot;</span>,</span><br><span class="line">        tableBuilder =&gt; tableBuilder.Property(dog =&gt; dog.Id).HasColumnName(<span class="string">&quot;DogId&quot;</span>));</span><br></pre></td></tr></table></figure>

<h1 id="从属实体类型"><a href="#从属实体类型" class="headerlink" title="从属实体类型"></a>从属实体类型</h1><p>EF Core 使你能够对只能出现在其他实体类型的导航属性上的实体类型进行建模。 它们称为“从属实体类型”。 包含从属实体类型的实体是其所有者。</p>
<p>从属实体本质上是所有者的一部分，没有它就不能存在，它们在概念上类似于聚合。 这意味着，根据定义，从属实体位于与所有者关系的从属关系中。</p>
<h2 id="将类型配置为Owned"><a href="#将类型配置为Owned" class="headerlink" title="将类型配置为Owned"></a>将类型配置为Owned</h2><p>在大多数提供程序中，实体类型永远不会按约定配置为已拥有，必须显式使用 OnModelCreating 中的 OwnsOne 方法或使用 OwnedAttribute 为类型做注释以将类型配置为已拥有。</p>
<p>在此示例中，StreetAddress 是一个无标识类型。 它用作 Order 类型的属性来指定特定订单的发货地址。我们可以使用 OwnedAttribute 将其标记为从属实体：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Owned</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StreetAddress</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Street &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> City &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Order</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> StreetAddress ShippingAddress &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以使用 OnModelCreating 中的 OwnsOne 方法来指定 ShippingAddress 属性是 Order 实体类型的从属实体，并根据需要配置其他方面。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Order&gt;().OwnsOne(p =&gt; p.ShippingAddress);</span><br></pre></td></tr></table></figure>
<p>如果 ShippingAddress 属性在 Order 类型中是专用的，则可以使用 OwnsOne 方法的字符串版本：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Order&gt;().OwnsOne(<span class="keyword">typeof</span>(StreetAddress), <span class="string">&quot;ShippingAddress&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="隐式键"><a href="#隐式键" class="headerlink" title="隐式键"></a>隐式键</h2><p>使用 OwnsOne 配置的从属类型或通过引用导航发现的从属类型始终与所有者具有一对一的关系，因此它们不需要自己的键值，因为外键值是唯一的。 在上面的示例中，StreetAddress 类型不需要定义键属性。</p>
<p>为了了解 EF Core 如何跟踪这些对象，了解主键是作为从属类型的属性创建的很有用。 从属类型的实例的键值将与所有者实例的键值相同。</p>
<h1 id="无键实体类型"><a href="#无键实体类型" class="headerlink" title="无键实体类型"></a>无键实体类型</h1><p>除了常规实体类型外，EF Core 模型还可以包含无键实体类型，可用于对不包含键值的数据执行数据库查询。</p>
<h2 id="定义无键实体类型"><a href="#定义无键实体类型" class="headerlink" title="定义无键实体类型"></a>定义无键实体类型</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Keyless</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BlogPostsCount</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> BlogName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostCount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="无键实体类型特征"><a href="#无键实体类型特征" class="headerlink" title="无键实体类型特征"></a>无键实体类型特征</h2><p>无键实体类型支持与常规实体类型相同的多个映射功能，例如继承映射和导航属性。 在关系存储上，它们可以通过 Fluent API 方法或数据注释来配置目标数据库对象和列。</p>
<p>但是，它们不同于常规实体类型，因为它们：</p>
<ul>
<li>不能定义键。</li>
<li>永远不会对 DbContext 中的更改进行跟踪，因此不会对数据库进行插入、更新或删除这些操作。</li>
<li>绝不会被约定发现。</li>
<li>仅支持导航映射功能的子集，具体如下：<ul>
<li>它们永远不能充当关系的主体端。</li>
<li>它们可能没有指向从属实体的导航</li>
<li>它们只能包含指向常规实体的引用导航属性。</li>
<li>实体不能包含无键实体类型的导航属性。</li>
</ul>
</li>
<li>需要配置 [Keyless] 数据注释或 .HasNoKey() 方法调用。</li>
<li>可以映射到定义查询。 定义查询是在模型中声明的查询，它充当无键实体类型的数据源。</li>
<li>可以有层次结构，但必须映射为 TPH。</li>
<li>不能使用表拆分或实体拆分。</li>
</ul>
<h2 id="使用方案"><a href="#使用方案" class="headerlink" title="使用方案"></a>使用方案</h2><p>无键实体类型的一些主要使用场景包括：</p>
<ul>
<li>用作 SQL 查询的返回类型。</li>
<li>映射到不包含主键的数据库视图。</li>
<li>映射到未定义主键的表。</li>
<li>映射到模型中定义的查询。</li>
</ul>
<h1 id="模型批量配置"><a href="#模型批量配置" class="headerlink" title="模型批量配置"></a>模型批量配置</h1><h2 id="OnModelCreating-中的批量配置"><a href="#OnModelCreating-中的批量配置" class="headerlink" title="OnModelCreating 中的批量配置"></a>OnModelCreating 中的批量配置</h2><p>从 ModelBuilder 返回的每个生成器对象都会公开ModelMetadata 属性，该属性提供对构成模型对象的低级别访问。 具体而言，有一些方法允许循环访问模型中的特定对象，并对其应用通用配置。</p>
<p>在以下示例中， 模型包含自定义值类型 Currency：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">struct</span> Currency</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Currency</span>(<span class="params"><span class="built_in">decimal</span> amount</span>)</span></span><br><span class="line">        =&gt; Amount = amount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Amount &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">        =&gt; <span class="string">$&quot;$<span class="subst">&#123;Amount&#125;</span>&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下不会发现此类型的属性，因为当前 EF 提供程序不知道如何将它映射到数据库类型。 此代码片段 OnModelCreating 添加 类型 Currency 的所有属性，并将值转换器配置为受支持的类型 - decimal：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> entityType <span class="keyword">in</span> modelBuilder.Model.GetEntityTypes())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> propertyInfo <span class="keyword">in</span> entityType.ClrType.GetProperties())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (propertyInfo.PropertyType == <span class="keyword">typeof</span>(Currency))</span><br><span class="line">        &#123;</span><br><span class="line">            entityType.AddProperty(propertyInfo)</span><br><span class="line">                .SetValueConverter(<span class="keyword">typeof</span>(CurrencyConverter));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CurrencyConverter</span> : <span class="title">ValueConverter</span>&lt;<span class="title">Currency</span>, <span class="title">decimal</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CurrencyConverter</span>()</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">            v =&gt; v.Amount,</span></span></span><br><span class="line"><span class="params"><span class="function">            v =&gt; <span class="keyword">new</span> Currency(v</span>))</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="元数据-API-的缺点"><a href="#元数据-API-的缺点" class="headerlink" title="元数据 API 的缺点"></a>元数据 API 的缺点</h2><p>与 Fluent API 不同，对模型的每个修改都需要显式完成。 例如，如果某些 Currency 属性按约定配置为导航，则需要先删除引用 CLR 属性的导航，然后再为其添加实体类型属性。 #9117 将对此进行改进。<br>约定在每次更改后运行。 如果删除由约定发现的导航，该约定将再次运行，并可以重新添加它。 若要防止这种情况发生，需要延迟约定，直到通过调用 DelayConventions() 并稍后释放返回的对象添加属性后，或使用 将 CLR 属性标记为已忽略。AddIgnored<br>此迭代发生后，可能会添加实体类型，并且配置不会应用于这些实体类型。 通常可以通过将此代码放在 末尾 OnModelCreating来防止这种情况，但如果具有两组相互依赖的配置，则可能不会有一个允许一致应用它们的顺序。</p>
<h2 id="预约定配置"><a href="#预约定配置" class="headerlink" title="预约定配置"></a>预约定配置</h2><p>EF Core 允许为给定 CLR 类型指定一次映射配置;然后，该配置在发现时应用于模型中该类型的所有属性。 这称为“预约定模型配置”，因为它在允许运行模型生成约定之前配置模型的各个方面。 通过重写 ConfigureConventions 派生自 DbContext的类型来应用此类配置。</p>
<p>此示例演示如何将 类型 Currency 的所有属性配置为具有值转换器：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">ConfigureConventions</span>(<span class="params">ModelConfigurationBuilder configurationBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    configurationBuilder</span><br><span class="line">        .Properties&lt;Currency&gt;()</span><br><span class="line">        .HaveConversion&lt;CurrencyConverter&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 它将覆盖所有约定和数据注释。 例如，使用上述配置时，所有字符串外键属性都将创建为具有 1024 的非 unicode MaxLength ，即使这与主体键不匹配也是如此。</p>
</blockquote>
<h2 id="忽略类型"><a href="#忽略类型" class="headerlink" title="忽略类型"></a>忽略类型</h2><p>约定前配置还允许忽略类型，并阻止约定将其作为实体类型或实体类型的属性发现：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">configurationBuilder</span><br><span class="line">    .IgnoreAny(<span class="keyword">typeof</span>(IList&lt;&gt;));</span><br></pre></td></tr></table></figure>

<h2 id="默认类型映射"><a href="#默认类型映射" class="headerlink" title="默认类型映射"></a>默认类型映射</h2><p>通常，只要为此类型的属性指定了值转换器，EF 就可以使用提供程序不支持的类型常量转换查询。 但是，在不涉及此类型的任何属性的查询中，EF 无法找到正确的值转换器。 在这种情况下，可以调用 DefaultTypeMapping 以添加或替代提供程序类型映射：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configurationBuilder</span><br><span class="line">    .DefaultTypeMapping&lt;Currency&gt;()</span><br><span class="line">    .HasConversion&lt;CurrencyConverter&gt;();</span><br></pre></td></tr></table></figure>
<h2 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h2><p>EF Core 模型生成约定是包含逻辑的类，这些逻辑基于生成模型时对模型所做的更改触发。 这会在进行显式配置、应用映射属性和其他约定时使模型保持最新状态。 为了参与此目的，每个约定实现一个或多个接口，用于确定何时触发相应的方法。 例如，每当向模型添加新实体类型时，将触发实现 IEntityTypeAddedConvention 的约定。 同样，每当向模型添加键或外键时，都会触发实现 和 IKeyAddedConvention 的IForeignKeyAddedConvention约定。</p>
<p>模型生成约定是控制模型配置的一种强大方法，但可能很复杂，很难正确。</p>
<h3 id="添加新约定"><a href="#添加新约定" class="headerlink" title="添加新约定"></a>添加新约定</h3><h4 id="约束鉴别器属性的长度"><a href="#约束鉴别器属性的长度" class="headerlink" title="约束鉴别器属性的长度"></a>约束鉴别器属性的长度</h4><p>让我们通过首次尝试实现鉴别器长度约定，使这更具体一点：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DiscriminatorLengthConvention1</span> : <span class="title">IEntityTypeBaseTypeChangedConvention</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ProcessEntityTypeBaseTypeChanged</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        IConventionEntityTypeBuilder entityTypeBuilder,</span></span></span><br><span class="line"><span class="params"><span class="function">        IConventionEntityType? newBaseType,</span></span></span><br><span class="line"><span class="params"><span class="function">        IConventionEntityType? oldBaseType,</span></span></span><br><span class="line"><span class="params"><span class="function">        IConventionContext&lt;IConventionEntityType&gt; context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> discriminatorProperty = entityTypeBuilder.Metadata.FindDiscriminatorProperty();</span><br><span class="line">        <span class="keyword">if</span> (discriminatorProperty != <span class="literal">null</span></span><br><span class="line">            &amp;&amp; discriminatorProperty.ClrType == <span class="keyword">typeof</span>(<span class="built_in">string</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            discriminatorProperty.Builder.HasMaxLength(<span class="number">24</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此约定实现 IEntityTypeBaseTypeChangedConvention，这意味着每当实体类型的映射继承层次结构发生更改时，都会触发它。 然后，该约定查找并配置层次结构的字符串鉴别器属性。</p>
<p>然后，通过在 中ConfigureConventions调用 Add 来使用此约定：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">ConfigureConventions</span>(<span class="params">ModelConfigurationBuilder configurationBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    configurationBuilder.Conventions.Add(_ =&gt;  <span class="keyword">new</span> DiscriminatorLengthConvention1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，如果我们现在显式配置不同的鉴别器属性，会发生什么情况呢？ 例如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Post&gt;()</span><br><span class="line">    .HasDiscriminator&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;PostTypeDiscriminator&quot;</span>)</span><br><span class="line">    .HasValue&lt;Post&gt;(<span class="string">&quot;Post&quot;</span>)</span><br><span class="line">    .HasValue&lt;FeaturedPost&gt;(<span class="string">&quot;Featured&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这是因为我们在约定中配置的鉴别器属性后来在添加自定义鉴别器时被删除。 我们可以尝试通过在约定上实现另一个接口来修复此问题，以响应鉴别器更改，但找出要实现的接口并不容易。</p>
<p>幸运的是，有一种更简单的方法。 很多时候，只要最终模型正确，模型在生成时的外观并不重要。 此外，要应用的配置通常不需要触发其他约定来做出反应。 因此，我们的约定可以实现 IModelFinalizingConvention。 模型最终确定约定 在所有其他模型生成完成后运行，因此可以访问模型的接近最终状态。 这与响应每个模型更改并确保模型在方法执行的任何时间点处于最新状态的OnModelCreating交互式约定相反。 模型最终确定约定通常会循环访问整个模型，以根据需要配置模型元素。 因此，在这种情况下，我们会在模型中找到每个鉴别器并对其进行配置：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DiscriminatorLengthConvention2</span> : <span class="title">IModelFinalizingConvention</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ProcessModelFinalizing</span>(<span class="params">IConventionModelBuilder modelBuilder, IConventionContext&lt;IConventionModelBuilder&gt; context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> entityType <span class="keyword">in</span> modelBuilder.Metadata.GetEntityTypes()</span><br><span class="line">                     .Where(entityType =&gt; entityType.BaseType == <span class="literal">null</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> discriminatorProperty = entityType.FindDiscriminatorProperty();</span><br><span class="line">            <span class="keyword">if</span> (discriminatorProperty != <span class="literal">null</span></span><br><span class="line">                &amp;&amp; discriminatorProperty.ClrType == <span class="keyword">typeof</span>(<span class="built_in">string</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                discriminatorProperty.Builder.HasMaxLength(<span class="number">24</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用此新约定生成模型后，我们发现现在已正确配置了鉴别器长度，即使已对其进行自定义：</p>
<p>我们可以更进一步，将最大长度配置为最长的鉴别器值的长度：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DiscriminatorLengthConvention3</span> : <span class="title">IModelFinalizingConvention</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ProcessModelFinalizing</span>(<span class="params">IConventionModelBuilder modelBuilder, IConventionContext&lt;IConventionModelBuilder&gt; context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> entityType <span class="keyword">in</span> modelBuilder.Metadata.GetEntityTypes()</span><br><span class="line">                     .Where(entityType =&gt; entityType.BaseType == <span class="literal">null</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> discriminatorProperty = entityType.FindDiscriminatorProperty();</span><br><span class="line">            <span class="keyword">if</span> (discriminatorProperty != <span class="literal">null</span></span><br><span class="line">                &amp;&amp; discriminatorProperty.ClrType == <span class="keyword">typeof</span>(<span class="built_in">string</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> maxDiscriminatorValueLength =</span><br><span class="line">                    entityType.GetDerivedTypesInclusive().Select(e =&gt; ((<span class="built_in">string</span>)e.GetDiscriminatorValue()!).Length).Max();</span><br><span class="line"></span><br><span class="line">                discriminatorProperty.Builder.HasMaxLength(maxDiscriminatorValueLength);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，鉴别器列的最大长度为 8，即“特别推荐”的长度，这是使用的最长的鉴别器值。</p>
<h2 id="替换现有约定"><a href="#替换现有约定" class="headerlink" title="替换现有约定"></a>替换现有约定</h2><p>有时，与其完全删除现有约定，不如将其替换为执行基本相同操作但行为已更改的约定。 这很有用，因为现有约定已实现需要适当触发的接口。</p>
<h2 id="何时将每种方法用于批量配置"><a href="#何时将每种方法用于批量配置" class="headerlink" title="何时将每种方法用于批量配置"></a>何时将每种方法用于批量配置</h2><p>在以下情况下使用 元数据 API ：</p>
<ul>
<li>需要在特定时间应用配置，而不是对模型中的后续更改做出反应。</li>
<li>模型生成速度非常重要。 元数据 API 的安全检查较少，因此可能比其他方法稍快一些，但使用 已编译的模型 将产生更好的启动时间。</li>
</ul>
<p>在以下情况下使用 约定前模型配置 ：</p>
<ul>
<li>适用性条件很简单，因为它仅取决于类型。</li>
<li>需要在模型中添加给定类型的属性并重写数据注释和约定时应用配置</li>
</ul>
<p>在以下情况下使用 Finalizing 约定 ：</p>
<ul>
<li>适用性条件很复杂。</li>
<li>配置不应替代数据批注指定的内容。</li>
</ul>
<p>在以下情况下使用 交互式约定 ：</p>
<ul>
<li>多个约定相互依赖。 完成约定按添加顺序运行，因此无法对以后完成约定所做的更改做出反应。</li>
<li>逻辑在多个上下文之间共享。 交互式约定比其他方法更安全。</li>
</ul>
<h1 id="IModelCacheKeyFactory"><a href="#IModelCacheKeyFactory" class="headerlink" title="IModelCacheKeyFactory"></a>IModelCacheKeyFactory</h1><p>EF 使用 IModelCacheKeyFactory 为模型生成缓存键；默认情况下，EF 假定对于任何给定的上下文类型，模型都相同，因此该服务的默认实现将返回仅包含上下文类型的键。 若要从同一上下文类型构建不同的模型，需要将服务替换为正确的实现；生成的键将使用 IModelCacheKeyFactoryEquals 方法与其他的模型键进行比较，同时考虑影响模型的所有变量。</p>
<p>以下实现在生成模型缓存键时考虑 UseIntProperty：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DynamicModelCacheKeyFactory</span> : <span class="title">IModelCacheKeyFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Create</span>(<span class="params">DbContext context, <span class="built_in">bool</span> designTime</span>)</span></span><br><span class="line">        =&gt; context <span class="keyword">is</span> DynamicContext dynamicContext</span><br><span class="line">            ? (context.GetType(), dynamicContext.UseIntProperty, designTime)</span><br><span class="line">            : (<span class="built_in">object</span>)context.GetType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还必须实现 Create 方法的重载，该方法也处理设计时模型缓存。 如以下示例所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DynamicModelCacheKeyFactoryDesignTimeSupport</span> : <span class="title">IModelCacheKeyFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Create</span>(<span class="params">DbContext context, <span class="built_in">bool</span> designTime</span>)</span></span><br><span class="line">        =&gt; context <span class="keyword">is</span> DynamicContext dynamicContext</span><br><span class="line">            ? (context.GetType(), dynamicContext.UseIntProperty, designTime)</span><br><span class="line">            : (<span class="built_in">object</span>)context.GetType();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Create</span>(<span class="params">DbContext context</span>)</span></span><br><span class="line">        =&gt; Create(context, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，在上下文的 OnConfiguring 中注册新的 IModelCacheKeyFactory：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span></span><br><span class="line">    =&gt; optionsBuilder</span><br><span class="line">        .UseInMemoryDatabase(<span class="string">&quot;DynamicContext&quot;</span>)</span><br><span class="line">        .ReplaceService&lt;IModelCacheKeyFactory, DynamicModelCacheKeyFactory&gt;();</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2022/11/18/EFCore/%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9E%8B(%E4%B8%80)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/18/EFCore/%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9E%8B(%E4%B8%80)/" class="post-title-link" itemprop="url">创建模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-11-18 17:19:56" itemprop="dateCreated datePublished" datetime="2022-11-18T17:19:56+08:00">2022-11-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-13 14:50:54" itemprop="dateModified" datetime="2023-03-13T14:50:54+08:00">2023-03-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="创建并配置模型"><a href="#创建并配置模型" class="headerlink" title="创建并配置模型"></a>创建并配置模型</h1><p>Entity Framework Core 使用一组约定来根据实体类的形状生成模型。 可指定其他配置以补充和&#x2F;或替代约定的内容。</p>
<h2 id="使用-fluent-API-配置模型"><a href="#使用-fluent-API-配置模型" class="headerlink" title="使用 fluent API 配置模型"></a>使用 fluent API 配置模型</h2><p>Fluent API 配置具有最高优先级，并将替代约定和数据注释。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Blog</span>&gt; Blogs</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> Required</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">            .Property(b =&gt; b.Url)</span><br><span class="line">            .IsRequired();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分组配置"><a href="#分组配置" class="headerlink" title="分组配置"></a>分组配置</h2><p>为了减小 <code>OnModelCreating</code> 方法的大小，可以将实体类型的所有配置提取到实现 <code>IEntityTypeConfiguration&lt;TEntity&gt;</code> 的单独类中。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BlogEntityTypeConfiguration</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Blog</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Blog&gt; builder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        builder</span><br><span class="line">            .Property(b =&gt; b.Url)</span><br><span class="line">            .IsRequired();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，只需从 OnModelCreating 调用 Configure 方法。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> BlogEntityTypeConfiguration().Configure(modelBuilder.Entity&lt;Blog&gt;());</span><br></pre></td></tr></table></figure>
<p>可以在给定程序集中应用实现 <code>IEntityTypeConfiguration</code>的类型中指定的所有配置。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.ApplyConfigurationsFromAssembly(<span class="keyword">typeof</span>(BlogEntityTypeConfiguration).Assembly);</span><br></pre></td></tr></table></figure>
<h2 id="使用数据注释来配置模型"><a href="#使用数据注释来配置模型" class="headerlink" title="使用数据注释来配置模型"></a>使用数据注释来配置模型</h2><p>也可将特性（称为数据注释）应用于类和属性。 数据注释会替代约定，但会被 Fluent API 配置替代。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Blog&gt; Blogs &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Table(<span class="string">&quot;Blogs&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Required</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="实体类型"><a href="#实体类型" class="headerlink" title="实体类型"></a>实体类型</h1><p>在上下文中包含一种类型的 DbSet 意味着它包含在 EF Core 的模型中；我们通常将此类类型称为实体。</p>
<h2 id="在模型中包含类型"><a href="#在模型中包含类型" class="headerlink" title="在模型中包含类型"></a>在模型中包含类型</h2><p>按照约定，上下文的<code>DbSet</code>属性中公开的类型作为实体包含在模型中。 还包括在 <code>OnModelCreating</code>方法中指定的实体类型，以及通过递归探索其他发现的实体类型的导航属性找到的任何类型。</p>
<p>*** 下面的代码示例中包含了所有类型：***</p>
<p>包含<code>Blog</code>，因为它在上下文的<code>DbSet</code>属性中公开。<br>包含<code>Post</code>，因为它是通过<code>Blog.Posts</code> 导航属性发现的。<br>包含<code>AuditEntry</code>因为它是 <code>OnModelCreating</code>中指定的。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Blog</span>&gt; Blogs</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;AuditEntry&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Post&gt; Posts &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Blog Blog &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AuditEntry</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> AuditEntryId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Username &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Action &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="从模型中排除类型"><a href="#从模型中排除类型" class="headerlink" title="从模型中排除类型"></a>从模型中排除类型</h2><p>如果不希望在模型中包含某一类型，则可以排除它：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Ignore&lt;BlogMetadata&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从迁移中排除"><a href="#从迁移中排除" class="headerlink" title="从迁移中排除"></a>从迁移中排除</h3><p>有时，将相同的实体类型映射到多个<code>DbContext</code>类型中非常有用。 在使用绑定上下文时尤其如此，对于每段绑定上下文，使用不同<code>DbContext</code>类型的情况很常见</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;IdentityUser&gt;()</span><br><span class="line">        .ToTable(<span class="string">&quot;AspNetUsers&quot;</span>, t =&gt; t.ExcludeFromMigrations());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此配置迁移不会创建<code>AspNetUsers</code>该表，但<code>IdentityUser</code> 仍包含在模型中，并且可正常使用。</p>
<p>如果需要再次使用迁移来管理表，则应创建不包括 <code>AspNetUsers</code>的新迁移。 下一次迁移将包含对表所做的任何更改。</p>
<h2 id="表名称"><a href="#表名称" class="headerlink" title="表名称"></a>表名称</h2><p>每个实体类型都将设置为映射到与公开实体的 DbSet 属性名称相同的数据库表。 如果给定实体不存在 DbSet，则使用类名称,可以手动配置表名</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .ToTable(<span class="string">&quot;blogs&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="表架构"><a href="#表架构" class="headerlink" title="表架构"></a>表架构</h2><p>使用关系数据库时，表按约定在数据库的默认架构中创建,你可以配置要在特定架构中创建的表，如下所示</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .ToTable(<span class="string">&quot;blogs&quot;</span>, schema: <span class="string">&quot;blogging&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以在模型级别使用 Fluent API 定义默认架构，而不是为每个表指定架构：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.HasDefaultSchema(<span class="string">&quot;blogging&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置默认架构也会影响其他数据库对象，例如序列。</p>
<h2 id="视图映射"><a href="#视图映射" class="headerlink" title="视图映射"></a>视图映射</h2><p>可以使用 Fluent API 将实体类型映射到数据库视图，EF 假定数据库中已存在引用的视图，它不会在迁移中自动创建它。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">    .ToView(<span class="string">&quot;blogsView&quot;</span>, schema: <span class="string">&quot;blogging&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>映射到视图将删除默认表映射，但从 EF 5.0 开始，实体类型也可以显式映射到表。 在这种情况下，查询映射将用于查询，表映射将用于更新。</p>
<h2 id="表值函数映射"><a href="#表值函数映射" class="headerlink" title="表值函数映射"></a>表值函数映射</h2><p>若要将实体映射到表值函数，函数必须是无参数的</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BlogWithMultiplePosts</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostCount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CREATE FUNCTION dbo.BlogsWithMultiplePosts()</span><br><span class="line"><span class="function">RETURNS TABLE</span></span><br><span class="line"><span class="function">AS</span></span><br><span class="line"><span class="function"><span class="title">RETURN</span></span></span><br><span class="line"><span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    SELECT b.Url, COUNT(p.BlogId</span>) AS PostCount</span></span><br><span class="line"><span class="function">    FROM Blogs AS b</span></span><br><span class="line"><span class="function">    JOIN Posts AS p ON b.BlogId</span> = p.BlogId</span><br><span class="line">    GROUP BY b.BlogId, b.<span class="function">Url</span></span><br><span class="line"><span class="function">    HAVING <span class="title">COUNT</span>(<span class="params">p.BlogId</span>) &gt; 1</span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">modelBuilder.<span class="title">Entity</span>&lt;<span class="title">BlogWithMultiplePosts</span>&gt;().<span class="title">HasNoKey</span>().<span class="title">ToFunction</span>(<span class="params"><span class="string">&quot;BlogsWithMultiplePosts&quot;</span></span>)</span>;</span><br></pre></td></tr></table></figure>
<p>通常情况下，实体属性将映射到 TVF 返回的匹配列。 如果 TVF 返回的列名称与实体属性的名称不同，则可以使用 HasColumnName 方法配置实体的列，就像映射到常规表一样。</p>
<h2 id="表注释"><a href="#表注释" class="headerlink" title="表注释"></a>表注释</h2><p>可以对数据库表设置任意文本注释，从而在数据库中记录架构</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;().ToTable(</span><br><span class="line">        tableBuilder =&gt; tableBuilder.HasComment(<span class="string">&quot;Blogs managed on the website&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="共享类型实体类型"><a href="#共享类型实体类型" class="headerlink" title="共享类型实体类型"></a>共享类型实体类型</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;&gt; Blogs =&gt; Set&lt;Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;&gt;(<span class="string">&quot;Blog&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.SharedTypeEntity&lt;Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;&gt;(</span><br><span class="line">            <span class="string">&quot;Blog&quot;</span>, bb =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                bb.Property&lt;<span class="built_in">int</span>&gt;(<span class="string">&quot;BlogId&quot;</span>);</span><br><span class="line">                bb.Property&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Url&quot;</span>);</span><br><span class="line">                bb.Property&lt;DateTime&gt;(<span class="string">&quot;LastUpdated&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实体属性"><a href="#实体属性" class="headerlink" title="实体属性"></a>实体属性</h1><p>模型中的每个实体类型都有一组属性，EF Core 将从数据库中读取和写入这些属性。 如果使用的是关系数据库，实体属性将映射到表列。</p>
<h2 id="已包含和已排除的属性"><a href="#已包含和已排除的属性" class="headerlink" title="已包含和已排除的属性"></a>已包含和已排除的属性</h2><p>按照约定，所有具有 Getter 和 Setter 的公共属性都将包含在模型中。</p>
<p>可以按如下所示排除特定属性：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Ignore(b =&gt; b.LoadedFromDatabase);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="列名"><a href="#列名" class="headerlink" title="列名"></a>列名</h2><p>按照约定，使用关系数据库时，实体属性将映射到与属性同名的表列。</p>
<p>如果希望配置具有不同名称的列，可以按以下代码片段进行操作：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(b =&gt; b.BlogId)</span><br><span class="line">        .HasColumnName(<span class="string">&quot;blog_id&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="列数据类型"><a href="#列数据类型" class="headerlink" title="列数据类型"></a>列数据类型</h2><p>还可以配置列以指定列的确切数据类型</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;(</span><br><span class="line">        eb =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            eb.Property(b =&gt; b.Url).HasColumnType(<span class="string">&quot;varchar(200)&quot;</span>);</span><br><span class="line">            eb.Property(b =&gt; b.Rating).HasColumnType(<span class="string">&quot;decimal(5, 2)&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最大长度"><a href="#最大长度" class="headerlink" title="最大长度"></a>最大长度</h2><p>在向提供程序传递数据之前，实体框架不会执行任何最大长度的验证。 而是由提供程序或数据存储根据情况进行验证。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(b =&gt; b.Url)</span><br><span class="line">        .HasMaxLength(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="精度和小数位数"><a href="#精度和小数位数" class="headerlink" title="精度和小数位数"></a>精度和小数位数</h2><p>哪些数据类型支持精度和小数位数取决于数据库，但在大多数数据库中，decimal 和 DateTime 类型支持这些 Facet</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(b =&gt; b.Score)</span><br><span class="line">        .HasPrecision(<span class="number">14</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(b =&gt; b.LastUpdated)</span><br><span class="line">        .HasPrecision(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不先定义精度，则永远不会定义小数位数，因此用于定义小数位数的 Fluent API 为 HasPrecision(precision, scale)。</p>
<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>在某些关系数据库中，存在不同的类型来表示 Unicode 和非 Unicode 文本数据。 例如，在 SQL Server 中，nvarchar(x)用于表示 UTF-16 中的 Unicode 数据，而varchar(x)用于表示非 Unicode 数据<br>默认情况下，文本属性配置为 Unicode。 可以将列配置为非 Unicode，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Book&gt;()</span><br><span class="line">        .Property(b =&gt; b.Isbn)</span><br><span class="line">        .IsUnicode(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="必需和可选属性"><a href="#必需和可选属性" class="headerlink" title="必需和可选属性"></a>必需和可选属性</h2><p>如果属性包含<code>null</code>是有效的，则该属性被视为可选属性。 如果<code>null</code>不是要分配给属性的有效值，则它被视为必需属性。 映射到关系数据库架构时，必需属性创建为不可为<code>null</code>的列，可选属性创建为可为<code>null</code>的列。</p>
<h3 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h3><p>按照约定，其<code>.NET</code>类型可包含<code>null</code>的属性将配置为可选属性，而<code>.NET</code>类型不能包含<code>null</code>的属性将配置为必需属性。 例如，所有具有<code>.NET</code>值类型<code>(intdecimal、bool等)</code>的属性都配置为必需，并且具有可为<code>null</code>的 <code>.NET</code>值类型的所有属性<code>(int?decimal?、bool?等)</code>配置为可选。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Customer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> FirstName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// Required by convention</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> LastName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// Required by convention</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>? MiddleName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// Optional by convention</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note the following use of constructor binding, which avoids compiled warnings</span></span><br><span class="line">    <span class="comment">// for uninitialized non-nullable properties.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span>(<span class="params"><span class="built_in">string</span> firstName, <span class="built_in">string</span> lastName, <span class="built_in">string</span>? middleName = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        FirstName = firstName;</span><br><span class="line">        LastName = lastName;</span><br><span class="line">        MiddleName = middleName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="显式配置"><a href="#显式配置" class="headerlink" title="显式配置"></a>显式配置</h3><p>按约定为可选属性的属性可以配置为必需属性，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(b =&gt; b.Url)</span><br><span class="line">        .IsRequired();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="列排序规则"><a href="#列排序规则" class="headerlink" title="列排序规则"></a>列排序规则</h2><p>可以定义文本列的排序规则，以确定如何比较和排序</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Customer&gt;().Property(c =&gt; c.Name)</span><br><span class="line">    .UseCollation(<span class="string">&quot;SQL_Latin1_General_CP1_CI_AS&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>如果数据库中的所有列都需要使用特定的排序规则，请改为在数据库级别定义排序规则。</p>
<h2 id="列注释"><a href="#列注释" class="headerlink" title="列注释"></a>列注释</h2><p>可以对数据库列设置任意文本注释，从而在数据库中记录架构：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(b =&gt; b.Url)</span><br><span class="line">        .HasComment(<span class="string">&quot;The URL of the blog&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="列顺序"><a href="#列顺序" class="headerlink" title="列顺序"></a>列顺序</h2><p>默认情况下，在使用迁移创建表时，EF Core 首先为主键列排序，然后为实体类型和从属类型的属性排序，最后为基类型中的属性排序。 但是，你可以指定不同的列顺序：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Employee&gt;(x =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        x.Property(b =&gt; b.Id)</span><br><span class="line">            .HasColumnOrder(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        x.Property(b =&gt; b.FirstName)</span><br><span class="line">            .HasColumnOrder(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        x.Property(b =&gt; b.LastName)</span><br><span class="line">            .HasColumnOrder(<span class="number">2</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，在一般情况下，大多数数据库仅支持在创建表时对列进行排序。 这意味着不能使用列顺序特性对现有表中的列进行重新排序</p>
<h1 id="键"><a href="#键" class="headerlink" title="键"></a>键</h1><p>键用作每个实体实例的唯一标识符</p>
<h2 id="配置主键"><a href="#配置主键" class="headerlink" title="配置主键"></a>配置主键</h2><p>根据约定，名为 Id 或 <type name>Id 的属性将被配置为实体的主键</type></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Make &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Model &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Truck</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> TruckId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Make &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Model &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可将单个属性配置为实体的主键，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Car&gt;()</span><br><span class="line">        .HasKey(c =&gt; c.LicensePlate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可将多个属性配置为实体的键 - 这称为组合键。 约定仅在特定情况下设置组合键 - 例如，对于拥有的类型集合。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Car&gt;()</span><br><span class="line">        .HasKey(c =&gt; <span class="keyword">new</span> &#123; c.State, c.LicensePlate &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创造价值"><a href="#创造价值" class="headerlink" title="创造价值"></a>创造价值</h3><p>对于非复合数字和<code>GUID</code>主键，<code>EF Core</code>根据约定设置值生成</p>
<h3 id="主键名称"><a href="#主键名称" class="headerlink" title="主键名称"></a>主键名称</h3><p>根据约定，在关系数据库上，主键使用名称<code>PK_&lt;type name&gt;</code> 进行创建。 可按如下方式配置主键约束的名称：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .HasKey(b =&gt; b.BlogId)</span><br><span class="line">        .HasName(<span class="string">&quot;PrimaryKey_BlogId&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="键类型和值"><a href="#键类型和值" class="headerlink" title="键类型和值"></a>键类型和值</h3><p>向上下文添加新实体时，键属性必须始终具有非默认值，但某些类型将由数据库生成。 在这种情况下，当添加实体以用于跟踪时，EF 将尝试生成一个临时值。 调用 SaveChanges 后，临时值将替换为数据库生成的值。</p>
<p>如果键属性的值由数据库生成，并且在添加实体时指定了非默认值，则 EF 将假定该实体已存在于数据库中，并尝试更新它，而不是插入新的实体。</p>
<h3 id="备用键"><a href="#备用键" class="headerlink" title="备用键"></a>备用键</h3><p>除主键外，备选键还充当每个实体实例的备用唯一标识符；它可以用作关系的目标<br>如果只想对列强制执行唯一性，请定义唯一索引而不是备选键</p>
<p>备选建通常根据需要引入，无需手动配置。 根据约定，当你将不是主键的属性标识为关系的目标时，会引入备选键。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Blog</span>&gt; Blogs</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Post</span>&gt; Posts</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;Post&gt;()</span><br><span class="line">            .HasOne(p =&gt; p.Blog)</span><br><span class="line">            .WithMany(b =&gt; b.Posts)</span><br><span class="line">            .HasForeignKey(p =&gt; p.BlogUrl)</span><br><span class="line">            .HasPrincipalKey(b =&gt; b.Url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Post&gt; Posts &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> BlogUrl &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Blog Blog &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可将单个属性配置为备选键：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Car&gt;()</span><br><span class="line">        .HasAlternateKey(c =&gt; c.LicensePlate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可将多个属性配置为备选键（即复合备选键）：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Car&gt;()</span><br><span class="line">        .HasAlternateKey(c =&gt; <span class="keyword">new</span> &#123; c.State, c.LicensePlate &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可配置备选键的索引和唯一约束的名称：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Car&gt;()</span><br><span class="line">        .HasAlternateKey(c =&gt; c.LicensePlate)</span><br><span class="line">        .HasName(<span class="string">&quot;AlternateKey_LicensePlate&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="生成的值"><a href="#生成的值" class="headerlink" title="生成的值"></a>生成的值</h1><p>数据库列的值可以通过多种方式生成：主键列通常是自动递增的整数，其他列具有默认值或计算值等。</p>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>在关系数据库中，可以为列配置默认值；如果插入的行没有该列的值，则将使用默认值。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(b =&gt; b.Rating)</span><br><span class="line">        .HasDefaultValue(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以指定用于计算默认值的 SQL 片段：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(b =&gt; b.Created)</span><br><span class="line">        .HasDefaultValueSql(<span class="string">&quot;getdate()&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计算列"><a href="#计算列" class="headerlink" title="计算列"></a>计算列</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Person&gt;()</span><br><span class="line">    .Property(p =&gt; p.DisplayName)</span><br><span class="line">    .HasComputedColumnSql(<span class="string">&quot;[LastName] + &#x27;, &#x27; + [FirstName]&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>以上命令将创建一个虚拟计算列，每次从数据库中提取时都会计算其值。 你也可以将计算列指定为存储（有时称为持久化）计算列，这意味着系统会在每次更新行时计算该列，并将其与常规列一起存储在磁盘上：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Person&gt;()</span><br><span class="line">    .Property(p =&gt; p.NameLength)</span><br><span class="line">    .HasComputedColumnSql(<span class="string">&quot;LEN([LastName]) + LEN([FirstName])&quot;</span>, stored: <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><h3 id="显式配置值生成"><a href="#显式配置值生成" class="headerlink" title="显式配置值生成"></a>显式配置值生成</h3><p>EF Core 会自动为主键设置值生成 - 但我们可能希望对非键属性执行相同的操作。 你可以将任何属性配置为针对插入的实体生成其值，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(b =&gt; b.Inserted)</span><br><span class="line">        .ValueGeneratedOnAdd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，可以将属性配置为在添加或更新时生成其值：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(b =&gt; b.LastUpdated)</span><br><span class="line">        .ValueGeneratedOnAddOrUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>与默认值或计算列不同，我们没有指定值的生成方式；这取决于所使用的数据库提供程序。 数据库提供程序可能会自动为某些属性类型设置值生成，但其他属性类型可能需要你手动设置值的生成方式。</strong></p>
<h2 id="日期-x2F-时间值生成"><a href="#日期-x2F-时间值生成" class="headerlink" title="日期&#x2F;时间值生成"></a>日期&#x2F;时间值生成</h2><p>EF Core 提供程序通常不会为日期&#x2F;时间列自动设置值生成 - 你必须自行配置。</p>
<h3 id="创建时间戳"><a href="#创建时间戳" class="headerlink" title="创建时间戳"></a>创建时间戳</h3><p>若要将日期&#x2F;时间列配置为包含行的创建时间戳，通常需要使用适当的 SQL 函数来配置默认值。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(b =&gt; b.Created)</span><br><span class="line">        .HasDefaultValueSql(<span class="string">&quot;getdate()&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更新时间戳"><a href="#更新时间戳" class="headerlink" title="更新时间戳"></a>更新时间戳</h3><p>尽管存储计算列看起来非常适合管理上次更新时间戳，但数据库通常不允许在计算列中指定诸如 GETDATE() 之类的函数。 作为替代方法，你可以设置一个数据库触发器来达到同样的效果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> [dbo].[Blogs_UPDATE] <span class="keyword">ON</span> [dbo].[Blogs]</span><br><span class="line">    AFTER <span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SET</span> NOCOUNT <span class="keyword">ON</span>;</span><br><span class="line"></span><br><span class="line">    IF ((<span class="keyword">SELECT</span> TRIGGER_NESTLEVEL()) <span class="operator">&gt;</span> <span class="number">1</span>) <span class="keyword">RETURN</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">DECLARE</span> <span class="variable">@Id</span> <span class="type">INT</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="variable">@Id</span> <span class="operator">=</span> INSERTED.BlogId</span><br><span class="line">    <span class="keyword">FROM</span> INSERTED</span><br><span class="line"></span><br><span class="line">    <span class="keyword">UPDATE</span> dbo.Blogs</span><br><span class="line">    <span class="keyword">SET</span> LastUpdated <span class="operator">=</span> GETDATE()</span><br><span class="line">    <span class="keyword">WHERE</span> BlogId <span class="operator">=</span> <span class="variable">@Id</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<h2 id="替代值生成"><a href="#替代值生成" class="headerlink" title="替代值生成"></a>替代值生成</h2><p>尽管为属性配置了值生成，但在许多情况下，你仍然可以为其显式指定一个值。 此操作能否真正起作用取决于已配置的特定值生成机制；虽然你可以指定显式值而不是使用列的默认值，但不能对计算列执行相同的操作。</p>
<p>若要使用显式值替代值生成，只需将属性设置为该属性类型的 CLR 默认值（string 为 null，int 为 0，Guid 为 Guid.Empty，等等）以外的任意值。</p>
<p>若要为已配置为在添加或更新时生成值的属性提供显式值，还必须按以下方式配置该属性：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;().Property(b =&gt; b.LastUpdated)</span><br><span class="line">        .ValueGeneratedOnAddOrUpdate()</span><br><span class="line">        .Metadata.SetAfterSaveBehavior(PropertySaveBehavior.Save);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="无值生成"><a href="#无值生成" class="headerlink" title="无值生成"></a>无值生成</h2><p>除了上述特定方案外，属性通常不会配置值生成；这意味着，始终由应用程序提供要保存到数据库的值。 必须先将此值分配给新实体，然后才能将新实体添加到上下文中。</p>
<p>但是，在某些情况下，你可能希望禁用按约定设置的值生成。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(b =&gt; b.BlogId)</span><br><span class="line">        .ValueGeneratedNever();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="阴影和索引器属性"><a href="#阴影和索引器属性" class="headerlink" title="阴影和索引器属性"></a>阴影和索引器属性</h1><p>阴影属性不是在 .NET 实体类中定义的，但在 EF Core 模型中是为该实体类型定义的。 这些属性的值和状态纯粹保留在更改跟踪器中。 当数据库中存在不应在映射的实体类型上公开的数据时，阴影属性非常有用。</p>
<p>索引器属性是实体类型属性，由 .NET 实体类中的 索引器器提供支持。 可以使用 .NET 类实例上的索引器访问它们。 它还允许向实体类型添加其他属性，而无需更改 CLR 类。</p>
<h2 id="外键阴影属性"><a href="#外键阴影属性" class="headerlink" title="外键阴影属性"></a>外键阴影属性</h2><p>阴影属性通常用于外键属性，其中两个实体之间的关系由数据库中的外键值表示，但这种关系是通过实体类型之间的导航属性来管理的。 根据约定，当发现关系，但在依赖实体类中找不到外键属性时，EF 将引入阴影属性。</p>
<p>例如，以下代码列表将导致 BlogId 阴影属性引入 Post 实体：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Blog&gt; Blogs &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Post&gt; Posts &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Post&gt; Posts &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Since there is no CLR property which holds the foreign</span></span><br><span class="line">    <span class="comment">// key for this relationship, a shadow property is created.</span></span><br><span class="line">    <span class="keyword">public</span> Blog Blog &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置阴影属性"><a href="#配置阴影属性" class="headerlink" title="配置阴影属性"></a>配置阴影属性</h2><p>可以使用 Fluent API 来配置阴影属性。 调用 Property 的字符串重载后，可以链接针对其他属性的任何配置调用。 在下面的示例中，由于 Blog 没有名为 LastUpdated 的 CLR 属性，因此将创建阴影属性：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Blog</span>&gt; Blogs</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">            .Property&lt;DateTime&gt;(<span class="string">&quot;LastUpdated&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="访问阴影属性"><a href="#访问阴影属性" class="headerlink" title="访问阴影属性"></a>访问阴影属性</h2><p>可以通过 ChangeTracker API 获取和更改阴影属性值：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.Entry(myBlog).Property(<span class="string">&quot;LastUpdated&quot;</span>).CurrentValue = DateTime.Now;</span><br></pre></td></tr></table></figure>
<p>可以通过 EF.Property 静态方法在 LINQ 查询中引用阴影属性：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blogs = context.Blogs</span><br><span class="line">    .OrderBy(b =&gt; EF.Property&lt;DateTime&gt;(b, <span class="string">&quot;LastUpdated&quot;</span>));</span><br></pre></td></tr></table></figure>
<h2 id="配置索引器属性"><a href="#配置索引器属性" class="headerlink" title="配置索引器属性"></a>配置索引器属性</h2><p>在下面的示例中，Blog 定义了一个索引器，该索引器将用于创建索引器属性。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Blog</span>&gt; Blogs</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;Blog&gt;().IndexerProperty&lt;DateTime&gt;(<span class="string">&quot;LastUpdated&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt; _data = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> <span class="keyword">this</span>[<span class="built_in">string</span> key]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; _data[key];</span><br><span class="line">        <span class="keyword">set</span> =&gt; _data[key] = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性包实体类型"><a href="#属性包实体类型" class="headerlink" title="属性包实体类型"></a>属性包实体类型</h2><p>仅包含索引器属性的实体类型称为属性包实体类型。 这些实体类型没有阴影属性，EF 会改为创建索引器属性。 目前仅支持将 Dictionary&lt;string, object&gt; 作为属性包实体类型。 必须配置为具有唯一名称的共享类型实体 类型，并且必须使用 Set 调用实现相应的 DbSet 属性。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;&gt; Blogs =&gt; Set&lt;Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;&gt;(<span class="string">&quot;Blog&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.SharedTypeEntity&lt;Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;&gt;(</span><br><span class="line">            <span class="string">&quot;Blog&quot;</span>, bb =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                bb.Property&lt;<span class="built_in">int</span>&gt;(<span class="string">&quot;BlogId&quot;</span>);</span><br><span class="line">                bb.Property&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Url&quot;</span>);</span><br><span class="line">                bb.Property&lt;DateTime&gt;(<span class="string">&quot;LastUpdated&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h1><p>关系定义两个实体之间的相关性。 在关系数据库中，关系由外键约束表示。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Post&gt; Posts &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Blog Blog &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Post</code> 是依赖实体</p>
<p><code>Blog</code> 是主体实体</p>
<p><code>Blog.BlogId</code> 是主体键（在此示例中，它是主键，而不是备选键）</p>
<p><code>Post.BlogId</code> 是外键</p>
<p><code>Post.Blog</code> 是引用导航属性</p>
<p><code>Blog.Posts</code> 是集合导航属性</p>
<p><code>Post.Blog</code> 是 <code>Blog.Posts</code> 的反向导航属性（反之亦然）</p>
<h2 id="约定-1"><a href="#约定-1" class="headerlink" title="约定"></a>约定</h2><p>按约定发现的关系将始终以主体实体的主键为目标。 若要以备选键为目标，必须使用 Fluent API 执行配置。</p>
<h3 id="完全定义的关系"><a href="#完全定义的关系" class="headerlink" title="完全定义的关系"></a>完全定义的关系</h3><h3 id="无外键属性"><a href="#无外键属性" class="headerlink" title="无外键属性"></a>无外键属性</h3><p>虽然建议在依赖实体类中定义外键属性，但这不是必需的。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Post&gt; Posts &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Blog Blog &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此示例中，影子外键为 BlogId，因为预先输入导航名称是多余的。</p>
<p><strong>如果已存在同名的属性，则影子属性名称将带有数字后缀(如果属性是主键或属性的类型与主体键不兼容，则不会将其配置为外键。)</strong></p>
<h3 id="单个导航属性"><a href="#单个导航属性" class="headerlink" title="单个导航属性"></a>单个导航属性</h3><p>仅包含一个导航属性（没有反向导航，也没有外键属性）就足以按约定定义关系。 还可包含一个导航属性和一个外键属性。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Post&gt; Posts &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>如果在两个类型之间定义了多个导航属性（即不止一对指向彼此的导航），则由导航属性表示的关系是不明确的。 需要对它们进行手动配置才能解决这种不明确的关系。</p>
<h3 id="级联删除"><a href="#级联删除" class="headerlink" title="级联删除"></a>级联删除</h3><p>根据约定，对于必需关系，级联删除将设置为<code>Cascade</code>，对于可选关系，它将设置为<code>ClientSetNull</code>。<code>Cascade</code>表示也会删除依赖实体。<code>ClientSetNull</code>表示未加载到内存中的依赖实体将保持不变，必须手动删除或更新以指向有效的主体实体。 对于加载到内存中的实体，EF Core 将尝试将外键属性设置为 <code>null</code>。</p>
<h2 id="手动配置"><a href="#手动配置" class="headerlink" title="手动配置"></a>手动配置</h2><p>若要在<code>Fluent API</code>中配置关系，首先应标识构成关系的导航属性。<code>HasOne</code>或<code>HasMany</code>标识要开始配置的实体类型的导航属性。然后，将调用链接到<code>WithOne</code>或<code>WithMany</code>以标识反向导航。<code>HasOne/WithOne</code>用于引用导航属性,<code>HasMany/WithMany</code>用于集合导航属性。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Blog</span>&gt; Blogs</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Post</span>&gt; Posts</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;Post&gt;()</span><br><span class="line">            .HasOne(p =&gt; p.Blog)</span><br><span class="line">            .WithMany(b =&gt; b.Posts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Post&gt; Posts &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Blog Blog &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单个导航属性-1"><a href="#单个导航属性-1" class="headerlink" title="单个导航属性"></a>单个导航属性</h3><p>如果只有一个导航属性，则<code>WithOne</code>和<code>WithMany</code>会发生无参数重载。 这表示在关系的另一端，存在概念上的引用或集合，但实体类中不包含导航属性。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Blog</span>&gt; Blogs</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Post</span>&gt; Posts</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">            .HasMany(b =&gt; b.Posts)</span><br><span class="line">            .WithOne();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Post&gt; Posts &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配置导航属性"><a href="#配置导航属性" class="headerlink" title="配置导航属性"></a>配置导航属性</h2><p>创建导航属性后，可能需要进一步对其进行配置。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .HasMany(b =&gt; b.Posts)</span><br><span class="line">        .WithOne();</span><br><span class="line"></span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Navigation(b =&gt; b.Posts)</span><br><span class="line">        .UsePropertyAccessMode(PropertyAccessMode.Property);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>可使用 Fluent API 来配置哪个属性应用作给定关系的外键属性：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Blog</span>&gt; Blogs</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Post</span>&gt; Posts</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;Post&gt;()</span><br><span class="line">            .HasOne(p =&gt; p.Blog)</span><br><span class="line">            .WithMany(b =&gt; b.Posts)</span><br><span class="line">            .HasForeignKey(p =&gt; p.BlogForeignKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">List</span>&lt;<span class="title">Post</span>&gt; Posts</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogForeignKey &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Blog Blog &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复合主键</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Car</span>&gt; Cars</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;Car&gt;()</span><br><span class="line">            .HasKey(c =&gt; <span class="keyword">new</span> &#123; c.State, c.LicensePlate &#125;);</span><br><span class="line"></span><br><span class="line">        modelBuilder.Entity&lt;RecordOfSale&gt;()</span><br><span class="line">            .HasOne(s =&gt; s.Car)</span><br><span class="line">            .WithMany(c =&gt; c.SaleHistory)</span><br><span class="line">            .HasForeignKey(s =&gt; <span class="keyword">new</span> &#123; s.CarState, s.CarLicensePlate &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> State &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> LicensePlate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Make &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Model &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;RecordOfSale&gt; SaleHistory &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RecordOfSale</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> RecordOfSaleId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime DateSold &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> CarState &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> CarLicensePlate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Car Car &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="影子外键"><a href="#影子外键" class="headerlink" title="影子外键"></a>影子外键</h3><p>可以使用 的字符串重载 HasForeignKey(…) 将阴影属性配置为外键,建议在将影子属性用作外键之前将其显式添加到模型中</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Blog</span>&gt; Blogs</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Post</span>&gt; Posts</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Add the shadow property to the model</span></span><br><span class="line">        modelBuilder.Entity&lt;Post&gt;()</span><br><span class="line">            .Property&lt;<span class="built_in">int</span>&gt;(<span class="string">&quot;BlogForeignKey&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use the shadow property as a foreign key</span></span><br><span class="line">        modelBuilder.Entity&lt;Post&gt;()</span><br><span class="line">            .HasOne(p =&gt; p.Blog)</span><br><span class="line">            .WithMany(b =&gt; b.Posts)</span><br><span class="line">            .HasForeignKey(<span class="string">&quot;BlogForeignKey&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Post&gt; Posts &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Blog Blog &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="外键约束名称"><a href="#外键约束名称" class="headerlink" title="外键约束名称"></a>外键约束名称</h3><p>根据约定，当以关系数据库作为目标时，外键约束将命名为 FK__&lt;依赖类型名称&gt;<em>&lt;主体类型名称&gt;</em>&lt;外键属性名称&gt;。 对于复合外键，&lt;外键属性名称&gt; 将成为外键属性名称的下划线分隔列表。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Post&gt;()</span><br><span class="line">        .HasOne(p =&gt; p.Blog)</span><br><span class="line">        .WithMany(b =&gt; b.Posts)</span><br><span class="line">        .HasForeignKey(p =&gt; p.BlogId)</span><br><span class="line">        .HasConstraintName(<span class="string">&quot;ForeignKey_Post_Blog&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="没有导航属性"><a href="#没有导航属性" class="headerlink" title="没有导航属性"></a>没有导航属性</h3><p>无需提供导航属性。 只需在关系的一侧提供外键。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Blog</span>&gt; Blogs</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Post</span>&gt; Posts</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;Post&gt;()</span><br><span class="line">            .HasOne&lt;Blog&gt;()</span><br><span class="line">            .WithMany()</span><br><span class="line">            .HasForeignKey(p =&gt; p.BlogId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="主体键"><a href="#主体键" class="headerlink" title="主体键"></a>主体键</h3><p>如果想要外键引用主键外的属性，可使用 Fluent API 为关系配置主体键属性。 配置为主体键的属性将自动设置为备选键</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Car</span>&gt; Cars</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;RecordOfSale&gt;()</span><br><span class="line">            .HasOne(s =&gt; s.Car)</span><br><span class="line">            .WithMany(c =&gt; c.SaleHistory)</span><br><span class="line">            .HasForeignKey(s =&gt; <span class="keyword">new</span> &#123; s.CarState, s.CarLicensePlate &#125;)</span><br><span class="line">            .HasPrincipalKey(c =&gt; <span class="keyword">new</span> &#123; c.State, c.LicensePlate &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> CarId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> State &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> LicensePlate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Make &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Model &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;RecordOfSale&gt; SaleHistory &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RecordOfSale</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> RecordOfSaleId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime DateSold &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> CarState &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> CarLicensePlate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Car Car &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="必需关系和可选关系"><a href="#必需关系和可选关系" class="headerlink" title="必需关系和可选关系"></a>必需关系和可选关系</h3><p>如果实体类中具有外键属性，则关系的必需性取决于外键属性是必需还是可选，外键属性位于依赖实体类型上，因此如果按要求配置它们，则意味着每个依赖实体都需要具有相应的主体实体。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Post&gt;()</span><br><span class="line">        .HasOne(p =&gt; p.Blog)</span><br><span class="line">        .WithMany(b =&gt; b.Posts)</span><br><span class="line">        .IsRequired();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="级联删除-1"><a href="#级联删除-1" class="headerlink" title="级联删除"></a>级联删除</h3><p>可使用 Fluent API 显式配置给定关系的级联删除行为。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Post&gt;()</span><br><span class="line">        .HasOne(p =&gt; p.Blog)</span><br><span class="line">        .WithMany(b =&gt; b.Posts)</span><br><span class="line">        .OnDelete(DeleteBehavior.Cascade);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他关系模式"><a href="#其他关系模式" class="headerlink" title="其他关系模式"></a>其他关系模式</h2><h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><p>一对一关系在两侧都有引用导航属性。 它们遵循与一对多关系相同的约定，但在外键属性上引入了一个唯一索引，以确保只有一个依赖项与每个主体相关。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BlogImage BlogImage &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BlogImage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogImageId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">byte</span>[] Image &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Caption &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Blog Blog &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在配置与 Fluent API 的关系时，可使用 HasOne 和 WithOne 方法。</p>
<p>显而易见，在一对多关系中，具有引用导航的实体是依赖项，而具有集合的实体是主体。 但在一对一的关系中并非如此，因此需要对其进行显式定义。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Blog</span>&gt; Blogs</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">BlogImage</span>&gt; BlogImages</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">            .HasOne(b =&gt; b.BlogImage)</span><br><span class="line">            .WithOne(i =&gt; i.Blog)</span><br><span class="line">            .HasForeignKey&lt;BlogImage&gt;(b =&gt; b.BlogForeignKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BlogImage BlogImage &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BlogImage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogImageId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">byte</span>[] Image &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Caption &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogForeignKey &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Blog Blog &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下依赖端为可选，但可视需要进行配置。 但是，EF 不会验证是否提供了依赖实体，因此此配置仅在数据库映射允许强制执行时才会产生影响。 此种情况的一个常见场景是默认使用表拆分的引用从属类型。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Order&gt;(</span><br><span class="line">    ob =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        ob.OwnsOne(</span><br><span class="line">            o =&gt; o.ShippingAddress,</span><br><span class="line">            sa =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                sa.Property(p =&gt; p.Street).IsRequired();</span><br><span class="line">                sa.Property(p =&gt; p.City).IsRequired();</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        ob.Navigation(o =&gt; o.ShippingAddress)</span><br><span class="line">            .IsRequired();</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>通过此配置，与 ShippingAddress 对应的列将在数据库中标记为不可为 null。</p>
<h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>多对多关系需要两端的集合导航属性。 与其他类型的关系一样，它们也可通过约定发现。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ICollection&lt;Tag&gt; Tags &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Tag</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> TagId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ICollection&lt;Post&gt; Posts &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在数据库中实现此关系的方式是使用联接表，其中包含 Post 和 Tag 的外键。 例如，以下就是 EF 将在关系数据库中为上述模型创建的内容。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [Posts] (</span><br><span class="line">    [PostId] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">IDENTITY</span>,</span><br><span class="line">    [Title] nvarchar(max) <span class="keyword">NULL</span>,</span><br><span class="line">    [Content] nvarchar(max) <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_Posts] <span class="keyword">PRIMARY</span> KEY ([PostId])</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [Tags] (</span><br><span class="line">    [TagId] nvarchar(<span class="number">450</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_Tags] <span class="keyword">PRIMARY</span> KEY ([TagId])</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [PostTag] (</span><br><span class="line">    [PostsId] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    [TagsId] nvarchar(<span class="number">450</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_PostTag] <span class="keyword">PRIMARY</span> KEY ([PostsId], [TagsId]),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [FK_PostTag_Posts_PostsId] <span class="keyword">FOREIGN</span> KEY ([PostsId]) <span class="keyword">REFERENCES</span> [Posts] ([PostId]) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [FK_PostTag_Tags_TagsId] <span class="keyword">FOREIGN</span> KEY ([TagsId]) <span class="keyword">REFERENCES</span> [Tags] ([TagId]) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在内部，EF 创建一个实体类型Dictionary&lt;string, object&gt; 来表示将称为联接实体类型的联接表。 Dictionary&lt;string, object&gt; 当前用于处理外键属性的任意组合，有关详细信息，请参阅属性包实体类型。 模型中可以存在多个多对多关系，因此必须为联接实体类型指定唯一的名称，在本例中为 PostTag。 允许此操作的功能称为共享类型实体类型。<br><strong>按照约定，用于联接实体类型的 CLR 类型可能会在未来版本中更改以提高性能。 除非已显式配置，否则不要依赖于联接类型 Dictionary&lt;string, object&gt;，如下一节所述。</strong></p>
<p>多对多导航称为跳过导航，因为它们有效地跳过联接实体类型。 如果使用的是批量配置，则可以从 GetSkipNavigations获取所有跳过导航。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> entityType <span class="keyword">in</span> modelBuilder.Model.GetEntityTypes())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> skipNavigation <span class="keyword">in</span> entityType.GetSkipNavigations())</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(entityType.DisplayName() + <span class="string">&quot;.&quot;</span> + skipNavigation.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="联接实体类型配置"><a href="#联接实体类型配置" class="headerlink" title="联接实体类型配置"></a>联接实体类型配置</h4><p>将配置应用于联接实体类型是很常见的。 此操作可通过 UsingEntity 完成。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder</span><br><span class="line">    .Entity&lt;Post&gt;()</span><br><span class="line">    .HasMany(p =&gt; p.Tags)</span><br><span class="line">    .WithMany(p =&gt; p.Posts)</span><br><span class="line">    .UsingEntity(j =&gt; j.ToTable(<span class="string">&quot;PostTags&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>其他数据可存储在联接实体类型中，但为此最好创建一个定制的 CLR 类型。 使用自定义联接实体类型配置关系时，需要显式指定这两个外键。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyContext</span>(<span class="params">DbContextOptions&lt;MyContext&gt; options</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">options</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Post</span>&gt; Posts</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Tag</span>&gt; Tags</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;Post&gt;()</span><br><span class="line">            .HasMany(p =&gt; p.Tags)</span><br><span class="line">            .WithMany(p =&gt; p.Posts)</span><br><span class="line">            .UsingEntity&lt;PostTag&gt;(</span><br><span class="line">                j =&gt; j</span><br><span class="line">                    .HasOne(pt =&gt; pt.Tag)</span><br><span class="line">                    .WithMany(t =&gt; t.PostTags)</span><br><span class="line">                    .HasForeignKey(pt =&gt; pt.TagId),</span><br><span class="line">                j =&gt; j</span><br><span class="line">                    .HasOne(pt =&gt; pt.Post)</span><br><span class="line">                    .WithMany(p =&gt; p.PostTags)</span><br><span class="line">                    .HasForeignKey(pt =&gt; pt.PostId),</span><br><span class="line">                j =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    j.Property(pt =&gt; pt.PublicationDate).HasDefaultValueSql(<span class="string">&quot;CURRENT_TIMESTAMP&quot;</span>);</span><br><span class="line">                    j.HasKey(t =&gt; <span class="keyword">new</span> &#123; t.PostId, t.TagId &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ICollection&lt;Tag&gt; Tags &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;PostTag&gt; PostTags &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Tag</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> TagId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ICollection&lt;Post&gt; Posts &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;PostTag&gt; PostTags &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PostTag</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DateTime PublicationDate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Post Post &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> TagId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Tag Tag &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="联接关系配置"><a href="#联接关系配置" class="headerlink" title="联接关系配置"></a>联接关系配置</h4><p>EF 对联接实体类型使用两个一对多关系来表示多对多关系。 可在 UsingEntity 参数中配置这些关系。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Post&gt;()</span><br><span class="line">    .HasMany(p =&gt; p.Tags)</span><br><span class="line">    .WithMany(p =&gt; p.Posts)</span><br><span class="line">    .UsingEntity&lt;Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;&gt;(</span><br><span class="line">        <span class="string">&quot;PostTag&quot;</span>,</span><br><span class="line">        j =&gt; j</span><br><span class="line">            .HasOne&lt;Tag&gt;()</span><br><span class="line">            .WithMany()</span><br><span class="line">            .HasForeignKey(<span class="string">&quot;TagsId&quot;</span>)</span><br><span class="line">            .HasConstraintName(<span class="string">&quot;FK_PostTag_Tags_TagId&quot;</span>)</span><br><span class="line">            .OnDelete(DeleteBehavior.Cascade),</span><br><span class="line">        j =&gt; j</span><br><span class="line">            .HasOne&lt;Post&gt;()</span><br><span class="line">            .WithMany()</span><br><span class="line">            .HasForeignKey(<span class="string">&quot;PostsId&quot;</span>)</span><br><span class="line">            .HasConstraintName(<span class="string">&quot;FK_PostTag_Posts_PostId&quot;</span>)</span><br><span class="line">            .OnDelete(DeleteBehavior.ClientCascade));</span><br></pre></td></tr></table></figure>

<h4 id="间接多对多关系"><a href="#间接多对多关系" class="headerlink" title="间接多对多关系"></a>间接多对多关系</h4><p>还可表示多对多关系，只需添加联接实体类型并映射两个单独的一对多关系。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyContext</span>(<span class="params">DbContextOptions&lt;MyContext&gt; options</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">options</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Post</span>&gt; Posts</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Tag</span>&gt; Tags</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;PostTag&gt;()</span><br><span class="line">            .HasKey(t =&gt; <span class="keyword">new</span> &#123; t.PostId, t.TagId &#125;);</span><br><span class="line"></span><br><span class="line">        modelBuilder.Entity&lt;PostTag&gt;()</span><br><span class="line">            .HasOne(pt =&gt; pt.Post)</span><br><span class="line">            .WithMany(p =&gt; p.PostTags)</span><br><span class="line">            .HasForeignKey(pt =&gt; pt.PostId);</span><br><span class="line"></span><br><span class="line">        modelBuilder.Entity&lt;PostTag&gt;()</span><br><span class="line">            .HasOne(pt =&gt; pt.Tag)</span><br><span class="line">            .WithMany(t =&gt; t.PostTags)</span><br><span class="line">            .HasForeignKey(pt =&gt; pt.TagId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;PostTag&gt; PostTags &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Tag</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> TagId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;PostTag&gt; PostTags &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PostTag</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DateTime PublicationDate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Post Post &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> TagId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Tag Tag &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是许多数据存储中的常见概念。 尽管它们在数据存储中的实现可能会有所不同，但它们可用于使基于列（或一组列）的查找更加高效。<br>可对列指定索引，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .HasIndex(b =&gt; b.Url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据约定，会在用作外键的每个属性（或属性集）中创建索引</p>
<h2 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h2><p>索引还可以跨多个列：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Person&gt;()</span><br><span class="line">        .HasIndex(p =&gt; <span class="keyword">new</span> &#123; p.FirstName, p.LastName &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="索引唯一性"><a href="#索引唯一性" class="headerlink" title="索引唯一性"></a>索引唯一性</h2><p>默认情况下，索引不唯一：对于索引的列集，允许多行具有相同的值。<br>可使索引唯一，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .HasIndex(b =&gt; b.Url)</span><br><span class="line">        .IsUnique();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尝试为索引的列集插入多个具有相同值的实体将导致引发异常。</p>
<h2 id="索引排序顺序"><a href="#索引排序顺序" class="headerlink" title="索引排序顺序"></a>索引排序顺序</h2><p>在大多数数据库中，索引涵盖的每个列可以是升序或降序。 对于仅包含一列的索引，这通常并不重要：数据库可以根据需要以相反的顺序遍历索引。 但是，对于复合索引，排序对于良好的性能至关重要，并且可以表示查询是否使用索引之间的差异。 通常，索引列的排序顺序应对应于查询的 ORDER BY 子句中指定的排序顺序。</p>
<p>索引排序顺序默认为升序。 可以按如下所示使所有列按降序排列：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .HasIndex(b =&gt; <span class="keyword">new</span> &#123; b.Url, b.Rating &#125;)</span><br><span class="line">        .IsDescending();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以按列指定排序顺序，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .HasIndex(b =&gt; <span class="keyword">new</span> &#123; b.Url, b.Rating &#125;)</span><br><span class="line">        .IsDescending(<span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="索引名称"><a href="#索引名称" class="headerlink" title="索引名称"></a>索引名称</h2><p>根据约定，在关系数据库中创建的索引被命名为<code>IX_&lt;type name&gt;_&lt;property name&gt;</code>。 对于复合索引，<code>&lt;property name&gt;</code> 将成为以下划线分隔的属性名称列表。</p>
<p>可设置在数据库中创建的索引的名称：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .HasIndex(b =&gt; b.Url)</span><br><span class="line">        .HasDatabaseName(<span class="string">&quot;Index_Url&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="索引筛选器"><a href="#索引筛选器" class="headerlink" title="索引筛选器"></a>索引筛选器</h2><p>通过某些关系数据库，可指定筛选索引或部分索引。 这使你可以仅索引列值的子集，从而减少索引的大小并改善性能和磁盘空间的使用情况。<br>可使用 Fluent API 在索引上指定筛选器（以 SQL 表达式的形式提供）：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .HasIndex(b =&gt; b.Url)</span><br><span class="line">        .HasFilter(<span class="string">&quot;[Url] IS NOT NULL&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EF 为作为唯一索引一部分的所有可为 null 列添加 ‘IS NOT NULL’ 筛选器。 若要替代此约定，可提供一个 null 值。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .HasIndex(b =&gt; b.Url)</span><br><span class="line">        .IsUnique()</span><br><span class="line">        .HasFilter(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="包含列"><a href="#包含列" class="headerlink" title="包含列"></a>包含列</h2><p>通过某些关系数据库，可配置一组列，这些列包含在索引中，但不是其“键”的一部分。 当查询中的所有列都作为键列或非键列包含在索引中时，这可以显著提高查询性能，因为无需访问表本身。                                                         在以下示例中，Url 列是索引键的一部分，因此对该列的任何查询筛选都可以使用索引。 但除此之外，仅访问 Title 和 PublishedOn 列的查询将不需要访问表，并且会更高效地运行：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Post&gt;()</span><br><span class="line">        .HasIndex(p =&gt; p.Url)</span><br><span class="line">        .IncludeProperties(</span><br><span class="line">            p =&gt; <span class="keyword">new</span> &#123; p.Title, p.PublishedOn &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="检查约束"><a href="#检查约束" class="headerlink" title="检查约束"></a>检查约束</h2><p>检查约束是一项标准关系功能，让你可以定义一个条件，该条件必须适用于表中的所有行；任何违反约束的插入或修改数据的尝试都将失败。 检查约束类似于非 null 约束（禁止列中的空值）或唯一约束（禁止重复），但允许定义任意 SQL 表达式。</p>
<p>可使用 Fluent API 指定表的检查约束（以 SQL 表达式的形式提供）：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder</span><br><span class="line">        .Entity&lt;Product&gt;()</span><br><span class="line">        .ToTable(b =&gt; b.HasCheckConstraint(<span class="string">&quot;CK_Prices&quot;</span>, <span class="string">&quot;[Price] &gt; [DiscountedPrice]&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>EF 可以将 .NET 类型层次结构映射到数据库。 这允许你像往常一样使用基类型和派生类型在代码中编写 .NET 实体，并让 EF 无缝创建适当的数据库架构、发出查询等。有关如何映射类型层次结构的实际细节取决于提供程序；本页介绍关系数据库上下文中的继</p>
<h2 id="实体类型层次结构映射-TPH"><a href="#实体类型层次结构映射-TPH" class="headerlink" title="实体类型层次结构映射(TPH)"></a>实体类型层次结构映射(TPH)</h2><p>如果要映射层次结构中的 CLR 类型，就必须在模型上显式指定该类型。 例如，仅指定层次结构的基类型不会导致 EF Core 隐式包含其所有子类型。</p>
<p>以下示例将为 Blog 及其子类 RssBlog 公开 DbSet。 如果 Blog 有任何其他子类，它不会包含在模型中。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Blog&gt; Blogs &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;RssBlog&gt; RssBlogs &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RssBlog</span> : <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> RssUrl &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 TPH 映射时，数据库列会根据需要自动设置为可为 null。 例如，RssUrl 列可为 null，因为常规 Blog 实例没有该属性。</p>
<p>如果不依赖约定，则可以使用 HasBaseType 显式指定基类型。 还可以使用 .HasBaseType((Type)null) 从层次结构中删除实体类型。</p>
<h2 id="每个层次结构一张表和鉴别器配置-TPT"><a href="#每个层次结构一张表和鉴别器配置-TPT" class="headerlink" title="每个层次结构一张表和鉴别器配置(TPT)"></a>每个层次结构一张表和鉴别器配置(TPT)</h2><p>TPH 使用单个表来存储层次结构中所有类型的数据，并使用鉴别器列来标识每行表示的类型。</p>
<p>上面的模型映射到以下数据库架构（注意隐式创建的 Discriminator 列，它标识了每行中存储的 Blog 类型）。</p>
<p>可以配置鉴别器列的名称和类型以及用于标识层次结构中每种类型的值：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .HasDiscriminator&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;blog_type&quot;</span>)</span><br><span class="line">        .HasValue&lt;Blog&gt;(<span class="string">&quot;blog_base&quot;</span>)</span><br><span class="line">        .HasValue&lt;RssBlog&gt;(<span class="string">&quot;blog_rss&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，EF 在层次结构的基本实体上隐式添加了鉴别器作为影子属性。 可以像配置任何其他属性一样配置此属性：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(<span class="string">&quot;Discriminator&quot;</span>)</span><br><span class="line">        .HasMaxLength(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，鉴别器也可以映射到实体中的常规 .NET 属性：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .HasDiscriminator(b =&gt; b.BlogType);</span><br><span class="line"></span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(e =&gt; e.BlogType)</span><br><span class="line">        .HasMaxLength(<span class="number">200</span>)</span><br><span class="line">        .HasColumnName(<span class="string">&quot;blog_type&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询使用 TPH 模式的派生实体时，EF Core 会在查询中添加一个基于鉴别器列的谓词。<br>此筛选器确保对于结果中没有的基类型或同级类型，我们不会获得任何附加行。<br>对于基本实体类型，将跳过此筛选器谓词，因为查询基本实体将获得层次结构中所有实体的结果。<br>在具体化查询结果时，如果遇到未映射到模型中任何实体类型的鉴别器值，我们将引发异常，因为我们不知道如何具体化结果。<br>仅当数据库包含的行具有鉴别器值并且这些值未映射到 EF 模型时，才会发生此错误。<br>如果你有这样的数据，可以将 EF Core 模型中的鉴别器映射标记为不完整，以指示我们应始终添加筛选器谓词来查询层次结构中的任意类型。 IsComplete(false) 在鉴别器配置上调用会将映射标记为不完整。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .HasDiscriminator()</span><br><span class="line">        .IsComplete(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="共享列"><a href="#共享列" class="headerlink" title="共享列"></a>共享列</h2><p>默认情况下，当层次结构中的两个同级实体类型具有同名的属性时，它们将映射到两个单独的列。 但是，如果它们的类型相同，则可以映射到相同的数据库列：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">BlogBase</span>&gt; Blogs</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">            .Property(b =&gt; b.Url)</span><br><span class="line">            .HasColumnName(<span class="string">&quot;Url&quot;</span>);</span><br><span class="line"></span><br><span class="line">        modelBuilder.Entity&lt;RssBlog&gt;()</span><br><span class="line">            .Property(b =&gt; b.Url)</span><br><span class="line">            .HasColumnName(<span class="string">&quot;Url&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">BlogBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span> : <span class="title">BlogBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RssBlog</span> : <span class="title">BlogBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用强制转换查询共享列时，关系数据库提供程序（例如 SQL Server）不会自动使用鉴别器谓词。 查询 Url &#x3D; (blog as RssBlog).Url 还将返回同级 Blog 行的 Url 值。 若要将查询限制为 RssBlog 实体，你需要在鉴别器上手动添加筛选器，例如 Url &#x3D; blog is RssBlog ? (blog as RssBlog).Url : null。</p>
<h2 id="每个类型一张表配置"><a href="#每个类型一张表配置" class="headerlink" title="每个类型一张表配置"></a>每个类型一张表配置</h2><p>在 TPT 映射模式中，所有类型都分别映射到各自的表。 仅属于某个基类型或派生类型的属性存储在映射到该类型的一个表中。 映射到派生类型的表还存储将派生表与基表联接的外键。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Blog&gt;().ToTable(<span class="string">&quot;Blogs&quot;</span>);</span><br><span class="line">modelBuilder.Entity&lt;RssBlog&gt;().ToTable(<span class="string">&quot;RssBlogs&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>ToTable可以针对每个根实体类型调用 ，而不是对每个实体类型调用 modelBuilder.Entity<Blog>().UseTptMappingStrategy() ，并且表名称将由 EF 生成。</Blog></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [Blogs] (</span><br><span class="line">    [BlogId] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">IDENTITY</span>,</span><br><span class="line">    [Url] nvarchar(max) <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_Blogs] <span class="keyword">PRIMARY</span> KEY ([BlogId])</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [RssBlogs] (</span><br><span class="line">    [BlogId] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    [RssUrl] nvarchar(max) <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_RssBlogs] <span class="keyword">PRIMARY</span> KEY ([BlogId]),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [FK_RssBlogs_Blogs_BlogId] <span class="keyword">FOREIGN</span> KEY ([BlogId]) <span class="keyword">REFERENCES</span> [Blogs] ([BlogId]) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在许多情况下，与 TPH 相比，TPT 性能较差。 有关详细信息，请参阅性能文档。</p>
<h2 id="每个具体表类型-TPC"><a href="#每个具体表类型-TPC" class="headerlink" title="每个具体表类型(TPC)"></a>每个具体表类型(TPC)</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Blog&gt;().UseTpcMappingStrategy()</span><br><span class="line">    .ToTable(<span class="string">&quot;Blogs&quot;</span>);</span><br><span class="line">modelBuilder.Entity&lt;RssBlog&gt;()</span><br><span class="line">    .ToTable(<span class="string">&quot;RssBlogs&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>ToTable将按约定生成表名称，而不是在每个实体类型上调用 ，而只需在每个根实体类型上调用 modelBuilder.Entity<Blog>().UseTpcMappingStrategy() 。</Blog></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [Blogs] (</span><br><span class="line">    [BlogId] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> (NEXT <span class="keyword">VALUE</span> <span class="keyword">FOR</span> [BlogSequence]),</span><br><span class="line">    [Url] nvarchar(max) <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_Blogs] <span class="keyword">PRIMARY</span> KEY ([BlogId])</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [RssBlogs] (</span><br><span class="line">    [BlogId] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> (NEXT <span class="keyword">VALUE</span> <span class="keyword">FOR</span> [BlogSequence]),</span><br><span class="line">    [Url] nvarchar(max) <span class="keyword">NULL</span>,</span><br><span class="line">    [RssUrl] nvarchar(max) <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_RssBlogs] <span class="keyword">PRIMARY</span> KEY ([BlogId])</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="TPC-数据库架构"><a href="#TPC-数据库架构" class="headerlink" title="TPC 数据库架构"></a>TPC 数据库架构</h2><p>TPC 策略类似于 TPT 策略，只是为层次结构中的每个 具体 类型创建不同的表，但 不会 为 抽象 类型创建表，因此名称为“table-per-concrete-type”。 与 TPT 一样，表本身指示保存的对象的类型。 但是，与 TPT 映射不同，每个表都包含具体类型及其基类型中每个属性的列。 TPC 数据库架构非规范化。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Animal</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">string</span> Species &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Food? Food &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Pet</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Pet</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>? Vet &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ICollection&lt;Human&gt; Humans &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> List&lt;Human&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FarmAnimal</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FarmAnimal</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> species</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Species = species;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Species &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Precision(18, 2)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Value &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">        =&gt; <span class="string">$&quot;Farm animal &#x27;<span class="subst">&#123;Name&#125;</span>&#x27; (<span class="subst">&#123;Species&#125;</span>/<span class="subst">&#123;Id&#125;</span>) worth <span class="subst">&#123;Value:C&#125;</span> eats <span class="subst">&#123;Food?.ToString() ?? <span class="string">&quot;&lt;Unknown&gt;&quot;</span>&#125;</span>&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> educationLevel</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        EducationLevel = educationLevel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> EducationLevel &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Species =&gt; <span class="string">&quot;Felis catus&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">        =&gt; <span class="string">$&quot;Cat &#x27;<span class="subst">&#123;Name&#125;</span>&#x27; (<span class="subst">&#123;Species&#125;</span>/<span class="subst">&#123;Id&#125;</span>) with education &#x27;<span class="subst">&#123;EducationLevel&#125;</span>&#x27; eats <span class="subst">&#123;Food?.ToString() ?? <span class="string">&quot;&lt;Unknown&gt;&quot;</span>&#125;</span>&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> favoriteToy</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        FavoriteToy = favoriteToy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> FavoriteToy &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Species =&gt; <span class="string">&quot;Canis familiaris&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">        =&gt; <span class="string">$&quot;Dog &#x27;<span class="subst">&#123;Name&#125;</span>&#x27; (<span class="subst">&#123;Species&#125;</span>/<span class="subst">&#123;Id&#125;</span>) with favorite toy &#x27;<span class="subst">&#123;FavoriteToy&#125;</span>&#x27; eats <span class="subst">&#123;Food?.ToString() ?? <span class="string">&quot;&lt;Unknown&gt;&quot;</span>&#125;</span>&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Human</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Human</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Species =&gt; <span class="string">&quot;Homo sapiens&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Animal? FavoriteAnimal &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> ICollection&lt;Pet&gt; Pets &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> List&lt;Pet&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">        =&gt; <span class="string">$&quot;Human &#x27;<span class="subst">&#123;Name&#125;</span>&#x27; (<span class="subst">&#123;Species&#125;</span>/<span class="subst">&#123;Id&#125;</span>) with favorite animal &#x27;<span class="subst">&#123;FavoriteAnimal?.Name ?? <span class="string">&quot;&lt;Unknown&gt;&quot;</span>&#125;</span>&#x27;&quot;</span> +</span><br><span class="line">           <span class="string">$&quot; eats <span class="subst">&#123;Food?.ToString() ?? <span class="string">&quot;&lt;Unknown&gt;&quot;</span>&#125;</span>&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为此层次结构创建的表为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [Cats] (</span><br><span class="line">    [Id] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> (NEXT <span class="keyword">VALUE</span> <span class="keyword">FOR</span> [AnimalSequence]),</span><br><span class="line">    [Name] nvarchar(max) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    [FoodId] uniqueidentifier <span class="keyword">NULL</span>,</span><br><span class="line">    [Vet] nvarchar(max) <span class="keyword">NULL</span>,</span><br><span class="line">    [EducationLevel] nvarchar(max) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_Cats] <span class="keyword">PRIMARY</span> KEY ([Id]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [Dogs] (</span><br><span class="line">    [Id] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> (NEXT <span class="keyword">VALUE</span> <span class="keyword">FOR</span> [AnimalSequence]),</span><br><span class="line">    [Name] nvarchar(max) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    [FoodId] uniqueidentifier <span class="keyword">NULL</span>,</span><br><span class="line">    [Vet] nvarchar(max) <span class="keyword">NULL</span>,</span><br><span class="line">    [FavoriteToy] nvarchar(max) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_Dogs] <span class="keyword">PRIMARY</span> KEY ([Id]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [FarmAnimals] (</span><br><span class="line">    [Id] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> (NEXT <span class="keyword">VALUE</span> <span class="keyword">FOR</span> [AnimalSequence]),</span><br><span class="line">    [Name] nvarchar(max) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    [FoodId] uniqueidentifier <span class="keyword">NULL</span>,</span><br><span class="line">    [<span class="keyword">Value</span>] <span class="type">decimal</span>(<span class="number">18</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    [Species] nvarchar(max) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_FarmAnimals] <span class="keyword">PRIMARY</span> KEY ([Id]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [Humans] (</span><br><span class="line">    [Id] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> (NEXT <span class="keyword">VALUE</span> <span class="keyword">FOR</span> [AnimalSequence]),</span><br><span class="line">    [Name] nvarchar(max) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    [FoodId] uniqueidentifier <span class="keyword">NULL</span>,</span><br><span class="line">    [FavoriteAnimalId] <span class="type">int</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_Humans] <span class="keyword">PRIMARY</span> KEY ([Id]));</span><br></pre></td></tr></table></figure>
<p>请注意：</p>
<p>没有 用于 Animal 或 Pet 类型的表，因为这些表位于 abstract 对象模型中。 请记住，C# 不允许抽象类型的实例，因此不存在将抽象类型实例保存到数据库的情况。</p>
<p>对于每个具体类型，将重复基类型中的属性映射。 例如，每个表都有一列 Name ，Cats 和 Dogs 都有一列 Vet 。</p>
<h2 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h2><p>选择的继承映射策略会对生成和管理主键值的方式产生影响。 TPH 中的键很简单，因为每个实体实例都由单个表中的一行表示。 可以使用任何类型的键值生成，并且不需要其他约束。</p>
<p>对于 TPT 策略，表中始终有一行映射到层次结构的基类型。 可以在此行上使用任何类型的键生成，其他表的键使用外键约束链接到此表。</p>
<p>对于 TPC 来说，事情会稍微复杂一些。 首先，请务必了解 EF Core 要求层次结构中的所有实体都具有唯一的键值，即使实体具有不同的类型。 例如，使用我们的示例模型，狗不能具有与 Cat 相同的 Id 键值。 其次，与 TPT 不同，没有共同表可以充当键值所在的单个位置，并且可以生成键值。 这意味着无法使用简单 Identity 列。</p>
<p>对于支持序列的数据库，可以使用每个表的默认约束中引用的单个序列来生成键值。 这是上面所示的 TPC 表中使用的策略，其中每个表具有以下项：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Id] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> (NEXT <span class="keyword">VALUE</span> <span class="keyword">FOR</span> [AnimalSequence])</span><br></pre></td></tr></table></figure>
<p>AnimalSequence 是 EF Core 创建的数据库序列。 将 EF Core 数据库提供程序用于SQL Server时，默认将此策略用于 TPC 层次结构。 支持序列的其他数据库的数据库提供程序应具有类似的默认值。 使用序列的其他密钥生成策略（如 Hi-Lo 模式）也可用于 TPC。</p>
<p>虽然标准标识列不适用于 TPC，但如果每个表都配置了适当的种子和增量，则可以使用标识列，以便为每个表生成的值永远不会发生冲突。 例如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Cat&gt;().ToTable(<span class="string">&quot;Cats&quot;</span>, tb =&gt; tb.Property(e =&gt; e.Id).UseIdentityColumn(<span class="number">1</span>, <span class="number">4</span>));</span><br><span class="line">modelBuilder.Entity&lt;Dog&gt;().ToTable(<span class="string">&quot;Dogs&quot;</span>, tb =&gt; tb.Property(e =&gt; e.Id).UseIdentityColumn(<span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line">modelBuilder.Entity&lt;FarmAnimal&gt;().ToTable(<span class="string">&quot;FarmAnimals&quot;</span>, tb =&gt; tb.Property(e =&gt; e.Id).UseIdentityColumn(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">modelBuilder.Entity&lt;Human&gt;().ToTable(<span class="string">&quot;Humans&quot;</span>, tb =&gt; tb.Property(e =&gt; e.Id).UseIdentityColumn(<span class="number">4</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><p>TPC 映射策略创建非规范化的 SQL 架构 - 这是一些数据库纯粹主义者反对它的原因之一。 例如，请考虑外键列 FavoriteAnimalId。 此列中的值必须与某些动物的主键值匹配。 使用 TPH 或 TPT 时，可以使用简单的 FK 约束在数据库中强制实施此操作。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONSTRAINT [FK_Animals_Animals_FavoriteAnimalId] <span class="function">FOREIGN <span class="title">KEY</span> (<span class="params">[FavoriteAnimalId]</span>) REFERENCES [Animals] (<span class="params">[Id]</span>)</span></span><br></pre></td></tr></table></figure>
<p>但是，使用 TPC 时，任何给定动物的主键都存储在对应于该动物的具体类型的表中。 例如，猫的主键存储在 Cats.Id 列中，而狗的主键存储在 Dogs.Id 列中，依此而行。 这意味着无法为此关系创建 FK 约束。</p>
<p>实际上，只要应用程序不尝试插入无效数据，就不是问题。 例如，如果所有数据都由 EF Core 插入并使用导航来关联实体，则保证 FK 列将始终保持有效的 PK 值。</p>
<h2 id="摘要和指南"><a href="#摘要和指南" class="headerlink" title="摘要和指南"></a>摘要和指南</h2><p>总之，TPH 通常适用于大多数应用程序，并且对于各种方案都是很好的默认值，因此，如果不需要 TPC，请不要增加 TPC 的复杂性。 具体而言，如果代码将主要查询许多类型的实体（例如针对基类型编写查询），则倾向于使用 TPH 和 TPC。</p>
<p>话亦然，当代码主要查询单叶类型的实体，并且基准显示与 TPH 相比，TPC 也是一个很好的映射策略。</p>
<p>仅当受外部因素限制时，才使用 TPT。</p>
<h1 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h1><p>序列在数据库中生成唯一的顺序数值。 序列不与特定表关联，可以设置多个表以从同一序列提取值。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>可以在模型中设置序列，然后使用它为属性生成值：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.HasSequence&lt;<span class="built_in">int</span>&gt;(<span class="string">&quot;OrderNumbers&quot;</span>);</span><br><span class="line"></span><br><span class="line">    modelBuilder.Entity&lt;Order&gt;()</span><br><span class="line">        .Property(o =&gt; o.OrderNo)</span><br><span class="line">        .HasDefaultValueSql(<span class="string">&quot;NEXT VALUE FOR OrderNumbers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，从序列生成值的特定SQL是特定于数据库的；上面的示例适用于 SQL Server 但在其他数据库上将失败。 有关详细信息，请查阅数据库的文档。</p>
<h2 id="配置序列设置"><a href="#配置序列设置" class="headerlink" title="配置序列设置"></a>配置序列设置</h2><p>还可以配置序列的其他方面，例如其架构、起始值、增量等：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.HasSequence&lt;<span class="built_in">int</span>&gt;(<span class="string">&quot;OrderNumbers&quot;</span>, schema: <span class="string">&quot;shared&quot;</span>)</span><br><span class="line">        .StartsAt(<span class="number">1000</span>)</span><br><span class="line">        .IncrementsBy(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
