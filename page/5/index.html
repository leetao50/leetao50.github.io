<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"leetao50.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
<meta property="og:type" content="website">
<meta property="og:title" content="InfoPool">
<meta property="og:url" content="https://leetao50.github.io/page/5/index.html">
<meta property="og:site_name" content="InfoPool">
<meta property="og:description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
<meta property="og:locale" content="zh_CN">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://leetao50.github.io/page/5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>InfoPool</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">InfoPool</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">私人信息记录</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">记录信息来源网络，内容只为方便查找，非公开信息，非请勿入</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">65</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/03/23/angular/%E6%8C%87%E4%BB%A4-%E6%A8%A1%E6%9D%BF-%E7%BB%84%E4%BB%B6-%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8-%E6%8E%A2%E7%B4%A2Angular-DOM%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/23/angular/%E6%8C%87%E4%BB%A4-%E6%A8%A1%E6%9D%BF-%E7%BB%84%E4%BB%B6-%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8-%E6%8E%A2%E7%B4%A2Angular-DOM%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">指令 模板 组件 综合应用 探索Angular DOM操作</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-23 11:43:41" itemprop="dateCreated datePublished" datetime="2023-03-23T11:43:41+08:00">2023-03-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-27 16:53:24" itemprop="dateModified" datetime="2023-03-27T16:53:24+08:00">2023-03-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>文章原出处:<br><a target="_blank" rel="noopener" href="https://blog.angularindepth.com/exploring-angular-dom-abstractions-80b3ebcfc02">Exploring Angular DOM manipulation techniques using ViewContainerRef</a></p>
<p>翻译原文：<a target="_blank" rel="noopener" href="https://github.com/giscafer/giscafer.github.io/issues/19">使用 ViewContainerRef 探索Angular DOM操作 · Issue #19 · giscafer&#x2F;giscafer.github.io</a></p>
<p>Angular 版本运行在不同的平台上——在浏览器上，在移动平台上，或者在 web worker 中。因此，需要在平台特定API 和框架接口之间进行抽象级别的抽象。从 Angular 来看，这些抽象的形式有以下的参考类型: ElementRef, TemplateRef, ViewRef, ComponentRef 和 ViewContainerRef。在本文中，我们将详细介绍每个引用类型，并展示如何使用它们来操作DOM。</p>
<h1 id="ViewChild"><a href="#ViewChild" class="headerlink" title="@ViewChild"></a>@ViewChild</h1><p>在探索 DOM 抽象层之前，先了解下如何在组件&#x2F;指令中访问它们。Angular 提供了一种叫做 DOM querys 的技术，它们以 @ViewChild 和 @ViewChildren 装饰器（decorators）的形式出现。两者功能类似，唯一区别是 @ViewChild 返回单个引用，@ViewChildren 返回由 QueryList 对象包装好的多个引用。本文示例中主要以 ViewChild 装饰器为例，后面描述时将省略 @ 符号。</p>
<p>通常这些装饰器与模板引用变量（template reference variable）配合使用，模板引用变量可以理解为 DOM 元素的引用标识，类似于 html 元素的 id 属性。你可以使用模板引用（template reference）来标记一个 DOM 元素（译者注：下面示例中的#tref），并在组件&#x2F;指令中使用 ViewChild 装饰器查询到它，比如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    <span class="attr">selector</span>: <span class="string">&#x27;sample&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;span #tref&gt;I am span&lt;/span&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">SampleComponent</span> <span class="keyword">implements</span> <span class="title class_">AfterViewInit</span> &#123;</span><br><span class="line">    <span class="meta">@ViewChild</span>(<span class="string">&quot;tref&quot;</span>, &#123;<span class="attr">read</span>: <span class="title class_">ElementRef</span>&#125;) <span class="attr">tref</span>: <span class="title class_">ElementRef</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">ngAfterViewInit</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// outputs `I am span`</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">tref</span>.<span class="property">nativeElement</span>.<span class="property">textContent</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ViewChild 装饰器基本语法是：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ViewChild</span>([reference <span class="keyword">from</span> template], &#123;<span class="attr">read</span>: [reference <span class="keyword">type</span>]&#125;);</span><br></pre></td></tr></table></figure>
<p>上例中你可以看到，我把 tref 作为模板引用名称，并将 ElementRef 与该元素联系起来。</p>
<p>第二个参数 read 是可选的，因为 Angular 会根据 DOM 元素的类型推断出该引用类型。例如，如果它（#tref）挂载的是类似 span 的简单 html 元素，Angular 推断为 ElementRef 类型；</p>
<p>如果它挂载的是 template 元素，Angular 推断为 TemplateRef 类型。</p>
<p>一些引用类型如 ViewContainerRef 就不可以被 Angular 推断出来，所以必须在 read 参数中显式声明。其他的如 ViewRef 不可以挂载在 DOM 元素中，所以必须手动在构造函数中编码构造出来。</p>
<p>现在，让我们看看应该如何获取这些引用，一起去探索吧。</p>
<h1 id="ElementRef"><a href="#ElementRef" class="headerlink" title="ElementRef"></a>ElementRef</h1><p>这是最基本的抽象类，如果你查看它的类结构，你会发现它仅仅包含与原生元素交互的方法，这对访问原生 DOM 元素很有用，比如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// outputs `I am span`</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">tref</span>.<span class="property">nativeElement</span>.<span class="property">textContent</span>);</span><br></pre></td></tr></table></figure>
<p>然而，Angular 团队不鼓励这种写法，不仅因为这种方式会存在安全风险，而且还会让你的程序与渲染层（rendering layers）紧耦合，这样就很难实现在多平台运行相同的应用程序。我认为这个问题并不是使用 nativeElement 导致的，而是使用特定的 DOM API 造成的，例如使用了 textContent。但是后文你会看到，Angular 实现了操作 DOM 的整体思路模型，这样将不用必须调用平台指定的低层次抽象的 API，如textContent。</p>
<blockquote>
<p>使用 ViewChild 装饰器可以返回任何 DOM 元素对应的 ElementRef，但是由于组件挂载在自定义 DOM 元素中;指令也应用在 DOM 元素上，所以组件和指令都可以通过 DI（依赖注入）获取宿主元素的 ElementRef 对象。</p>
</blockquote>
<p>比如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    <span class="attr">selector</span>: <span class="string">&#x27;sample&#x27;</span>,</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">SampleComponent</span>&#123;</span><br><span class="line">      <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span>       hostElement:ElementRef</span>) &#123;</span><br><span class="line">          <span class="comment">//outputs &lt;sample&gt;...&lt;/sample&gt;</span></span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">hostElement</span>.<span class="property">nativeElement</span>.<span class="property">outerHTML</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>所以组件通过 DI（Dependency Injection）可以访问到它的宿主元素，但 ViewChild 装饰器经常被用来获取模板视图中的 DOM 元素。然而指令却相反，因为指令没有视图模板，所以主要用来获取挂载指令的宿主元素。</p>
<h1 id="TemplateRef"><a href="#TemplateRef" class="headerlink" title="TemplateRef"></a>TemplateRef</h1><p>通过 template 标签，浏览器可以解析这段 html 代码，并创建对应的 DOM 树，但不会渲染它，该 DOM 树可以通过 content 属性访问：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> tpl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#tpl&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> container = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.insert-after-me&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">insertAfter</span>(container, tpl.<span class="property">content</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;insert-after-me&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ng-template</span> <span class="attr">id</span>=<span class="string">&quot;tpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>I am span in template<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ng-template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Angular 拥抱了标准，使用 TemplateRef 类来操作 template 元素，看看它是如何使用的（译者注：ng-template 是 Angular 提供的类似于 template 原生 html 标签）：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    <span class="attr">selector</span>: <span class="string">&#x27;sample&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;ng-template #tpl&gt;</span></span><br><span class="line"><span class="string">            &lt;span&gt;I am span in template&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/ng-template&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">SampleComponent</span> <span class="keyword">implements</span> <span class="title class_">AfterViewInit</span> &#123;</span><br><span class="line">    <span class="meta">@ViewChild</span>(<span class="string">&quot;tpl&quot;</span>) <span class="attr">tpl</span>: <span class="title class_">TemplateRef</span>&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">ngAfterViewInit</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> elementRef = <span class="variable language_">this</span>.<span class="property">tpl</span>.<span class="property">elementRef</span>;</span><br><span class="line">        <span class="comment">// outputs `template bindings=&#123;&#125;`</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(elementRef.<span class="property">nativeElement</span>.<span class="property">textContent</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Angular 框架从 DOM 中移除 template 元素，并在其位置插入注释，这是渲染后的样子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sample</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--template bindings=&#123;&#125;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sample</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>TemplateRef 是一个结构简单的抽象类，它的 elementRef 属性是对其宿主元素的引用，它还有一个 createEmbeddedView 方法。createEmbeddedView 方法非常有用，因为它可以创建一个视图（view）并返回该视图的引用对象 ViewRef。</p>
<h1 id="ViewRef"><a href="#ViewRef" class="headerlink" title="ViewRef"></a>ViewRef</h1><p>该抽象类型表示一个 Angular 视图（View），在 Angular 世界里，视图（View）是构建应用中 UI 的基础单元。它是可以同时创建与销毁的最小元素组合。Angular 鼓励开发者把 UI 作为一堆视图（View）的组合，而不仅仅是 html 标签组成的树。</p>
<p><em><strong>Angular 支持两种视图类型：</strong></em></p>
<ul>
<li>内嵌视图（Embedded View），与 Template 关联</li>
<li>宿主视图（Host View），与 Component 关联<br>创建内嵌视图</li>
</ul>
<p>模板仅仅是视图的蓝图，可以通过之前提到的 createEmbeddedView 方法创建视图，比如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">ngAfterViewInit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> view = <span class="variable language_">this</span>.<span class="property">tpl</span>.<span class="title function_">createEmbeddedView</span>(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建宿主视图"><a href="#创建宿主视图" class="headerlink" title="创建宿主视图"></a>创建宿主视图</h2><p>宿主视图是在组件动态实例化时创建的，一个动态组件（dynamic component）可以通过 ComponentFactoryResolver 创建：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> injector: Injector,</span></span><br><span class="line"><span class="params">            <span class="keyword">private</span> r: ComponentFactoryResolver</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> factory = <span class="variable language_">this</span>.<span class="property">r</span>.<span class="title function_">resolveComponentFactory</span>(<span class="title class_">ColorComponent</span>);</span><br><span class="line">    <span class="keyword">let</span> componentRef = factory.<span class="title function_">create</span>(injector);</span><br><span class="line">    <span class="keyword">let</span> view = componentRef.<span class="property">hostView</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Angular 中，每个组件都绑定着一个指定的注入器（Injector）实例，所以创建 ColorComponent 组件时传入当前组件（即 SampleComponent）的注入器。另外，别忘了，动态创建的组件，需要在 ngModule 中或者宿主组件中增加 EntryComponents 配置。</p>
<p>现在，我们已经看到内嵌视图和宿主视图是如何被创建的，一旦视图被创建，它就可以使用 ViewContainer 插入 DOM 树中。下文主要探索这个功能。</p>
<h1 id="ViewContainerRef"><a href="#ViewContainerRef" class="headerlink" title="ViewContainerRef"></a>ViewContainerRef</h1><p>视图容器可以挂载一个或多个视图。</p>
<p>首先需要说的是，任何 DOM 元素都可以作为视图容器，然而有趣的是，对于绑定 ViewContainer 的 DOM 元素，Angular 不会把视图插入该元素的内部，而是追加到该元素后面，这类似于 router-outlet 中插入组件的方式。</p>
<p>通常，比较好的方式是把 ViewContainer 绑定在 ng-container 元素上，因为 ng-container 元素会被渲染为注释，从而不会在 DOM 中引入多余的 html 元素。下面示例描述在组建模板中如何创建 ViewContainer：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    <span class="attr">selector</span>: <span class="string">&#x27;sample&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;span&gt;I am first span&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;ng-container #vc&gt;&lt;/ng-container&gt;</span></span><br><span class="line"><span class="string">        &lt;span&gt;I am last span&lt;/span&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">SampleComponent</span> <span class="keyword">implements</span> <span class="title class_">AfterViewInit</span> &#123;</span><br><span class="line">    <span class="meta">@ViewChild</span>(<span class="string">&quot;vc&quot;</span>, &#123;<span class="attr">read</span>: <span class="title class_">ViewContainerRef</span>&#125;) <span class="attr">vc</span>: <span class="title class_">ViewContainerRef</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">ngAfterViewInit</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// outputs `template bindings=&#123;&#125;`</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">vc</span>.<span class="property">element</span>.<span class="property">nativeElement</span>.<span class="property">textContent</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如同其他 DOM 抽象类一样，ViewContainer 绑定到特殊的 DOM 元素，并可以通过 element 访问到。例如上例中，它绑定到 ng-container 元素上，并且渲染为 HTML 注释，所以输出会是 template bindings&#x3D;{}。</p>
<h2 id="操作视图"><a href="#操作视图" class="headerlink" title="操作视图"></a>操作视图</h2><p>ViewContainer 提供了一些操作视图 API：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ViewContainerRef</span> &#123;</span><br><span class="line">    ...m</span><br><span class="line">    <span class="title function_">clear</span>() : <span class="built_in">void</span></span><br><span class="line">    <span class="title function_">insert</span>(<span class="attr">viewRef</span>: <span class="title class_">ViewRef</span>, index?: <span class="built_in">number</span>) : <span class="title class_">ViewRef</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="attr">index</span>: <span class="built_in">number</span>) : <span class="title class_">ViewRef</span></span><br><span class="line">    <span class="title function_">indexOf</span>(<span class="attr">viewRef</span>: <span class="title class_">ViewRef</span>) : <span class="built_in">number</span></span><br><span class="line">    <span class="title function_">detach</span>(index?: <span class="built_in">number</span>) : <span class="title class_">ViewRef</span></span><br><span class="line">    <span class="title function_">move</span>(<span class="attr">viewRef</span>: <span class="title class_">ViewRef</span>, <span class="attr">currentIndex</span>: <span class="built_in">number</span>) : <span class="title class_">ViewRef</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上文我们已经知道内嵌视图和宿主视图的创建方式，当创建视图后，就可以通过 insert 方法插入 DOM 中。下面示例描述如何通过 ng-template 创建内嵌视图，并在 ng-container 中插入该视图。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    <span class="attr">selector</span>: <span class="string">&#x27;sample&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;span&gt;I am first span&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;ng-container #vc&gt;&lt;/ng-container&gt;</span></span><br><span class="line"><span class="string">        &lt;span&gt;I am last span&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;ng-template #tpl&gt;</span></span><br><span class="line"><span class="string">            &lt;span&gt;I am span in template&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/ng-template&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">SampleComponent</span> <span class="keyword">implements</span> <span class="title class_">AfterViewInit</span> &#123;</span><br><span class="line">    <span class="meta">@ViewChild</span>(<span class="string">&quot;vc&quot;</span>, &#123;<span class="attr">read</span>: <span class="title class_">ViewContainerRef</span>&#125;) <span class="attr">vc</span>: <span class="title class_">ViewContainerRef</span>;</span><br><span class="line">    <span class="meta">@ViewChild</span>(<span class="string">&quot;tpl&quot;</span>) <span class="attr">tpl</span>: <span class="title class_">TemplateRef</span>&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">ngAfterViewInit</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> view = <span class="variable language_">this</span>.<span class="property">tpl</span>.<span class="title function_">createEmbeddedView</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">vc</span>.<span class="title function_">insert</span>(view);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的实现，最后的 html 看起来是：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sample</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>I am first span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--template bindings=&#123;&#125;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>I am span in template<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>I am last span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--template bindings=&#123;&#125;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sample</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（译者注：从上文中知道是追加到 ng-container 后面，而不是插入到该 DOM 元素内部，因为在 Angular 中 ng-container 元素不会生成真实的 DOM 元素，所以在结构中不会发现这个 “追加” 的痕迹。如果把 ng-container 替换成其他元素，则可以明显地看到视图是追加在 viewContainer 之后的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">_ngcontent-c4</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">_ngcontent-c4</span>&gt;</span>I am span in template<span class="tag">&lt;/<span class="name">span</span>&gt;</span>）</span><br></pre></td></tr></table></figure>

<p>此外，可以通过 detach 方法从 DOM 移除视图，其他的方法可以很容易通过方法名知道其含义，如通过 index 方法获得对应索引的视图引用，move 方法移动视图位置次序，或者使用 remove 方法从移除所有的视图。</p>
<h1 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h1><p>ViewContainer 也提供了手动创建视图 API ：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ViewContainerRef</span> &#123;</span><br><span class="line">    <span class="attr">element</span>: <span class="title class_">ElementRef</span></span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">createComponent</span>(componentFactory...): <span class="title class_">ComponentRef</span>&lt;C&gt;</span><br><span class="line">    <span class="title function_">createEmbeddedView</span>(templateRef...): <span class="title class_">EmbeddedViewRef</span>&lt;C&gt;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面两个方法是对上文中我们手动操作的封装，可以传入模板引用对象或组件工厂对象来创建视图，并将该视图插入视图容器中特定位置。</p>
<h1 id="ngTemplateOutlet-和-ngComponentOutlet"><a href="#ngTemplateOutlet-和-ngComponentOutlet" class="headerlink" title="ngTemplateOutlet 和 ngComponentOutlet"></a>ngTemplateOutlet 和 ngComponentOutlet</h1><p>尽管知道 Angular 操作 DOM 的内部机制是好事，但是如果存在某种便捷的方式就更好了。Angular 提供了两种快捷指令：ngTemplateOutlet 和 ngComponentOutlet。写作本文时这两个指令都是实验性的，ngComponentOutlet 也将在Angular4.0 版本中可用。如果你读完了上文，就很容易知道这两个指令是做什么的。</p>
<h2 id="ngTemplateOutlet"><a href="#ngTemplateOutlet" class="headerlink" title="ngTemplateOutlet"></a>ngTemplateOutlet</h2><p>该指令会把 DOM 元素标记为 ViewContainer，并插入由模板创建的内嵌视图，从而不需要在组件类中显式创建该内嵌视图。这意味着，上面实例中创建内嵌视图并插入 #vc DOM 元素的代码就可以重写为：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    <span class="attr">selector</span>: <span class="string">&#x27;sample&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;span&gt;I am first span&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;ng-container [ngTemplateOutlet]=&quot;tpl&quot;&gt;&lt;/ng-container&gt;</span></span><br><span class="line"><span class="string">        &lt;span&gt;I am last span&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;ng-template #tpl&gt;</span></span><br><span class="line"><span class="string">            &lt;span&gt;I am span in template&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/ng-template&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">SampleComponent</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>从上面示例看到我们不需要在组件类中写任何实例化视图的代码，非常方便。</p>
<h2 id="ngComponentOutlet"><a href="#ngComponentOutlet" class="headerlink" title="ngComponentOutlet"></a>ngComponentOutlet</h2><p>这个指令与 ngTemplateOutlet 很相似，区别是 ngComponentOutlet 创建的是由组件实例化生成的宿主视图，不是内嵌视图。你可以这么使用：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ng-container</span> *<span class="attr">ngComponentOutlet</span>=<span class="string">&quot;ColorComponent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ng-container</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看似有很多新知识需要消化啊，但实际上 Angular 通过视图操作 DOM 的思路模型是很清晰和连贯的。你可以使用 ViewChild 查询模板引用变量来获得 Angular DOM 元素的引用对象；DOM 元素的最简单封装是 ElementRef；而对于模板，你可以使用 TemplateRef 来创建内嵌视图；而对于组件，可以使用 ComponentRef 来创建宿主视图，同时又可以使用 ComponentFactoryResolver 创建 ComponentRef。这两个创建的视图（即内嵌视图和宿主视图）又会被 ViewContainerRef 管理。最后，Angular 又提供了两个快捷指令自动化这个过程：ngTemplateOutlet 指令使用模板创建内嵌视图；ngComponentOutlet 使用动态组件创建宿主视图。</p>
<h1 id="ViewChild与ContentChild的联系和区别"><a href="#ViewChild与ContentChild的联系和区别" class="headerlink" title="ViewChild与ContentChild的联系和区别"></a>ViewChild与ContentChild的联系和区别</h1><p>ViewChild和ContentChild其实都是从子组件中获取内容的装饰器</p>
<p>它们本质的区别其实就只是在于方法调用的时机以及获取内容的地方：   </p>
<ol>
<li>时机：</li>
</ol>
<p>ViewChild在ngAfterViewInit的回调中调用</p>
<p>ContentChild在ngAfterContentInit的回调用调用            </p>
<ol start="2">
<li>获取内容的地方</li>
</ol>
<p>ViewChild从模板中获取内容</p>
<p>ContentChild需要从ng-content中投影的内容中获取内容，也就是没有使用ng-content投影就无法获取内容</p>
<p>在 ng-template 标签中，我们可以访问与外部模板中相同的上下文变量，例如变量 lesson。这是因为所有 ng-template 实例都可以访问它们所嵌入的同一个上下文。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ng-container</span> *<span class="attr">ngIf</span>=<span class="string">&quot;lessons&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;lesson&quot;</span> *<span class="attr">ngFor</span>=<span class="string">&quot;let lesson of lessons&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;lesson-detail&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ng-container</span> *<span class="attr">ngIf</span>=<span class="string">&quot;lesson else empty&quot;</span>&gt;</span> &#123;&#123;lesson | json&#125;&#125; <span class="tag">&lt;/<span class="name">ng-container</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ng-template</span> #<span class="attr">empty</span>&gt;</span> &#123;&#123;lesson | json&#125;&#125; <span class="tag">&lt;/<span class="name">ng-template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ng-container</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是每个模板也可以定义自己的一组输入变量! 实际上，每个模板都关联了一个上下文对象，该对象包含所有特定于模板的输入变量。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&quot;app-root&quot;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;ng-template #estimateTemplate let-lessonsCounter=&quot;estimate&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;Approximately &#123;&#123; lessonsCounter &#125;&#125; lessons ...&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/ng-template&gt;</span></span><br><span class="line"><span class="string">    &lt;ng-container *ngTemplateOutlet=&quot;estimateTemplate; context: ctx&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;/ng-container&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppComponent</span> &#123;</span><br><span class="line">  totalEstimate = <span class="number">10</span>;</span><br><span class="line">  ctx = &#123; <span class="attr">estimate</span>: <span class="variable language_">this</span>.<span class="property">totalEstimate</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是对这个例子的分析：</p>
<p>与前面的模板不同，这个模板有一个输入变量（它也可以有几个）<br>通过 ng-template 上前缀为 let- 的属性来定义了一个输入变量 lessonsCounter<br>lessonsCounter 变量只能在 ng-template 内部可见<br>该变量的内容由赋给 let-lessonsCounter 属性的表达式 estimate 决定<br>estimate 表达式根据上下文对象 context 求值，并将其与要实例化的模板一起传递给 ngTemplateOutlet<br>上下文对象 context 有一个名为 estimate 的属性，以便在模板中显示该值<br>还可以给 ctx 对象添加其他属性，然后通过 ngTemplateOutlet 的 context 输入到 ng-template，从而可以拿到更多的输入变量<br>最终在屏幕上展示的结果是：</p>
<p>Approximately 10 lessons …<br>这让我们对如何定义和实例化自己的模板有了一个很好的概览。使用这样的方式还可以在 component 中通过模板进行编码，接下来就会介绍。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/03/20/angular/%E6%8C%87%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/20/angular/%E6%8C%87%E4%BB%A4/" class="post-title-link" itemprop="url">指令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-20 17:42:13" itemprop="dateCreated datePublished" datetime="2023-03-20T17:42:13+08:00">2023-03-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-22 17:15:44" itemprop="dateModified" datetime="2023-03-22T17:15:44+08:00">2023-03-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>指令是为 Angular 应用程序中的元素添加额外行为的类。使用 Angular 的内置指令，你可以管理表单、列表、样式以及要让用户看到的任何内容。</p>
<p>Angular 指令的不同类型如下：</p>
<table>
<thead>
<tr>
<th>指令类型</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td>组件</td>
<td>带有模板的指令。这种指令类型是最常见的指令类型。</td>
</tr>
<tr>
<td>属性型指令</td>
<td>更改元素、组件或其他指令的外观或行为的指令。</td>
</tr>
<tr>
<td>结构型指令</td>
<td>通过添加和删除 DOM 元素来更改 DOM 布局。</td>
</tr>
</tbody></table>
<h2 id="内置属性型指令"><a href="#内置属性型指令" class="headerlink" title="内置属性型指令"></a>内置属性型指令</h2><p>属性型指令会监听并修改其它 HTML 元素和组件的行为、Attribute 和 Property。</p>
<table>
<thead>
<tr>
<th>通用指令</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td>NgClass</td>
<td>添加和删除一组 CSS 类。</td>
</tr>
<tr>
<td>NgStyle</td>
<td>添加和删除一组 HTML 样式。</td>
</tr>
<tr>
<td>NgModel</td>
<td>将双向数据绑定添加到 HTML 表单元素。</td>
</tr>
</tbody></table>
<h2 id="内置结构型指令"><a href="#内置结构型指令" class="headerlink" title="内置结构型指令"></a>内置结构型指令</h2><p>结构型指令的职责是 HTML 布局。它们塑造或重塑 DOM 的结构，这通常是通过添加、移除和操纵它们所附加到的宿主元素来实现的。</p>
<table>
<thead>
<tr>
<th>常见的内置结构型指令</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td>NgIf</td>
<td>有条件地从模板创建或销毁子视图。</td>
</tr>
<tr>
<td>NgFor</td>
<td>为列表中的每个条目重复渲染一个节点。</td>
</tr>
<tr>
<td>NgSwitch</td>
<td>一组在备用视图之间切换的指令。</td>
</tr>
</tbody></table>
<h1 id="属性型指令"><a href="#属性型指令" class="headerlink" title="属性型指令"></a>属性型指令</h1><p>使用属性型指令，可以更改 DOM 元素和 Angular 组件的外观或行为。</p>
<h2 id="建立属性型指令"><a href="#建立属性型指令" class="headerlink" title="建立属性型指令"></a>建立属性型指令</h2><ol>
<li><p>要创建指令，请使用 CLI 命令 ng generate directive</p>
<p>CLI 创建 src&#x2F;app&#x2F;highlight.directive.ts 以及相应的测试文件 src&#x2F;app&#x2F;highlight.directive.spec.ts，并在 AppModule 中声明此指令类。<br>CLI 生成默认的 src&#x2F;app&#x2F;highlight.directive.ts，如下所示：</p>
</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> &#123; <span class="title class_">Directive</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="meta">@Directive</span>(&#123;</span><br><span class="line">    <span class="attr">selector</span>: <span class="string">&#x27;[appHighlight]&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">HighlightDirective</span> &#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Directive() 装饰器的配置属性会指定指令的 CSS 属性选择器 [appHighlight]。</p>
<ol start="2">
<li><p>从 @angular&#x2F;core 导入 ElementRef。ElementRef 的 nativeElement 属性会提供对宿主 DOM 元素的直接访问权限。</p>
</li>
<li><p>在指令的 constructor() 中添加 ElementRef 以注入对宿主 DOM 元素的引用，该元素就是 appHighlight 的作用目标。</p>
</li>
<li><p>向 HighlightDirective 类中添加逻辑，将背景设置为黄色。</p>
</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Directive</span>, <span class="title class_">ElementRef</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Directive</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;[appHighlight]&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">HighlightDirective</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> el: ElementRef</span>) &#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">el</span>.<span class="property">nativeElement</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;yellow&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用属性型指令"><a href="#应用属性型指令" class="headerlink" title="应用属性型指令"></a>应用属性型指令</h2><ol>
<li>要使用 HighlightDirective，请将 <p> 元素添加到 HTML 模板中，并以伪指令作为属性。</p></li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">appHighlight</span>&gt;</span>Highlight me!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Angular 会创建 HighlightDirective 类的实例，并将 <code>&lt;p&gt;</code> 元素的引用注入到该指令的构造函数中，它会将 <code>&lt;p&gt;</code> 元素的背景样式设置为黄色。</p>
<h2 id="处理用户事件"><a href="#处理用户事件" class="headerlink" title="处理用户事件"></a>处理用户事件</h2><p>添加两个事件处理程序，它们会在鼠标进入或离开时做出响应，每个事件处理程序都带有 @HostListener() 装饰器。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HostListener</span>(<span class="string">&#x27;mouseenter&#x27;</span>) <span class="title function_">onMouseEnter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">highlight</span>(<span class="string">&#x27;yellow&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HostListener</span>(<span class="string">&#x27;mouseleave&#x27;</span>) <span class="title function_">onMouseLeave</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">highlight</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">highlight</span>(<span class="params">color: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">el</span>.<span class="property">nativeElement</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要订阅本属性型指令宿主 DOM 元素上的事件（在本例中是 <code>&lt;p&gt;</code>），可以使用 @HostListener() 装饰器。</p>
<p>完整的指令如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Directive</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;[appHighlight]&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">HighlightDirective</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> el: ElementRef</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@HostListener</span>(<span class="string">&#x27;mouseenter&#x27;</span>) <span class="title function_">onMouseEnter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">highlight</span>(<span class="string">&#x27;yellow&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@HostListener</span>(<span class="string">&#x27;mouseleave&#x27;</span>) <span class="title function_">onMouseLeave</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">highlight</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">highlight</span>(<span class="params">color: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">el</span>.<span class="property">nativeElement</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当指针悬停在 p 元素上时，背景颜色就会出现；而当指针移出时，背景颜色就会消失。</p>
<h2 id="将值传递给属性型指令"><a href="#将值传递给属性型指令" class="headerlink" title="将值传递给属性型指令"></a>将值传递给属性型指令</h2><p>本节将引导你在应用 HighlightDirective 时设置突出显示颜色。</p>
<ol>
<li>在 highlight.directive.ts 中，从 @angular&#x2F;core 导入 Input。</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Directive</span>, <span class="title class_">ElementRef</span>, <span class="title class_">HostListener</span>, <span class="title class_">Input</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>添加一个 appHighlight 的 @Input() 属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Input</span>() appHighlight = <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>@Input() 装饰器会将元数据添加到此类，以便让该指令的 appHighlight 属性可用于绑定。</p>
</li>
<li><p>在 app.component.ts，将 color 属性添加到 AppComponent。</p>
</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppComponent</span> &#123;</span><br><span class="line">  color = <span class="string">&#x27;yellow&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要同时应用指令和颜色，请通过 appHighlight 指令选择器使用属性绑定，将其设置为 color。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> [<span class="attr">appHighlight</span>]=<span class="string">&quot;color&quot;</span>&gt;</span>Highlight me!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>[appHighlight] 属性绑定执行两项任务：</p>
<p>将突出显示指令应用于 <code>&lt;p&gt;</code> 元素</p>
<p>通过属性绑定设置指令的突出显示颜色</p>
<p>通过用户输入来设置值<br>本节指导你添加单选按钮，将你选择的颜色绑定到 appHighlight 指令。</p>
<p>将标记添加到 app.component.html 以选择颜色，如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>My First Attribute Directive<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Pick a highlight color<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;colors&quot;</span> (<span class="attr">click</span>)=<span class="string">&quot;color=&#x27;lightgreen&#x27;&quot;</span>&gt;</span>Green</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;colors&quot;</span> (<span class="attr">click</span>)=<span class="string">&quot;color=&#x27;yellow&#x27;&quot;</span>&gt;</span>Yellow</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;colors&quot;</span> (<span class="attr">click</span>)=<span class="string">&quot;color=&#x27;cyan&#x27;&quot;</span>&gt;</span>Cyan</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> [<span class="attr">appHighlight</span>]=<span class="string">&quot;color&quot;</span>&gt;</span>Highlight me!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>修改 AppComponent.color，使其没有初始值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppComponent</span> &#123;</span><br><span class="line">  color = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 highlight.directive.ts 中，修改 onMouseEnter 方法，让它首先尝试使用 appHighlight 进行高亮显示，如果 appHighlight 是 undefined，则回退为 red。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HostListener</span>(<span class="string">&#x27;mouseenter&#x27;</span>) <span class="title function_">onMouseEnter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">highlight</span>(<span class="variable language_">this</span>.<span class="property">appHighlight</span> || <span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动本应用的开发服务器，以验证用户可以通过单选按钮选择颜色。</p>
<h2 id="绑定到第二个属性"><a href="#绑定到第二个属性" class="headerlink" title="绑定到第二个属性"></a>绑定到第二个属性</h2><p>本节将指导你配置应用程序，以便开发人员可以设置默认颜色。</p>
<ol>
<li>将第二个 Input() 属性 defaultColor 添加到 HighlightDirective。</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Input</span>() defaultColor = <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>修改指令的 onMouseEnter，使其首先尝试使用 appHighlight 进行突出显示，然后尝试 defaultColor，如果两个属性都 undefined，则变回 red。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HostListener</span>(<span class="string">&#x27;mouseenter&#x27;</span>) <span class="title function_">onMouseEnter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">highlight</span>(<span class="variable language_">this</span>.<span class="property">appHighlight</span> || <span class="variable language_">this</span>.<span class="property">defaultColor</span> || <span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
若要绑定到 AppComponent.color 并回退为默认颜色“紫罗兰（violet）”，请添加以下 HTML。在这里，defaultColor 绑定没有使用方括号 []，因为它是静态的。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> [<span class="attr">appHighlight</span>]=<span class="string">&quot;color&quot;</span> <span class="attr">defaultColor</span>=<span class="string">&quot;violet&quot;</span>&gt;</span></span><br><span class="line">  Highlight me too!</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
与组件一样，你可以将指令的多个属性绑定添加到宿主元素上。</li>
</ol>
<p>如果没有默认颜色（defaultColor）绑定，则默认为红色。当用户选择一种颜色时，所选的颜色将成为突出显示的颜色。</p>
<h1 id="ElementRef"><a href="#ElementRef" class="headerlink" title="ElementRef"></a>ElementRef</h1><p>对视图中某个原生元素的包装器。</p>
<p>ElementRef 的背后是一个可渲染的具体元素。在浏览器中，它通常是一个 DOM 元素。</p>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>组件 (component) 类及其关联的模板 (template)定义了一个视图。 </p>
<p>视图是可显示元素的最小分组单位，它们会被同时创建和销毁。 Angular 在一个或多个指令 (directive) 的控制下渲染视图。</p>
<p>具体实现上，视图由一个与该组件相关的 ViewRef 实例表示。 直属于某个组件的视图叫做宿主视图。 通常会把视图组织成一些视图树（view hierarchies）。</p>
<h2 id="ViewRef"><a href="#ViewRef" class="headerlink" title="ViewRef"></a>ViewRef</h2><p>表示一个 Angular 视图</p>
<h2 id="视图树（View-hierarchy）"><a href="#视图树（View-hierarchy）" class="headerlink" title="视图树（View hierarchy）"></a>视图树（View hierarchy）</h2><p>一棵相关视图的树，它们可以作为一个整体行动。其根视图就是组件的宿主视图。宿主视图可以是内嵌视图树的根，它被收集到了宿主组件上的一个视图容器（ViewContainerRef）中。视图树是 Angular 变更检测的关键部件之一。</p>
<p>视图树和组件树并不是一一对应的。那些嵌入到指定视图树上下文中的视图也可能是其它组件的宿主视图。那些组件可能和宿主组件位于同一个 NgModule 中，也可能属于其它 NgModule。</p>
<h2 id="EmbeddedViewRef"><a href="#EmbeddedViewRef" class="headerlink" title="EmbeddedViewRef"></a>EmbeddedViewRef</h2><p>表示视图容器中的 Angular 视图。嵌入视图可以从在模板中定义它的宿主组件之外的组件中引用，也可以由 TemplateRef 进行独立定义。</p>
<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p>以下模板分为两个单独的 TemplateRef 实例，一个外部实例和一个内部实例。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Count: &#123;&#123;items.length&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> *<span class="attr">ngFor</span>=<span class="string">&quot;let  item of items&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这是外部 TemplateRef ：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Count: &#123;&#123;items.length&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ng-template</span> <span class="attr">ngFor</span> <span class="attr">let-item</span> [<span class="attr">ngForOf</span>]=<span class="string">&quot;items&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ng-template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这是内部的 TemplateRef ：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>外部和内部 TemplateRef 实例按如下方式组装到视图中：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ViewRef: outer-0 --&gt;</span></span><br><span class="line">Count: 2</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ng-template</span> <span class="attr">view-container-ref</span>&gt;</span><span class="tag">&lt;/<span class="name">ng-template</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ViewRef: inner-1 --&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>first<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="comment">&lt;!-- /ViewRef: inner-1 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ViewRef: inner-2 --&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>second<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="comment">&lt;!-- /ViewRef: inner-2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- /ViewRef: outer-0 --&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="TemplateRef"><a href="#TemplateRef" class="headerlink" title="TemplateRef"></a>TemplateRef</h3><p>表示一个内嵌模板，它可用于实例化内嵌的视图。 要想根据模板实例化内嵌的视图，请使用 ViewContainerRef 的 createEmbeddedView() 方法。</p>
<p>通过把一个指令放在 <code>&lt;ng-template&gt;</code> 元素（或一个带 * 前缀的指令）上，可以访问 TemplateRef 的实例。 内嵌视图的 TemplateRef 实例会以 TemplateRef 作为令牌，注入到该指令的构造函数中。</p>
<p>你还可以使用 Query 来找出与某个组件或指令相关的 TemplateRef。</p>
<h2 id="ViewContainerRef"><a href="#ViewContainerRef" class="headerlink" title="ViewContainerRef"></a>ViewContainerRef</h2><p>表示可以将一个或多个视图附着到组件中的容器。</p>
<p>可以包含宿主视图（当用 createComponent() 方法实例化组件时创建）和内嵌视图（当用 createEmbeddedView() 方法实例化 TemplateRef 时创建）。</p>
<p>视图容器的实例还可以包含其它视图容器，以创建层次化视图。</p>
<p>可以在元素上放置注入了 ViewContainerRef 的 Directive 来访问元素的 ViewContainerRef。也可以使用 ViewChild 进行查询。</p>
<h2 id="ViewChild"><a href="#ViewChild" class="headerlink" title="ViewChild"></a>ViewChild</h2><p>属性装饰器，用于配置一个视图查询。 变更检测器会在视图的 DOM 中查找能匹配上该选择器的第一个元素或指令。 如果视图的 DOM 发生了变化，出现了匹配该选择器的新的子节点，该属性就会被更新。</p>
<h1 id="结构型指令"><a href="#结构型指令" class="headerlink" title="结构型指令"></a>结构型指令</h1><h2 id="结构型指令简写形式"><a href="#结构型指令简写形式" class="headerlink" title="结构型指令简写形式"></a>结构型指令简写形式</h2><p>应用结构指令时，它们通常以星号 * 为前缀，例如 *ngIf。本约定是 Angular 解释并转换为更长形式的速记。Angular 会将结构指令前面的星号转换为围绕宿主元素及其后代的 <code>&lt;ng-template&gt;</code>。</p>
<h2 id="创建结构型指令"><a href="#创建结构型指令" class="headerlink" title="创建结构型指令"></a>创建结构型指令</h2><p>本节将指导你创建 UnlessDirective 以及如何设置 condition 值。UnlessDirective 与 NgIf 相反，并且 condition 值可以设置为 true 或 false。NgIf 为 true 时显示模板内容；而 UnlessDirective 在这个条件为 false 时显示内容。</p>
<p>以下是应用于 p 元素的 UnlessDirective 选择器 appUnless 当 condition 为 false，浏览器将显示该句子。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> *<span class="attr">appUnless</span>=<span class="string">&quot;condition&quot;</span>&gt;</span>Show this sentence unless the condition is true.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用 Angular CLI，运行以下命令，其中 unless 是伪指令的名称：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng generate directive unless</span><br></pre></td></tr></table></figure>
<p>Angular 会创建指令类，并指定 CSS 选择器 appUnless，它会在模板中标识指令。</p>
<p>导入 Input、TemplateRef 和 ViewContainerRef。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Directive</span>, <span class="title class_">Input</span>, <span class="title class_">TemplateRef</span>, <span class="title class_">ViewContainerRef</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Directive</span>(&#123; <span class="attr">selector</span>: <span class="string">&#x27;[appUnless]&#x27;</span>&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">UnlessDirective</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在指令的构造函数中将 TemplateRef 和 ViewContainerRef 注入成私有变量。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="keyword">private</span> templateRef: TemplateRef&lt;<span class="built_in">any</span>&gt;,</span></span><br><span class="line"><span class="params">  <span class="keyword">private</span> viewContainer: ViewContainerRef</span>) &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>UnlessDirective 会通过 Angular 生成的 <code>&lt;ng-template&gt;</code> 创建一个嵌入的视图，然后将该视图插入到该指令的原始<code>&lt;p&gt;</code>宿主元素紧后面的视图容器中。</p>
<p>TemplateRef可帮助你获取 <code>&lt;ng-template&gt; </code>的内容，而 ViewContainerRef 可以访问视图容器。</p>
<p>添加一个带 setter 的 @Input() 属性 appUnless。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Input</span>() <span class="keyword">set</span> <span class="title function_">appUnless</span>(<span class="params">condition: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!condition &amp;&amp; !<span class="variable language_">this</span>.<span class="property">hasView</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">viewContainer</span>.<span class="title function_">createEmbeddedView</span>(<span class="variable language_">this</span>.<span class="property">templateRef</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hasView</span> = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition &amp;&amp; <span class="variable language_">this</span>.<span class="property">hasView</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">viewContainer</span>.<span class="title function_">clear</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hasView</span> = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当条件的值更改时，Angular 都会设置 appUnless 属性。</p>
<p>如果条件是假值，并且 Angular 以前尚未创建视图，则此 setter 会导致视图容器从模板创建出嵌入式视图。</p>
<p>如果条件为真值，并且当前正显示着视图，则此 setter 会清除容器，这会导致销毁该视图。</p>
<p>完整的指令如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Directive</span>, <span class="title class_">Input</span>, <span class="title class_">TemplateRef</span>, <span class="title class_">ViewContainerRef</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add the template content to the DOM unless the condition is true.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Directive</span>(&#123; <span class="attr">selector</span>: <span class="string">&#x27;[appUnless]&#x27;</span>&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">UnlessDirective</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> hasView = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> templateRef: TemplateRef&lt;<span class="built_in">any</span>&gt;,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> viewContainer: ViewContainerRef</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Input</span>() <span class="keyword">set</span> <span class="title function_">appUnless</span>(<span class="params">condition: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!condition &amp;&amp; !<span class="variable language_">this</span>.<span class="property">hasView</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">viewContainer</span>.<span class="title function_">createEmbeddedView</span>(<span class="variable language_">this</span>.<span class="property">templateRef</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">hasView</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition &amp;&amp; <span class="variable language_">this</span>.<span class="property">hasView</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">viewContainer</span>.<span class="title function_">clear</span>();</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">hasView</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/03/20/angular/%E6%A8%A1%E6%9D%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/20/angular/%E6%A8%A1%E6%9D%BF/" class="post-title-link" itemprop="url">模板</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-03-20 12:15:32 / 修改时间：17:33:02" itemprop="dateCreated datePublished" datetime="2023-03-20T12:15:32+08:00">2023-03-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在 Angular 中，模板是用户界面 (UI) 片段的蓝图。模板是用 HTML 编写的，可以在模板中使用特殊语法来构建 Angular 的许多特性。</p>
<p>为了消除脚本注入攻击的风险，Angular 不支持模板中使用<br> script 元素。Angular 会忽略 script  标记，并向浏览器控制台输出一条警告。</p>
<h1 id="插值语法"><a href="#插值语法" class="headerlink" title="插值语法"></a>插值语法</h1><p>插值是指将表达式嵌入到被标记的文本中。默认情况下，插值使用双花括号  作为定界符。</p>
<p>在以下示例中，Angular 会求出 title 和 itemImageUrl 属性的值，以显示一些标题文本和图像。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&quot;item&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;itemImageUrl&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="模板语句"><a href="#模板语句" class="headerlink" title="模板语句"></a>模板语句</h1><p>模板语句是可在 HTML 中用于响应用户事件的方法或属性。</p>
<p>在以下示例中，模板语句 deleteHero() 出现在 &#x3D; 号右侧的引号中，(event)&#x3D;”statement”。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> (<span class="attr">click</span>)=<span class="string">&quot;deleteHero()&quot;</span>&gt;</span>Delete hero<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当用户单击 Delete hero 按钮时，Angular 就会调用组件类中 deleteHero() 方法。</p>
<p>可以将模板语句与元素、组件或指令一起使用以响应事件。</p>
<h2 id="语句的上下文"><a href="#语句的上下文" class="headerlink" title="语句的上下文"></a>语句的上下文</h2><p>语句上下文还可以引用模板自身的上下文属性。在下面的示例中，组件的事件处理方法 onSave() 将模板自己的 $event 对象用作参数。在接下来的两行中，deleteHero() 方法接收了模板输入变量 hero 作为参数，而 onSubmit() 接收了模板引用变量 #heroForm 作为参数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> (<span class="attr">click</span>)=<span class="string">&quot;onSave($event)&quot;</span>&gt;</span>Save<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> *<span class="attr">ngFor</span>=<span class="string">&quot;let hero of heroes&quot;</span> (<span class="attr">click</span>)=<span class="string">&quot;deleteHero(hero)&quot;</span>&gt;</span>&#123;&#123;hero.name&#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> #<span class="attr">heroForm</span> (<span class="attr">ngSubmit</span>)=<span class="string">&quot;onSubmit(heroForm)&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，$event 对象、hero 和 #heroForm 的上下文都是其模板。</p>
<p>模板上下文中的名称优先于组件上下文中的名称。前面 deleteHero(hero) 中的 hero 是模板输入变量，而不是组件的 hero 属性。</p>
<blockquote>
<p>模板语句的上下文可以是组件类实例或模板。因此，模板语句无法引用全局名称空间中的任何内容，比如 window 或 document。比如，模板语句不能调用 console.log() 或 Math.max()。</p>
</blockquote>
<h1 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h1><p>在 Angular 模板中，绑定会在从模板创建的一部分 UI（DOM 元素、指令或组件）与模型（模板所属的组件实例）之间创建实时连接。此连接可用于将视图与模型同步、在视图中发生事件或用户操作时通知模型，或两者兼而有之。Angular 的变更检测算法负责保持视图和模型的同步。</p>
<p>模板表达式类似于 JavaScript 表达式。许多 JavaScript 表达式都是合法的模板表达式，但以下例外。</p>
<p>你不能使用那些具有或可能引发副作用的 JavaScript 表达式，包括：</p>
<ul>
<li><p>赋值 (&#x3D;, +&#x3D;, -&#x3D;, …)</p>
</li>
<li><p>运算符，比如 new、typeof 或 instanceof 等。</p>
</li>
<li><p>链接表达式;或，</p>
</li>
<li><p>自增和自减运算符：++ 和 –</p>
</li>
<li><p>一些 ES2015+ 版本的运算符</p>
</li>
</ul>
<p>和 JavaScript 语法的其它显著差异包括：</p>
<ul>
<li><p>不支持位运算，比如 | 和 &amp;</p>
</li>
<li><p>新的模板表达式运算符，比如 |</p>
</li>
</ul>
<h2 id="表达式上下文"><a href="#表达式上下文" class="headerlink" title="表达式上下文"></a>表达式上下文</h2><p>插值表达式具有上下文 —— 表达式所属应用中的特定部分。通常，此上下文就是组件实例。</p>
<p>在下面的代码片段中，表达式 recommended 和 itemImageUrl2 表达式所引用的都是 AppComponent 中的属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;&#123;recommended&#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&quot;item 2&quot;</span> [<span class="attr">src</span>]=<span class="string">&quot;itemImageUrl2&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>表达式还可以引用模板上下文中的属性，比如模板输入变量或模板引用变量。</p>
<p>下面的例子就使用了模板输入变量 customer。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> *<span class="attr">ngFor</span>=<span class="string">&quot;let customer of customers&quot;</span>&gt;</span>&#123;&#123;customer.name&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来的例子使用了模板引用变量 #customerInput。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>Type something:</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> #<span class="attr">customerInput</span>&gt;</span>&#123;&#123;customerInput.value&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="防止命名冲突"><a href="#防止命名冲突" class="headerlink" title="防止命名冲突"></a>防止命名冲突</h2><p>表达式估算的上下文是模板变量、指令的上下文对象（如果有）和组件成员的并集。如果你引用的名称属于这些命名空间之一，则 Angular 会应用以下优先逻辑来确定上下文：</p>
<p>模板变量的名称。</p>
<p>指令上下文中的名称。</p>
<p>组件成员的名称。</p>
<p>为避免变量遮盖另一个上下文中的变量，请保持变量名称唯一。在以下示例中，AppComponent 模板在问候 customer Padma。</p>
<p>然后，一个 ngFor 列出了 customers 数组中的每个 customer。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;!-- Hello, Padma --&gt;</span></span><br><span class="line"><span class="string">      &lt;h1&gt;Hello, &#123;&#123;customer&#125;&#125;&lt;/h1&gt;</span></span><br><span class="line"><span class="string">      &lt;ul&gt;</span></span><br><span class="line"><span class="string">        &lt;!-- Ebony and Chiho in a list--&gt;</span></span><br><span class="line"><span class="string">        &lt;li *ngFor=&quot;let customer of customers&quot;&gt;&#123;&#123; customer.value &#125;&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;/ul&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AppComponent</span> &#123;</span><br><span class="line">  customers = [&#123;<span class="attr">value</span>: <span class="string">&#x27;Ebony&#x27;</span>&#125;, &#123;<span class="attr">value</span>: <span class="string">&#x27;Chiho&#x27;</span>&#125;];</span><br><span class="line">  customer = <span class="string">&#x27;Padma&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ngFor 中的 customer 处于一个 <ng-template> 的上下文中，所以它指向的是 customers 数组中的 customer，在这里是 Ebony 和 Chiho。此列表中不包含 Padma，因为那个 customer 位于 ngFor 以外的另一个上下文中。反之，<h1> 中的 customer 不包括 Ebony 或 Chiho，因为该 customer 的上下文是组件类，而这个类中 customer 的值是 Padma。</h1></ng-template></p>
<h1 id="属性绑定-Property"><a href="#属性绑定-Property" class="headerlink" title="属性绑定(Property)"></a>属性绑定(Property)</h1><p>Angular 中的属性绑定可帮助你设置 HTML 元素或指令的属性值。使用属性绑定，可以执行诸如切换按钮、以编程方式设置路径，以及在组件之间共享值之类的功能。</p>
<h2 id="绑定到属性"><a href="#绑定到属性" class="headerlink" title="绑定到属性"></a>绑定到属性</h2><p>要绑定到元素的属性 ，请将其括在方括号 [] 内，这会将此属性标为目标属性。目标属性就是你要对其进行赋值的 DOM 属性 。</p>
<p>要为 image 元素的目标属性（src）赋值，请键入以下代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&quot;item&quot;</span> [<span class="attr">src</span>]=<span class="string">&quot;itemImageUrl&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在大多数情况下，目标名称是 Property（属性）名称，即使它看起来是 Attribute（属性）名称。</p>
<p>在这个例子中，src 就是 <img> 元素的 Property 名称。</p>
<blockquote>
<p>方括号 [] 使 Angular 将等号的右侧看作动态表达式进行求值。</p>
</blockquote>
<blockquote>
<p>如果不使用方括号，Angular 就会将右侧视为字符串字面量并将此属性设置为该静态值。</p>
</blockquote>
<p>要将字符串赋值给属性，请键入以下代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-item-detail</span> <span class="attr">childItem</span>=<span class="string">&quot;parentItem&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">app-item-detail</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>省略方括号就会渲染出字符串 parentItem，而不是 parentItem 的值。</p>
<h1 id="Attribute-绑定"><a href="#Attribute-绑定" class="headerlink" title="Attribute 绑定"></a>Attribute 绑定</h1><p>Attribute 绑定语法类似于 Property 绑定，但不是直接在方括号之间放置元素的 Property，而是在 Attribute 名称前面加上前缀 attr，后跟一个点 .。然后，使用解析为字符串的表达式设置 Attribute 值。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> [<span class="attr">attr.attribute-you-are-targeting</span>]=<span class="string">&quot;expression&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当表达式解析为 null 或 undefined 时，Angular 会完全删除该 Attribute。</p>
</blockquote>
<h2 id="绑定到-colspan"><a href="#绑定到-colspan" class="headerlink" title="绑定到 colspan"></a>绑定到 colspan</h2><p>Attribute 绑定的另一个常见用例是绑定到表格中的 colspan Attribute。colspan Attribute 可帮助你以编程方式让表格保持动态。根据应用中用来填充表的数据量，某一行要跨越的列数可能会发生变化。</p>
<p>要将 Attribute 绑定到 <td> 的 colspan Attribute</td></p>
<p>使用以下语法指定 colspan：[attr.colspan]。</p>
<p>将 [attr.colspan] 设置为等于某个表达式。</p>
<p>在下面的示例中，我们将 colspan Attribute 绑定到表达式 1 + 1。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  expression calculates colspan=2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> [<span class="attr">attr.colspan</span>]=<span class="string">&quot;1 + 1&quot;</span>&gt;</span>One-Two<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此绑定会导致 <tr> 跨越两列。</tr></p>
<h1 id="样式-class和style-绑定"><a href="#样式-class和style-绑定" class="headerlink" title="样式(class和style)绑定"></a>样式(class和style)绑定</h1><p>使用类和样式绑定从元素的 class 属性中添加和删除 CSS 类名，以及动态设置样式。</p>
<h2 id="绑定到单个-CSS-class"><a href="#绑定到单个-CSS-class" class="headerlink" title="绑定到单个 CSS class"></a>绑定到单个 CSS class</h2><p>要创建单个类绑定，请键入以下内容：</p>
<p>[class.sale]&#x3D;”onSale”</p>
<p>当绑定表达式 onSale 为真值时，Angular 会添加类，当表达式为假值时，它会删除类 —— undefined 除外。</p>
<h2 id="绑定到多个-CSS-类"><a href="#绑定到多个-CSS-类" class="headerlink" title="绑定到多个 CSS 类"></a>绑定到多个 CSS 类</h2><p>要绑定到多个类，请键入以下内容：</p>
<p>[class]&#x3D;”classExpression”</p>
<p>表达式可以是以下之一：</p>
<ul>
<li><p>用空格分隔的类名字符串。</p>
</li>
<li><p>以类名作为键名并将真或假表达式作为值的对象。</p>
</li>
<li><p>类名的数组。</p>
</li>
</ul>
<p>对于对象格式，Angular 会在其关联的值为真时才添加类。</p>
<p>如果同一类名有多个绑定，Angular 会根据样式优先级来确定要使用的绑定。</p>
<p>下表是各种类绑定语法的小结。</p>
<table>
<thead>
<tr>
<th>绑定类型</th>
<th>语法</th>
<th>输入属性</th>
<th>范例输入值</th>
</tr>
</thead>
<tbody><tr>
<td>单一类绑定</td>
<td>[class.sale]&#x3D;”onSale”</td>
<td>boolean,undefined,null</td>
<td>true, false</td>
</tr>
<tr>
<td>多重类绑定</td>
<td>[class]&#x3D;”classExpression”</td>
<td>string</td>
<td>“my-class-1 my-class-2 my-class-3”</td>
</tr>
<tr>
<td>多重类绑定</td>
<td>[class]&#x3D;”classExpression”</td>
<td>Record&lt;string, ‘boolean,undefined,null’&gt;</td>
<td>{foo: true, bar: false}</td>
</tr>
<tr>
<td>多重类绑定</td>
<td>[class]&#x3D;”classExpression”</td>
<td><code>Array&lt;string&gt;</code></td>
<td>[‘foo’, ‘bar’]</td>
</tr>
</tbody></table>
<h2 id="绑定到单一样式"><a href="#绑定到单一样式" class="headerlink" title="绑定到单一样式"></a>绑定到单一样式</h2><p>要创建单个样式绑定，请使用 style 前缀，后跟一个点和 CSS 样式的名称。</p>
<p>比如，要设置 ‘width’ 样式，请键入以下内容：[style.width]&#x3D;”width”</p>
<p>Angular 将该属性设置为绑定表达式的值，这通常是一个字符串。（可选）你可以添加单位扩展名，比如 em 或 %，这需要数字类型。</p>
<h2 id="绑定到多个样式"><a href="#绑定到多个样式" class="headerlink" title="绑定到多个样式"></a>绑定到多个样式</h2><p>要切换多个样式，请绑定到 [style] Attribute，比如 [style]&#x3D;”styleExpression”。styleExpression 可以是如下格式之一：</p>
<p>样式的字符串列表，比如 “width: 100px; height: 100px; background-color: cornflowerblue;”。</p>
<p>一个对象，其键名是样式名，其值是样式值，比如 {width: ‘100px’, height: ‘100px’, backgroundColor: ‘cornflowerblue’}。</p>
<p>注意，不支持把数组绑定给 [style]</p>
<blockquote>
<p>当把 [style] 绑定到对象表达式时，该对象的引用必须改变，这样 Angular 才能更新这个类列表。在不改变对象引用的情况下更新其属性值是不会生效的。</p>
</blockquote>
<h2 id="单样式和多样式绑定示例"><a href="#单样式和多样式绑定示例" class="headerlink" title="单样式和多样式绑定示例"></a>单样式和多样式绑定示例</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-nav-bar&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">&lt;nav [style]=&#x27;navStyle&#x27;&gt;</span></span><br><span class="line"><span class="string">  &lt;a [style.text-decoration]=&quot;activeLinkStyle&quot;&gt;Home Page&lt;/a&gt;</span></span><br><span class="line"><span class="string">  &lt;a [style.text-decoration]=&quot;linkStyle&quot;&gt;Login&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/nav&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">NavBarComponent</span> &#123;</span><br><span class="line">  navStyle = <span class="string">&#x27;font-size: 1.2rem; color: cornflowerblue;&#x27;</span>;</span><br><span class="line">  linkStyle = <span class="string">&#x27;underline&#x27;</span>;</span><br><span class="line">  activeLinkStyle = <span class="string">&#x27;overline&#x27;</span>;</span><br><span class="line">  <span class="comment">/* . . . */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下表是各种样式绑定语法的小结。</p>
<table>
<thead>
<tr>
<th>绑定类型</th>
<th>语法</th>
<th>输入属性</th>
<th>范例输入值</th>
</tr>
</thead>
<tbody><tr>
<td>单一样式绑定</td>
<td>[style.width]&#x3D;”width”</td>
<td>string, undefined,null</td>
<td>“100px”</td>
</tr>
<tr>
<td>带单位的单一样式绑定</td>
<td>[style.width.px]&#x3D;”width”</td>
<td>number,undefined,null</td>
<td>100</td>
</tr>
<tr>
<td>多重样式绑定</td>
<td>[style]&#x3D;”styleExpression”</td>
<td>string</td>
<td>“width: 100px; height: 100px”</td>
</tr>
<tr>
<td>多重样式绑定</td>
<td>[style]&#x3D;”styleExpression”</td>
<td>Record&lt;string, string,undefined,null&gt;</td>
<td>{width: ‘100px’, height: ‘100px’}</td>
</tr>
</tbody></table>
<h1 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h1><p>通过事件绑定，你可以侦听并响应用户操作，比如按键、鼠标移动、点击和触摸。</p>
<h2 id="绑定到事件"><a href="#绑定到事件" class="headerlink" title="绑定到事件"></a>绑定到事件</h2><p>要绑定到事件，你可以使用 Angular 事件绑定语法。此语法由等号左侧括号中的目标事件名称和右侧带引号的模板语句组成。</p>
<p>创建以下示例；目标事件名是 click，模板语句是 onSave()。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> (<span class="attr">click</span>)=<span class="string">&quot;onSave()&quot;</span>&gt;</span>Save<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>事件绑定侦听按钮的单击事件，并在发生单击时调用组件的 onSave()。</p>
<h2 id="绑定到被动事件"><a href="#绑定到被动事件" class="headerlink" title="绑定到被动事件"></a>绑定到被动事件</h2><p>这是一项高级技术，对于大多数应用程序来说不是必需的。如果你想优化导致性能问题的频繁发生的事件，可能会发现这很有用。</p>
<p>Angular 还支持被动事件侦听器。比如，使用以下步骤使滚动事件变为被动的。</p>
<p>在 src 目录下创建一个文件 zone-flags.ts。</p>
<p>将以下行添加到此文件中。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="variable language_">window</span> <span class="keyword">as</span> <span class="built_in">any</span>)[<span class="string">&#x27;__zone_symbol__PASSIVE_EVENTS&#x27;</span>] = [<span class="string">&#x27;scroll&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>在 src&#x2F;polyfills.ts 文件中，在导入 zone.js 之前，先导入新创建的 zone-flags。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./zone-flags&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;zone.js&#x27;</span>;  <span class="comment">// Included with Angular CLI.</span></span><br></pre></td></tr></table></figure>
<p>在这些步骤之后，如果你为 scroll 事件添加事件侦听器，侦听器就会是 passive 的。</p>
<h2 id="绑定到键盘事件"><a href="#绑定到键盘事件" class="headerlink" title="绑定到键盘事件"></a>绑定到键盘事件</h2><p>你可以用 Angular 的绑定语法绑定到键盘事件。你可以指定要绑定到键盘事件的键值或代码。它们的 key 和 code 字段是浏览器键盘事件对象的原生部分。默认情况下，事件绑定假定你要使用键盘事件上的 key 字段。你还可以用 code 字段。</p>
<p>键的组合可以用点（.）分隔。例如， keydown.enter 将允许你将事件绑定到 enter 键。你还可以用修饰键，例如 shift 、 alt 、 control 和 Mac 中的 command 键。以下示例展示了如何将键盘事件绑定到 keydown.shift.t 。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> (<span class="attr">keydown.shift.t</span>)=<span class="string">&quot;onKeydown($event)&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>根据操作系统的不同，某些组合键可能会创建特殊字符，而不是你期望的组合键。例如，当你同时使用 option 和 shift 键时，MacOS 会创建特殊字符。如果你绑定到 keydown.shift.alt.t ，在 macOS 上，该组合会生成 ˇ 而不是 t ，它与绑定不匹配，也不会触发你的事件处理程序。要绑定到 macOS 上的 keydown.shift.alt.t ，请使用 code 键盘事件字段来获取正确的行为，例如此示例中显示的 keydown.code.shiftleft.altleft.keyt 。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> (<span class="attr">keydown.code.shiftleft.altleft.keyt</span>)=<span class="string">&quot;onKeydown($event)&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>code 字段比 key 字段更具体。 key 字段总是会报告 shift ，而 code 字段将指明 leftshift 或 rightshift 。使用 code 字段时，你可能需要添加单独的绑定以捕获你想要的所有行为。使用 code 字段时无需处理操作系统特有的行为，例如 macOS 上的 shift + option 行为。</p>
<p>有关更多信息，请访问键值和键码的完整参考，以帮助你构建事件字符串。</p>
<h1 id="双向绑定（组件）"><a href="#双向绑定（组件）" class="headerlink" title="双向绑定（组件）"></a>双向绑定（组件）</h1><p>双向绑定为应用中的组件提供了一种共享数据的方式。使用双向绑定绑定来侦听事件并在父组件和子组件之间同步更新值。</p>
<h2 id="添加双向数据绑定"><a href="#添加双向数据绑定" class="headerlink" title="添加双向数据绑定"></a>添加双向数据绑定</h2><p>Angular 的双向绑定语法是方括号和圆括号的组合 [()]。[] 进行属性绑定，() 进行事件绑定，如下所示。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-sizer</span> [(<span class="attr">size</span>)]=<span class="string">&quot;fontSizePx&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">app-sizer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="双向绑定工作原理"><a href="#双向绑定工作原理" class="headerlink" title="双向绑定工作原理"></a>双向绑定工作原理</h2><p>为了使双向数据绑定有效，@Output() 属性的名字必须遵循 inputChange 模式，其中 input 是相应 @Input() 属性的名字。比如，如果 @Input() 属性为 size，则 @Output() 属性必须为 sizeChange。</p>
<p>后面的 sizerComponent 具有值属性 size 和事件属性 sizeChange。size 属性是 @Input()，因此数据可以流入 sizerComponent。sizeChange 事件是一个 @Output()，它允许数据从 sizerComponent 流出到父组件。</p>
<p>接下来，有两个方法，dec() 用于减小字体大小，inc() 用于增大字体大小。这两种方法使用 resize() 在最小&#x2F;最大值的约束内更改 size 属性的值，并发出带有新 size 值的事件。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">SizerComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Input</span>()  size!: <span class="built_in">number</span> | <span class="built_in">string</span>;</span><br><span class="line">  <span class="meta">@Output</span>() sizeChange = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="title function_">dec</span>(<span class="params"></span>) &#123; <span class="variable language_">this</span>.<span class="title function_">resize</span>(-<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="title function_">inc</span>(<span class="params"></span>) &#123; <span class="variable language_">this</span>.<span class="title function_">resize</span>(+<span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">resize</span>(<span class="params">delta: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="number">40</span>, <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">8</span>, +<span class="variable language_">this</span>.<span class="property">size</span> + delta));</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sizeChange</span>.<span class="title function_">emit</span>(<span class="variable language_">this</span>.<span class="property">size</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sizerComponent 模板有两个按钮，分别将 click 事件绑定到 inc() 和 dec() 方法。当用户单击按钮之一时，sizerComponent 调用相应的方法。inc() 和 dec() 这两个方法分别使用 +1 或 -1 调用 resize() 方法，它使用新的 size 值引发 sizeChange 事件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> (<span class="attr">click</span>)=<span class="string">&quot;dec()&quot;</span> <span class="attr">title</span>=<span class="string">&quot;smaller&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> (<span class="attr">click</span>)=<span class="string">&quot;inc()&quot;</span> <span class="attr">title</span>=<span class="string">&quot;bigger&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> [<span class="attr">style.font-size.px</span>]=<span class="string">&quot;size&quot;</span>&gt;</span>FontSize: &#123;&#123;size&#125;&#125;px<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 AppComponent 模板中，fontSizePx 被双向绑定到 SizerComponent。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-sizer</span> [(<span class="attr">size</span>)]=<span class="string">&quot;fontSizePx&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">app-sizer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> [<span class="attr">style.font-size.px</span>]=<span class="string">&quot;fontSizePx&quot;</span>&gt;</span>Resizable Text<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 AppComponent 中，通过将 fontSizePx 的值设置为 16 来设置初始 SizerComponent.size 值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fontSizePx = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>
<p>单击这些按钮将更新 AppComponent.fontSizePx。修改后的 AppComponent.fontSizePx 值将更新样式绑定，从而使显示的文本变大或变小。</p>
<p>双向绑定语法是属性绑定和事件绑定的组合的简写形式。拆成单独的属性绑定和事件绑定形式的 SizerComponent 代码如下。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-sizer</span> [<span class="attr">size</span>]=<span class="string">&quot;fontSizePx&quot;</span> (<span class="attr">sizeChange</span>)=<span class="string">&quot;fontSizePx=$event&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">app-sizer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>$event 变量包含 SizerComponent.sizeChange 事件的数据。当用户单击按钮时，Angular 将 $event 赋值给 AppComponent.fontSizePx。</p>
<h1 id="表单中的双向绑定"><a href="#表单中的双向绑定" class="headerlink" title="表单中的双向绑定"></a>表单中的双向绑定</h1><p>因为没有任何原生 HTML 元素遵循了 x 值和 xChange 事件的命名模式，所以与表单元素进行双向绑定需要使用 NgModel。</p>
<h1 id="模板变量"><a href="#模板变量" class="headerlink" title="模板变量"></a>模板变量</h1><p>模板变量可以帮助你在模板的另一部分使用这个部分的数据。使用模板变量，你可以执行某些任务，比如响应用户输入或微调应用的表单。</p>
<p>模板变量可以引用这些东西：</p>
<ul>
<li><p>模板中的 DOM 元素</p>
</li>
<li><p>指令或组件</p>
</li>
<li><p>来自 ng-template 的 TemplateRef</p>
</li>
<li><p>Web 组件</p>
</li>
</ul>
<p>在模板中，要使用井号 # 来声明一个模板变量。下列模板变量 #phone 声明了一个名为 phone 的变量，其值为此 <code>&lt;input&gt;</code> 元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> #<span class="attr">phone</span> <span class="attr">placeholder</span>=<span class="string">&quot;phone number&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以在组件模板中的任何地方引用某个模板变量。这里的 <code>&lt;button&gt; </code>就引用了 phone 变量。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> #<span class="attr">phone</span> <span class="attr">placeholder</span>=<span class="string">&quot;phone number&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- lots of other elements --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- phone refers to the input element; pass its `value` to an event handler --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> (<span class="attr">click</span>)=<span class="string">&quot;callPhone(phone.value)&quot;</span>&gt;</span>Call<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Angular-是如何为模板变量赋值的"><a href="#Angular-是如何为模板变量赋值的" class="headerlink" title="Angular 是如何为模板变量赋值的"></a>Angular 是如何为模板变量赋值的</h2><p>Angular 根据你所声明的变量的位置给模板变量赋值：</p>
<ul>
<li><p>如果在组件上声明变量，该变量就会引用该组件实例。</p>
</li>
<li><p>如果在标准的 HTML 标记上声明变量，该变量就会引用该元素。</p>
</li>
<li><p>如果你在 <ng-template> 元素上声明变量，该变量就会引用一个 TemplateRef 实例来代表此模板。</ng-template></p>
</li>
</ul>
<h2 id="指定名称的变量"><a href="#指定名称的变量" class="headerlink" title="指定名称的变量"></a>指定名称的变量</h2><p>如果该变量在右侧指定了一个名字，比如 #var&#x3D;”ngModel”，那么该变量就会引用所在元素上具有这个 exportAs 名字的指令或组件。</p>
<h3 id="将-NgForm-与模板变量一起使用"><a href="#将-NgForm-与模板变量一起使用" class="headerlink" title="将 NgForm 与模板变量一起使用"></a>将 NgForm 与模板变量一起使用</h3><p>在大多数情况下，Angular 会把模板变量的值设置为它所在的元素。在前面的例子中，phone 引用的是电话号码 <code>&lt;input&gt;</code>。该按钮的 click 处理程序会把这个 <code>&lt;input&gt;</code> 的值传给该组件的 callPhone() 方法。</p>
<p>这里的 NgForm 指令演示了如何通过引用指令的的 exportAs 名字来引用不同的值。在下面的例子中，模板变量 itemForm 在 HTML 中分别出现了三次。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> #<span class="attr">itemForm</span>=<span class="string">&quot;ngForm&quot;</span> (<span class="attr">ngSubmit</span>)=<span class="string">&quot;onSubmit(itemForm)&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;name&quot;</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">ngModel</span> <span class="attr">required</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> [<span class="attr">hidden</span>]=<span class="string">&quot;!itemForm.form.valid&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; submitMessage &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果没有 ngForm 这个属性值，itemForm 引用的值将是 HTMLFormElement 也就是 <code>&lt;form&gt;</code> 元素。如果某元素是一个 Angular 组件，则不带属性值的引用会自动引用此组件的实例。否则，不带属性值的引用会引用此 DOM 元素，而不管此元素上有一个或多个指令。</p>
<h2 id="模板变量的作用域"><a href="#模板变量的作用域" class="headerlink" title="模板变量的作用域"></a>模板变量的作用域</h2><p>就像 JavaScript 或 TypeScript 代码中的变量一样，模板变量的范围为声明它们的模板。</p>
<p>同样，诸如 *ngIf 和 *ngFor 类的结构指令或 <code>&lt;ng-template&gt;</code> 声明会创建一个新的嵌套模板范围，就像 JavaScript 的控制流语句（例如 if 和 for 创建新的词法范围。你不能从边界外访问这些结构指令之一中的模板变量。</p>
<h2 id="在嵌套模板中访问"><a href="#在嵌套模板中访问" class="headerlink" title="在嵌套模板中访问"></a>在嵌套模板中访问</h2><p>内部模板可以访问外模板定义的模板变量。</p>
<p>在下面的例子中，修改 <code>&lt;input&gt;</code> 中的文本值也会改变 <code>&lt;span&gt;</code> 中的值，因为 Angular 会立即通过模板变量 ref1 来更新这种变化。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> #<span class="attr">ref1</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> [(<span class="attr">ngModel</span>)]=<span class="string">&quot;firstExample&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> *<span class="attr">ngIf</span>=<span class="string">&quot;true&quot;</span>&gt;</span>Value: &#123;&#123; ref1.value &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这种情况下，<code>&lt;span&gt;</code> 上的 *ngIf 会创建一个新的模板范围，其中包括其父范围中的 ref1 变量。</p>
<p>但是，从外部的父模板访问子范围中的变量是行不通的。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> *<span class="attr">ngIf</span>=<span class="string">&quot;true&quot;</span> #<span class="attr">ref2</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> [(<span class="attr">ngModel</span>)]=<span class="string">&quot;secondExample&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Value: &#123;&#123; ref2?.value &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="comment">&lt;!-- doesn&#x27;t work --&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这里，ref2 是在 *ngIf 创建的子范围中声明的，并且无法从父模板访问。</p>
<h2 id="模板输入变量"><a href="#模板输入变量" class="headerlink" title="模板输入变量"></a>模板输入变量</h2><p>模板输入变量是一个具有在创建该模板实例时设置的值的变量。</p>
<p>可以在 NgFor 的长格式用法中看到模板输入变量的作用：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ng-template</span> <span class="attr">ngFor</span> <span class="attr">let-hero</span> [<span class="attr">ngForOf</span>]=<span class="string">&quot;heroes&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;hero.name&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">ng-template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>NgFor 指令将实例化此为 hero 数组中的每个 heroes 一次，并将为每个实例相应地设置 hero 变量。</p>
<p>实例化 <code>&lt;ng-template&gt;</code> 时，可以传递多个命名值，这些值可以绑定到不同的模板输入变量。输入变量的 let- 声明的右侧可以指定应该用于该变量的值。</p>
<p>例如，NgFor 还提供了对数组中每个英雄的 index 的访问：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ng-template</span> <span class="attr">ngFor</span> <span class="attr">let-hero</span> <span class="attr">let-i</span>=<span class="string">&quot;index&quot;</span> [<span class="attr">ngForOf</span>]=<span class="string">&quot;heroes&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Hero number &#123;&#123;i&#125;&#125;: &#123;&#123;hero.name&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">ng-template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/03/17/angular/%E7%BB%84%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/17/angular/%E7%BB%84%E4%BB%B6/" class="post-title-link" itemprop="url">组件(Component)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-17 10:43:50" itemprop="dateCreated datePublished" datetime="2023-03-17T10:43:50+08:00">2023-03-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-31 18:05:06" itemprop="dateModified" datetime="2023-03-31T18:05:06+08:00">2023-03-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>组件是 Angular 应用的主要构造块。每个组件包括如下部分：</p>
<ul>
<li><p>一个 HTML 模板，用于声明页面要渲染的内容</p>
</li>
<li><p>一个用于定义行为的 TypeScript 类</p>
</li>
<li><p>一个 CSS 选择器，用于定义组件在模板中的使用方式</p>
</li>
<li><p>（可选）要应用在模板上的 CSS 样式</p>
</li>
</ul>
<h1 id="创建一个组件"><a href="#创建一个组件" class="headerlink" title="创建一个组件"></a>创建一个组件</h1><p>运行 <code>ng generate component &lt;component-name&gt;</code> 命令，其中 <code>&lt;component-name&gt;</code> 是新组件的名字。</p>
<h2 id="指定组件的-CSS-选择器"><a href="#指定组件的-CSS-选择器" class="headerlink" title="指定组件的 CSS 选择器"></a>指定组件的 CSS 选择器</h2><p>每个组件都需要一个 CSS 选择器。选择器会告诉 Angular：当在模板 HTML 中找到相应的标签时，就把该组件实例化在那里。<br>比如，考虑一个组件 hello-world.component.ts，它的选择器定义为 app-hello-world。当 <app-hello-world> 出现在模板中时，这个选择器就会让 Angular 实例化该组件。</app-hello-world></p>
<p>在 @Component 装饰器中添加一个 selector 语句来指定组件的选择器。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-component-overview&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="定义一个组件的模板"><a href="#定义一个组件的模板" class="headerlink" title="定义一个组件的模板"></a>定义一个组件的模板</h2><p>模板是一段 HTML，它告诉 Angular 如何在应用中渲染组件。可以通过以下两种方式之一为组件定义模板：引用外部文件，或直接写在组件内部。</p>
<p>要把模板定义为外部文件，就要把 templateUrl 添加到 @Component 装饰器中。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-component-overview&#x27;</span>,</span><br><span class="line">  <span class="attr">templateUrl</span>: <span class="string">&#x27;./component-overview.component.html&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>要在组件中定义模板，就要把一个 template 属性添加到 @Component 中，该属性的内容是要使用的 HTML。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-component-overview&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;h1&gt;Hello World!&lt;/h1&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;This template definition spans multiple lines.&lt;/p&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Angular 组件需要一个用 template 或 templateUrl 定义的模板。但你不能在组件中同时拥有这两个语句。</p>
</blockquote>
<h2 id="声明组件的样式"><a href="#声明组件的样式" class="headerlink" title="声明组件的样式"></a>声明组件的样式</h2><p>有两种方式可以为组件的模板声明样式：引用一个外部文件，或直接写在组件内部。</p>
<p>要在单独的文件中声明组件的样式，就要把 styleUrls 属性添加到 @Component 装饰器中。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-component-overview&#x27;</span>,</span><br><span class="line">  <span class="attr">templateUrl</span>: <span class="string">&#x27;./component-overview.component.html&#x27;</span>,</span><br><span class="line">  <span class="attr">styleUrls</span>: [<span class="string">&#x27;./component-overview.component.css&#x27;</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>要想在组件内部声明样式，就要把 styles 属性添加到 @Component，该属性的内容是你要用的样式。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-component-overview&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;h1&gt;Hello World!&lt;/h1&gt;&#x27;</span>,</span><br><span class="line">  <span class="attr">styles</span>: [<span class="string">&#x27;h1 &#123; font-weight: normal; &#125;&#x27;</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h1><p>当 Angular 实例化组件类并渲染组件视图及其子视图时，组件实例的生命周期就开始了。生命周期一直伴随着变更检测，Angular 会检查数据绑定属性何时发生变化，并按需更新视图和组件实例。当 Angular 销毁组件实例并从 DOM 中移除它渲染的模板时，生命周期就结束了。当 Angular 在执行过程中创建、更新和销毁实例时，指令就有了类似的生命周期。</p>
<p>应用可以使用生命周期钩子方法来触发组件或指令生命周期中的关键事件，以初始化新实例，需要时启动变更检测，在变更检测过程中响应更新，并在删除实例之前进行清理。</p>
<h2 id="生命周期的顺序"><a href="#生命周期的顺序" class="headerlink" title="生命周期的顺序"></a>生命周期的顺序</h2><p>当你的应用通过调用构造函数来实例化一个组件或指令时，Angular 就会调用那个在该实例生命周期的适当位置实现了的那些钩子方法。</p>
<p>Angular 会按以下顺序执行钩子方法。可以用它来执行以下类型的操作。</p>
<h3 id="ngOnChanges"><a href="#ngOnChanges" class="headerlink" title="ngOnChanges()"></a>ngOnChanges()</h3><h4 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h4><p>如果组件绑定过输入属性，那么在 ngOnInit() 之前以及所绑定的一个或多个输入属性的值发生变化时都会调用。</p>
<p>如果你的组件没有输入属性，或者你使用它时没有提供任何输入属性，那么框架就不会调用 ngOnChanges()。</p>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>当 Angular 设置或重新设置数据绑定的输入属性时响应。该方法接受当前和上一属性值的 SimpleChanges 对象</p>
<p>注意：这发生得比较频繁，所以你在这里执行的任何操作都会显著影响性能。</p>
<h3 id="ngOnInit"><a href="#ngOnInit" class="headerlink" title="ngOnInit()"></a>ngOnInit()</h3><h4 id="时机-1"><a href="#时机-1" class="headerlink" title="时机"></a>时机</h4><p>在第一轮 ngOnChanges() 完成之后调用，只调用一次。而且即使没有调用过 ngOnChanges()，也仍然会调用 ngOnInit()（比如当模板中没有绑定任何输入属性时）。</p>
<h4 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h4><p>在 Angular 第一次显示数据绑定和设置指令&#x2F;组件的输入属性之后，初始化指令&#x2F;组件。</p>
<h3 id="ngDoCheck"><a href="#ngDoCheck" class="headerlink" title="ngDoCheck()"></a>ngDoCheck()</h3><h4 id="时机-2"><a href="#时机-2" class="headerlink" title="时机"></a>时机</h4><p>紧跟在每次执行变更检测时的 ngOnChanges() 和 首次执行变更检测时的 ngOnInit() 后调用。</p>
<h4 id="用途-2"><a href="#用途-2" class="headerlink" title="用途"></a>用途</h4><p>检测，并在发生 Angular 无法或不愿意自己检测的变化时作出反应。</p>
<h3 id="ngAfterContentInit"><a href="#ngAfterContentInit" class="headerlink" title="ngAfterContentInit()"></a>ngAfterContentInit()</h3><h4 id="时机-3"><a href="#时机-3" class="headerlink" title="时机"></a>时机</h4><p>第一次 ngDoCheck() 之后调用，只调用一次。</p>
<h4 id="用途-3"><a href="#用途-3" class="headerlink" title="用途"></a>用途</h4><p>当 Angular 把外部内容投影进组件视图或指令所在的视图之后调用。</p>
<h3 id="ngAfterContentChecked"><a href="#ngAfterContentChecked" class="headerlink" title="ngAfterContentChecked()"></a>ngAfterContentChecked()</h3><h4 id="时机-4"><a href="#时机-4" class="headerlink" title="时机"></a>时机</h4><p>ngAfterContentInit() 和每次 ngDoCheck() 之后调用。</p>
<h4 id="用途-4"><a href="#用途-4" class="headerlink" title="用途"></a>用途</h4><p>每当 Angular 检查完被投影到组件或指令中的内容之后调用。</p>
<h3 id="ngAfterViewInit"><a href="#ngAfterViewInit" class="headerlink" title="ngAfterViewInit()"></a>ngAfterViewInit()</h3><h4 id="时机-5"><a href="#时机-5" class="headerlink" title="时机"></a>时机</h4><p>第一次 ngAfterContentChecked() 之后调用，只调用一次。</p>
<h4 id="用途-5"><a href="#用途-5" class="headerlink" title="用途"></a>用途</h4><p>当 Angular 初始化完组件视图及其子视图或包含该指令的视图之后调用。</p>
<h3 id="ngAfterViewChecked"><a href="#ngAfterViewChecked" class="headerlink" title="ngAfterViewChecked()"></a>ngAfterViewChecked()</h3><h4 id="时机-6"><a href="#时机-6" class="headerlink" title="时机"></a>时机</h4><p>ngAfterViewInit() 和每次 ngAfterContentChecked() 之后调用。</p>
<h4 id="用途-6"><a href="#用途-6" class="headerlink" title="用途"></a>用途</h4><p>每当 Angular 做完组件视图和子视图或包含该指令的视图的变更检测之后调用。</p>
<h3 id="ngOnDestroy"><a href="#ngOnDestroy" class="headerlink" title="ngOnDestroy()"></a>ngOnDestroy()</h3><h4 id="时机-7"><a href="#时机-7" class="headerlink" title="时机"></a>时机</h4><p>在 Angular 销毁指令或组件之前立即调用。</p>
<h4 id="用途-7"><a href="#用途-7" class="headerlink" title="用途"></a>用途</h4><p>每当 Angular 每次销毁指令&#x2F;组件之前调用并清扫。在这儿反订阅可观察对象和分离事件处理器，以防内存泄漏。</p>
<h2 id="所有生命周期事件的顺序和频率"><a href="#所有生命周期事件的顺序和频率" class="headerlink" title="所有生命周期事件的顺序和频率"></a>所有生命周期事件的顺序和频率</h2><table>
<thead>
<tr>
<th>顺序</th>
<th>事件</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>OnChanges</td>
</tr>
<tr>
<td>2</td>
<td>OnInit</td>
</tr>
<tr>
<td>3</td>
<td>DoCheck</td>
</tr>
<tr>
<td>4</td>
<td>AfterContentInit</td>
</tr>
<tr>
<td>5</td>
<td>AfterContentChecked</td>
</tr>
<tr>
<td>6</td>
<td>AfterViewInit</td>
</tr>
<tr>
<td>7</td>
<td>AfterViewChecked</td>
</tr>
<tr>
<td>8</td>
<td>DoCheck</td>
</tr>
<tr>
<td>9</td>
<td>AfterContentChecked</td>
</tr>
<tr>
<td>10</td>
<td>AfterViewChecked</td>
</tr>
<tr>
<td>11</td>
<td>OnDestroy</td>
</tr>
</tbody></table>
<h1 id="视图封装"><a href="#视图封装" class="headerlink" title="视图封装"></a>视图封装</h1><p>在 Angular 中，组件的样式可以封装在组件的宿主元素中，这样它们就不会影响应用程序的其余部分。</p>
<p>Component 的装饰器提供了 encapsulation 选项，可用来控制如何基于每个组件应用视图封装。</p>
<h2 id="ViewEncapsulation-ShadowDom"><a href="#ViewEncapsulation-ShadowDom" class="headerlink" title="ViewEncapsulation.ShadowDom"></a>ViewEncapsulation.ShadowDom</h2><p>Angular 使用浏览器内置的 Shadow DOM API 将组件的视图包含在 ShadowRoot（用作组件的宿主元素）中，并以隔离的方式应用所提供的样式。</p>
<h2 id="ViewEncapsulation-Emulated"><a href="#ViewEncapsulation-Emulated" class="headerlink" title="ViewEncapsulation.Emulated"></a>ViewEncapsulation.Emulated</h2><p>Angular 会修改组件的 CSS 选择器，使它们只应用于组件的视图，不影响应用程序中的其他元素（模拟 Shadow DOM 行为）</p>
<h2 id="ViewEncapsulation-None"><a href="#ViewEncapsulation-None" class="headerlink" title="ViewEncapsulation.None"></a>ViewEncapsulation.None</h2><p>Angular 不应用任何形式的视图封装，这意味着为组件指定的任何样式实际上都是全局应用的，并且可以影响应用程序中存在的任何 HTML 元素。这种模式本质上与将样式包含在 HTML 本身中是一样的。</p>
<h1 id="组件之间的交互"><a href="#组件之间的交互" class="headerlink" title="组件之间的交互"></a>组件之间的交互</h1><p>Angular 中的一个常见模式就是在父组件和一个或多个子组件之间共享数据。可以用 @Input() 和 @Output() 来实现这个模式。</p>
<p>考虑以下层次结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent-component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child-component</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>@Input() 允许父组件更新子组件中的数据。相反，@Output() 允许子组件向父组件发送数据。</p>
<h2 id="把数据发送到子组件"><a href="#把数据发送到子组件" class="headerlink" title="把数据发送到子组件"></a>把数据发送到子组件</h2><p>子组件或指令中的 @Input() 装饰器表示该属性可以从其父组件中获取值。</p>
<h3 id="配置子组件"><a href="#配置子组件" class="headerlink" title="配置子组件"></a>配置子组件</h3><p>要使用 @Input() 装饰器，首先要导入 Input，然后用 @Input() 装饰该属性，如下例所示。</p>
<blockquote>
<p>src&#x2F;app&#x2F;item-detail&#x2F;item-detail.component.ts</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span>, <span class="title class_">Input</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>; <span class="comment">// First, import Input</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ItemDetailComponent</span> &#123;</span><br><span class="line">  <span class="meta">@Input</span>() item = <span class="string">&#x27;&#x27;</span>; <span class="comment">// decorate the property with @Input()</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，@Input() 会修饰属性 item，它的类型为 string，但 @Input() 属性可以是任意类型，比如 number、string、boolean 或 object。item 的值来自父组件。</p>
</blockquote>
<p>接下来，在子组件模板中添加以下内容：</p>
<blockquote>
<p>src&#x2F;app&#x2F;item-detail&#x2F;item-detail.component.html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line"> Today&#x27;s item: &#123;&#123;item&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="配置父组件"><a href="#配置父组件" class="headerlink" title="配置父组件"></a>配置父组件</h3><p>使用属性绑定把子组件的 item 属性绑定到父组件的 currentItem 属性上。</p>
<blockquote>
<p>src&#x2F;app&#x2F;app.component.html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-item-detail</span> [<span class="attr">item</span>]=<span class="string">&quot;currentItem&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">app-item-detail</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在父组件类中，为 currentItem 指定一个值：<br>src&#x2F;app&#x2F;app.component.ts</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppComponent</span> &#123;</span><br><span class="line"> currentItem = <span class="string">&#x27;Television&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 @Input()，Angular 把 currentItem 的值传给子组件，以便 item 渲染为 Television。</p>
</blockquote>
<h3 id="监视-Input-的变更"><a href="#监视-Input-的变更" class="headerlink" title="监视 @Input() 的变更"></a>监视 @Input() 的变更</h3><p>要想监视 @Input() 属性的变化，可以用 Angular 的生命周期钩子OnChanges 或 使用一个输入属性的 setter，以拦截父组件中值的变化。</p>
<h4 id="通过-ngOnChanges-来截听输入属性值的变化"><a href="#通过-ngOnChanges-来截听输入属性值的变化" class="headerlink" title="通过 ngOnChanges() 来截听输入属性值的变化"></a>通过 ngOnChanges() 来截听输入属性值的变化</h4><p>VersionParentComponent 提供 minor 和 major 值，把修改它们值的方法绑定到按钮上。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-version-parent&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;h2&gt;Source code version&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;button type=&quot;button&quot; (click)=&quot;newMinor()&quot;&gt;New minor version&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;button type=&quot;button&quot; (click)=&quot;newMajor()&quot;&gt;New major version&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;app-version-child [major]=&quot;major&quot; [minor]=&quot;minor&quot;&gt;&lt;/app-version-child&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">VersionParentComponent</span> &#123;</span><br><span class="line">  major = <span class="number">1</span>;</span><br><span class="line">  minor = <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">newMinor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">minor</span>++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">newMajor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">major</span>++;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">minor</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 VersionChildComponent 会监测输入属性 major 和 minor 的变化，并把这些变化编写成日志以报告这些变化。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span>, <span class="title class_">Input</span>, <span class="title class_">OnChanges</span>, <span class="title class_">SimpleChanges</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-version-child&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;h3&gt;Version &#123;&#123;major&#125;&#125;.&#123;&#123;minor&#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">    &lt;h4&gt;Change log:&lt;/h4&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">      &lt;li *ngFor=&quot;let change of changeLog&quot;&gt;&#123;&#123;change&#125;&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">VersionChildComponent</span> <span class="keyword">implements</span> <span class="title class_">OnChanges</span> &#123;</span><br><span class="line">  <span class="meta">@Input</span>() major = <span class="number">0</span>;</span><br><span class="line">  <span class="meta">@Input</span>() minor = <span class="number">0</span>;</span><br><span class="line">  <span class="attr">changeLog</span>: <span class="built_in">string</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="title function_">ngOnChanges</span>(<span class="params">changes: SimpleChanges</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">log</span>: <span class="built_in">string</span>[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> propName <span class="keyword">in</span> changes) &#123;</span><br><span class="line">      <span class="keyword">const</span> changedProp = changes[propName];</span><br><span class="line">      <span class="keyword">const</span> to = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(changedProp.<span class="property">currentValue</span>);</span><br><span class="line">      <span class="keyword">if</span> (changedProp.<span class="title function_">isFirstChange</span>()) &#123;</span><br><span class="line">        log.<span class="title function_">push</span>(<span class="string">`Initial value of <span class="subst">$&#123;propName&#125;</span> set to <span class="subst">$&#123;to&#125;</span>`</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">from</span> = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(changedProp.<span class="property">previousValue</span>);</span><br><span class="line">        log.<span class="title function_">push</span>(<span class="string">`<span class="subst">$&#123;propName&#125;</span> changed from <span class="subst">$&#123;<span class="keyword">from</span>&#125;</span> to <span class="subst">$&#123;to&#125;</span>`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">changeLog</span>.<span class="title function_">push</span>(log.<span class="title function_">join</span>(<span class="string">&#x27;, &#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过-setter-截听输入属性值的变化"><a href="#通过-setter-截听输入属性值的变化" class="headerlink" title="通过 setter 截听输入属性值的变化"></a>通过 setter 截听输入属性值的变化</h3><p>使用一个输入属性的 setter，以拦截父组件中值的变化，并采取行动。</p>
<p>NameParentComponent 展示了各种名字的处理方式，包括一个全是空格的名字。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-name-parent&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;h2&gt;Master controls &#123;&#123;names.length&#125;&#125; names&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;app-name-child *ngFor=&quot;let name of names&quot; [name]=&quot;name&quot;&gt;&lt;/app-name-child&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">NameParentComponent</span> &#123;</span><br><span class="line">  <span class="comment">// Displays &#x27;Dr. IQ&#x27;, &#x27;&lt;no name set&gt;&#x27;, &#x27;Bombasto&#x27;</span></span><br><span class="line">  names = [<span class="string">&#x27;Dr. IQ&#x27;</span>, <span class="string">&#x27;   &#x27;</span>, <span class="string">&#x27;  Bombasto  &#x27;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子组件 NameChildComponent 的输入属性 name 上的这个 setter，会 trim 掉名字里的空格，并把空值替换成默认字符串。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span>, <span class="title class_">Input</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-name-child&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;h3&gt;&quot;&#123;&#123;name&#125;&#125;&quot;&lt;/h3&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">NameChildComponent</span> &#123;</span><br><span class="line">  <span class="meta">@Input</span>()</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>(): <span class="built_in">string</span> &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>; &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = (name &amp;&amp; name.<span class="title function_">trim</span>()) || <span class="string">&#x27;&lt;no name set&gt;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> _name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="把数据发送到父组件"><a href="#把数据发送到父组件" class="headerlink" title="把数据发送到父组件"></a>把数据发送到父组件</h2><p>子组件或指令中的 @Output() 装饰器允许数据从子组件传给父组件。</p>
<p>@Output() 在子组件中标记了一个属性，作为数据从子组件传递到父组件的途径。</p>
<p>子组件使用 @Output() 属性来引发事件，以通知父组件这一变化。为了引发事件，@Output() 必须是 EventEmitter 类型，它是 @angular&#x2F;core 中用来发出自定义事件的类。</p>
<h3 id="配置子组件-1"><a href="#配置子组件-1" class="headerlink" title="配置子组件"></a>配置子组件</h3><p>子组件的模板有两个控件。第一个是带有模板引用变量 #newItem 的 <input>，用户可在其中输入条目名称。#newItem 变量的 value 属性存储了用户输入到 <input> 中的值。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;item-input&quot;</span>&gt;</span>Add an item:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;item-input&quot;</span> #<span class="attr">newItem</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> (<span class="attr">click</span>)=<span class="string">&quot;addNewItem(newItem.value)&quot;</span>&gt;</span>Add to parent&#x27;s list<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>(click) 事件绑定到了子组件类中 addNewItem() 方法。addNewItem() 方法接受一个 #newItem.value 属性的值作为参数。</p>
<p>在子组件类中导入 Output 和 EventEmitter，用 @Output() 装饰一个属性。下面的例子中 newItemEvent 这个 @Output() 的类型为 EventEmitter，这意味着它是一个事件。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ItemOutputComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Output</span>() newItemEvent = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addNewItem</span>(<span class="params">value: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newItemEvent</span>.<span class="title function_">emit</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>addNewItem() 函数使用 newItemEvent 这个 @Output() 来引发一个事件，该事件带有用户输入；</p>
<h3 id="配置父组件-1"><a href="#配置父组件-1" class="headerlink" title="配置父组件"></a>配置父组件</h3><p>在父模板中，把父组件的方法绑定到子组件的事件上。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-item-output</span> (<span class="attr">newItemEvent</span>)=<span class="string">&quot;addItem($event)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">app-item-output</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>事件绑定 (newItemEvent)&#x3D;’addItem($event)’ 会把子组件中的 newItemEvent 事件连接到父组件的 addItem() 方法。</p>
<p>$event 中包含用户在子组件模板上的 <input> 中键入的数据。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppComponent</span> &#123;</span><br><span class="line">  items = [<span class="string">&#x27;item1&#x27;</span>, <span class="string">&#x27;item2&#x27;</span>, <span class="string">&#x27;item3&#x27;</span>, <span class="string">&#x27;item4&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addItem</span>(<span class="params">newItem: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">push</span>(newItem);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>addItem() 方法接受一个字符串形式的参数，然后把该字符串添加到 items 数组中。</p>
<h2 id="父组件与子组件通过本地变量互动"><a href="#父组件与子组件通过本地变量互动" class="headerlink" title="父组件与子组件通过本地变量互动"></a>父组件与子组件通过本地变量互动</h2><p>父组件不能使用数据绑定来读取子组件的属性或调用子组件的方法。但可以在父组件模板里，新建一个本地变量来代表子组件，然后利用这个变量来读取子组件的属性和调用子组件的方法，如下例所示。</p>
<p>宿主组件 CountdownLocalVarParentComponent 如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CountdownTimerComponent</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./countdown-timer.component&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-countdown-parent-lv&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;h3&gt;Countdown to Liftoff (via local variable)&lt;/h3&gt;</span></span><br><span class="line"><span class="string">    &lt;button type=&quot;button&quot; (click)=&quot;timer.start()&quot;&gt;Start&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;button type=&quot;button&quot; (click)=&quot;timer.stop()&quot;&gt;Stop&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;seconds&quot;&gt;&#123;&#123;timer.seconds&#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;app-countdown-timer #timer&gt;&lt;/app-countdown-timer&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  <span class="attr">styleUrls</span>: [<span class="string">&#x27;../assets/demo.css&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">CountdownLocalVarParentComponent</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>子组件 CountdownTimerComponent 进行倒计时，归零时发射一个导弹。start 和 stop 方法负责控制时钟并在模板里显示倒计时的状态信息。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span>, <span class="title class_">OnDestroy</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-countdown-timer&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">CountdownTimerComponent</span> <span class="keyword">implements</span> <span class="title class_">OnDestroy</span> &#123;</span><br><span class="line"></span><br><span class="line">  intervalId = <span class="number">0</span>;</span><br><span class="line">  message = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  seconds = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">ngOnDestroy</span>(<span class="params"></span>) &#123; <span class="variable language_">this</span>.<span class="title function_">clearTimer</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">start</span>(<span class="params"></span>) &#123; <span class="variable language_">this</span>.<span class="title function_">countDown</span>(); &#125;</span><br><span class="line">  <span class="title function_">stop</span>(<span class="params"></span>)  &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">clearTimer</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">`Holding at T-<span class="subst">$&#123;<span class="variable language_">this</span>.seconds&#125;</span> seconds`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">clearTimer</span>(<span class="params"></span>) &#123; <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">intervalId</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">countDown</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">clearTimer</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">intervalId</span> = <span class="variable language_">window</span>.<span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">seconds</span> -= <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">seconds</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">&#x27;Blast off!&#x27;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">seconds</span> &lt; <span class="number">0</span>) &#123; <span class="variable language_">this</span>.<span class="property">seconds</span> = <span class="number">10</span>; &#125; <span class="comment">// reset</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">`T-<span class="subst">$&#123;<span class="variable language_">this</span>.seconds&#125;</span> seconds and counting`</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父组件不能通过数据绑定使用子组件的 start 和 stop 方法，也不能访问子组件的 seconds 属性。</p>
<p>把本地变量(#timer)放到(<app-countdown-timer>)标签中，用来代表子组件。这样父组件的模板就得到了子组件的引用，于是可以在父组件的模板中访问子组件的所有属性和方法。</app-countdown-timer></p>
<p>这个例子把父组件的按钮绑定到子组件的 start 和 stop 方法，并用插值来显示子组件的 seconds 属性。</p>
<h2 id="父级调用-ViewChild"><a href="#父级调用-ViewChild" class="headerlink" title="父级调用 @ViewChild()"></a>父级调用 @ViewChild()</h2><p>这个本地变量方法是个简单明了的方法。但是它也有局限性，因为父组件-子组件的连接必须全部在父组件的模板中进行。父组件本身的代码对子组件没有访问权。如果父组件的类需要依赖于子组件类，就不能使用本地变量方法。</p>
<p>当父组件类需要访问时子组件类时，可以把子组件作为 ViewChild，注入到父组件里面。</p>
<p>下面是父组件 CountdownViewChildParentComponent:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">AfterViewInit</span>, <span class="title class_">ViewChild</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CountdownTimerComponent</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./countdown-timer.component&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-countdown-parent-vc&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;h3&gt;Countdown to Liftoff (via ViewChild)&lt;/h3&gt;</span></span><br><span class="line"><span class="string">    &lt;button type=&quot;button&quot; (click)=&quot;start()&quot;&gt;Start&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;button type=&quot;button&quot; (click)=&quot;stop()&quot;&gt;Stop&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;seconds&quot;&gt;&#123;&#123; seconds() &#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;app-countdown-timer&gt;&lt;/app-countdown-timer&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  <span class="attr">styleUrls</span>: [<span class="string">&#x27;../assets/demo.css&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">CountdownViewChildParentComponent</span> <span class="keyword">implements</span> <span class="title class_">AfterViewInit</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ViewChild</span>(<span class="title class_">CountdownTimerComponent</span>)</span><br><span class="line">  <span class="keyword">private</span> timerComponent!: <span class="title class_">CountdownTimerComponent</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">seconds</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">ngAfterViewInit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// Redefine `seconds()` to get from the `CountdownTimerComponent.seconds` ...</span></span><br><span class="line">    <span class="comment">// but wait a tick first to avoid one-time devMode</span></span><br><span class="line">    <span class="comment">// unidirectional-data-flow-violation error</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="property">seconds</span> = <span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="property">timerComponent</span>.<span class="property">seconds</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">start</span>(<span class="params"></span>) &#123; <span class="variable language_">this</span>.<span class="property">timerComponent</span>.<span class="title function_">start</span>(); &#125;</span><br><span class="line">  <span class="title function_">stop</span>(<span class="params"></span>) &#123; <span class="variable language_">this</span>.<span class="property">timerComponent</span>.<span class="title function_">stop</span>(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把子组件的视图插入到父组件类需要做一点额外的工作。</p>
<p>首先，你必须导入对装饰器 ViewChild 以及生命周期钩子 AfterViewInit 的引用。</p>
<p>接着，通过 @ViewChild 属性装饰器，将子组件 CountdownTimerComponent 注入到私有属性 timerComponent 里面。</p>
<p>组件元数据里就不再需要 #timer 本地变量了。而是把按钮绑定到父组件自己的 start 和 stop 方法，使用父组件的 seconds 方法的插值来展示秒数变化。</p>
<p>这些方法可以直接访问被注入的计时器组件。</p>
<p>ngAfterViewInit() 生命周期钩子是非常重要的一步。被注入的计时器组件只有在 Angular 显示了父组件视图之后才能访问，所以它先把秒数显示为 0。</p>
<p>然后 Angular 会调用 ngAfterViewInit 生命周期钩子，但这时候再更新父组件视图的倒计时就已经太晚了。Angular 的单向数据流规则会阻止在同一个周期内更新父组件视图。应用在显示秒数之前会被迫再等一轮。</p>
<p>使用 setTimeout() 来等下一轮，然后改写 seconds() 方法，这样它接下来就会从注入的这个计时器组件里获取秒数的值。</p>
<h2 id="父组件和子组件通过服务来通讯"><a href="#父组件和子组件通过服务来通讯" class="headerlink" title="父组件和子组件通过服务来通讯"></a>父组件和子组件通过服务来通讯</h2><p>父组件和它的子组件共享同一个服务，利用该服务在组件家族内部实现双向通讯。</p>
<p>该服务实例的作用域被限制在父组件和其子组件内。这个组件子树之外的组件将无法访问该服务或者与它们通讯。</p>
<p>这个 MissionService 把 MissionControlComponent 和多个 AstronautComponent 子组件连接起来。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Injectable</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Subject</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">MissionService</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Observable string sources</span></span><br><span class="line">  <span class="keyword">private</span> missionAnnouncedSource = <span class="keyword">new</span> <span class="title class_">Subject</span>&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">  <span class="keyword">private</span> missionConfirmedSource = <span class="keyword">new</span> <span class="title class_">Subject</span>&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Observable string streams</span></span><br><span class="line">  missionAnnounced$ = <span class="variable language_">this</span>.<span class="property">missionAnnouncedSource</span>.<span class="title function_">asObservable</span>();</span><br><span class="line">  missionConfirmed$ = <span class="variable language_">this</span>.<span class="property">missionConfirmedSource</span>.<span class="title function_">asObservable</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Service message commands</span></span><br><span class="line">  <span class="title function_">announceMission</span>(<span class="params">mission: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">missionAnnouncedSource</span>.<span class="title function_">next</span>(mission);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">confirmMission</span>(<span class="params">astronaut: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">missionConfirmedSource</span>.<span class="title function_">next</span>(astronaut);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MissionControlComponent 提供服务的实例，并将其共享给它的子组件(通过 providers 元数据数组)，子组件可以通过构造函数将该实例注入到自身。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">MissionService</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./mission.service&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-mission-control&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;h2&gt;Mission Control&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;button type=&quot;button&quot; (click)=&quot;announce()&quot;&gt;Announce mission&lt;/button&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;app-astronaut</span></span><br><span class="line"><span class="string">      *ngFor=&quot;let astronaut of astronauts&quot;</span></span><br><span class="line"><span class="string">      [astronaut]=&quot;astronaut&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;/app-astronaut&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;h3&gt;History&lt;/h3&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">      &lt;li *ngFor=&quot;let event of history&quot;&gt;&#123;&#123;event&#125;&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  <span class="attr">providers</span>: [<span class="title class_">MissionService</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">MissionControlComponent</span> &#123;</span><br><span class="line">  astronauts = [<span class="string">&#x27;Lovell&#x27;</span>, <span class="string">&#x27;Swigert&#x27;</span>, <span class="string">&#x27;Haise&#x27;</span>];</span><br><span class="line">  <span class="attr">history</span>: <span class="built_in">string</span>[] = [];</span><br><span class="line">  missions = [<span class="string">&#x27;Fly to the moon!&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;Fly to mars!&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;Fly to Vegas!&#x27;</span>];</span><br><span class="line">  nextMission = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> missionService: MissionService</span>) &#123;</span><br><span class="line">    missionService.<span class="property">missionConfirmed$</span>.<span class="title function_">subscribe</span>(</span><br><span class="line">      <span class="function"><span class="params">astronaut</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">history</span>.<span class="title function_">push</span>(<span class="string">`<span class="subst">$&#123;astronaut&#125;</span> confirmed the mission`</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">announce</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> mission = <span class="variable language_">this</span>.<span class="property">missions</span>[<span class="variable language_">this</span>.<span class="property">nextMission</span>++];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">missionService</span>.<span class="title function_">announceMission</span>(mission);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">history</span>.<span class="title function_">push</span>(<span class="string">`Mission &quot;<span class="subst">$&#123;mission&#125;</span>&quot; announced`</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">nextMission</span> &gt;= <span class="variable language_">this</span>.<span class="property">missions</span>.<span class="property">length</span>) &#123; <span class="variable language_">this</span>.<span class="property">nextMission</span> = <span class="number">0</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AstronautComponent 也通过自己的构造函数注入该服务。由于每个 AstronautComponent 都是 MissionControlComponent 的子组件，所以它们获取到的也是父组件的这个服务实例。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span>, <span class="title class_">Input</span>, <span class="title class_">OnDestroy</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">MissionService</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./mission.service&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Subscription</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-astronaut&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;p&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123;astronaut&#125;&#125;: &lt;strong&gt;&#123;&#123;mission&#125;&#125;&lt;/strong&gt;</span></span><br><span class="line"><span class="string">      &lt;button</span></span><br><span class="line"><span class="string">        type=&quot;button&quot;</span></span><br><span class="line"><span class="string">        (click)=&quot;confirm()&quot;</span></span><br><span class="line"><span class="string">        [disabled]=&quot;!announced || confirmed&quot;&gt;</span></span><br><span class="line"><span class="string">        Confirm</span></span><br><span class="line"><span class="string">      &lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/p&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AstronautComponent</span> <span class="keyword">implements</span> <span class="title class_">OnDestroy</span> &#123;</span><br><span class="line">  <span class="meta">@Input</span>() astronaut = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  mission = <span class="string">&#x27;&lt;no mission announced&gt;&#x27;</span>;</span><br><span class="line">  confirmed = <span class="literal">false</span>;</span><br><span class="line">  announced = <span class="literal">false</span>;</span><br><span class="line">  <span class="attr">subscription</span>: <span class="title class_">Subscription</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> missionService: MissionService</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscription</span> = missionService.<span class="property">missionAnnounced$</span>.<span class="title function_">subscribe</span>(</span><br><span class="line">      <span class="function"><span class="params">mission</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">mission</span> = mission;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">announced</span> = <span class="literal">true</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">confirmed</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">confirm</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">confirmed</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">missionService</span>.<span class="title function_">confirmMission</span>(<span class="variable language_">this</span>.<span class="property">astronaut</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">ngOnDestroy</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// prevent memory leak when component destroyed</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscription</span>.<span class="title function_">unsubscribe</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>History 日志证明了：在父组件 MissionControlComponent 和子组件 AstronautComponent 之间，信息通过该服务实现了双向传递。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/03/01/expression/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/01/expression/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/" class="post-title-link" itemprop="url">表达式树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-03-01 12:31:32 / 修改时间：19:07:42" itemprop="dateCreated datePublished" datetime="2023-03-01T12:31:32+08:00">2023-03-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在创建 LINQ 查询时，通常使用 Lambda 表达式编写函数参数。 在典型的 LINQ 查询中，这些函数参数会被转换为编译器创建的委托。</p>
<p>当想要进行更丰富的交互时，需要使用表达式树。 表达式树将代码表示为可以检查、修改或执行的结构。 这些工具让你能够在运行时操作代码。 可以编写检查正在运行的算法的代码，或插入新的功能。 在更加高级的方案中，你可以修改正在运行的算法，甚至可以将 C# 表达式转换为另一种形式从而可在另一环境中执行。</p>
<h1 id="表达式树说明"><a href="#表达式树说明" class="headerlink" title="表达式树说明"></a>表达式树说明</h1><p>让我们来举一个简单的示例。 以下是一个代码行：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">1</span> + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>直观地看，整个语句是一棵树：应从根节点开始，浏览到树中的每个节点，以查看构成该语句的代码：</p>
<ul>
<li>具有赋值 (var sum &#x3D; 1 + 2;) 的变量声明语句<ul>
<li>隐式变量类型声明 (var sum)<ul>
<li>隐式 var 关键字 (var)</li>
<li>变量名称声明 (sum)</li>
</ul>
</li>
<li>赋值运算符 (&#x3D;)</li>
<li>二进制加法表达式 (1 + 2)<ul>
<li>左操作数 (1)</li>
<li>加法运算符 (+)</li>
<li>右操作数 (2)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>表达式树的结构非常一致。 了解基础知识后，你甚至可以理解以表达式树形式表示的最复杂的代码。 优美的数据结构说明了 C# 编译器如何分析最复杂的 C# 程序并从该复杂的源代码创建正确的输出。</p>
<p>不能执行的操作是修改表达式树。 表达式树是不可变的数据结构。 如果想要改变（更改）表达式树，则必须创建基于原始树副本但包含所需更改的新树。</p>
<h1 id="支持表达式树的框架类型"><a href="#支持表达式树的框架类型" class="headerlink" title="支持表达式树的框架类型"></a>支持表达式树的框架类型</h1><h2 id="这一切都始于-System-Linq-Expression"><a href="#这一切都始于-System-Linq-Expression" class="headerlink" title="这一切都始于 System.Linq.Expression"></a>这一切都始于 System.Linq.Expression</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Expression&lt;Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;&gt; addFive = (num) =&gt; num + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (addFive.NodeType == ExpressionType.Lambda)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> lambdaExp = (LambdaExpression)addFive;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> parameter = lambdaExp.Parameters.First();</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(parameter.Name);</span><br><span class="line">    Console.WriteLine(parameter.Type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如，此代码将打印变量访问表达式的变量的名称。 我的做法是，先查看节点类型，再转换为变量访问表达式，然后查看特定表达式类型的属性：</p>
<h2 id="创建表达式树"><a href="#创建表达式树" class="headerlink" title="创建表达式树"></a>创建表达式树</h2><p>System.Linq.Expression 类还包含许多创建表达式的静态方法。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Addition is an add expression for &quot;1 + 2&quot;</span></span><br><span class="line"><span class="keyword">var</span> one = Expression.Constant(<span class="number">1</span>, <span class="keyword">typeof</span>(<span class="built_in">int</span>));</span><br><span class="line"><span class="keyword">var</span> two = Expression.Constant(<span class="number">2</span>, <span class="keyword">typeof</span>(<span class="built_in">int</span>));</span><br><span class="line"><span class="keyword">var</span> addition = Expression.Add(one, two);</span><br></pre></td></tr></table></figure>

<h2 id="导航-API"><a href="#导航-API" class="headerlink" title="导航 API"></a>导航 API</h2><p>存在映射到 C# 语言的几乎所有语法元素的表达式节点类型。 每种类型都有针对该种语言元素的特定方法。 需要一次性记住的内容很多。 我不会记住所有内容，而是会采用有关使用表达式树的技巧，如下所示：</p>
<ul>
<li>查看 ExpressionType 枚举的成员以确定应检查的可能节点。 如果想要遍历和理解表达式树，这将非常有用。</li>
<li>查看 Expression 类的静态成员以生成表达式。 这些方法可以从其子节点集生成任何表达式类型。</li>
<li>查看 ExpressionVisitor 类，以生成一个经过修改的表达式树。</li>
</ul>
<h1 id="执行表达式树"><a href="#执行表达式树" class="headerlink" title="执行表达式树"></a>执行表达式树</h1><p>表达式树是表示一些代码的数据结构。 它不是已编译且可执行的代码。 如果想要执行由表达式树表示的 .NET 代码，则必须将其转换为可执行的 IL 指令。</p>
<h2 id="Lambda-表达式到函数"><a href="#Lambda-表达式到函数" class="headerlink" title="Lambda 表达式到函数"></a>Lambda 表达式到函数</h2><blockquote>
<p>可以将任何 LambdaExpression 或派生自 LambdaExpression 的任何类型转换为可执行的 IL。<br>其他表达式类型不能直接转换为代码。 此限制在实践中影响不大。<br>Lambda 表达式是你可通过转换为可执行的中间语言 (IL) 来执行的唯一表达式类型。 </p>
</blockquote>
<p>LambdaExpression 类型包含用于将表达式树转换为可执行代码的 Compile 和 CompileToMethod 成员。 Compile 方法创建委托。 CompileToMethod 方法通过表示表达式树的已编译输出的 IL 更新 MethodBuilder 对象。 </p>
<p>请注意，CompileToMethod 仅在完整的桌面框架中可用，不能用于 .NET Core。</p>
<p>使用下面的代码将表达式转换为委托：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Expression&lt;Func&lt;<span class="built_in">int</span>&gt;&gt; <span class="keyword">add</span> = () =&gt; <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> func = <span class="keyword">add</span>.Compile(); <span class="comment">// Create Delegate</span></span><br><span class="line"><span class="keyword">var</span> answer = func(); <span class="comment">// Invoke Delegate</span></span><br><span class="line">Console.WriteLine(answer);</span><br></pre></td></tr></table></figure>
<p>请注意，该委托类型基于表达式类型。 如果想要以强类型的方式使用委托对象，则必须知道返回类型和参数列表。 LambdaExpression.Compile() 方法返回 Delegate 类型。 必须将其转换为正确的委托类型，以便使任何编译时工具检查参数列表或返回类型。</p>
<p>在此提醒你不要通过避免不必要的编译调用尝试创建用于提高性能的任何更复杂的缓存机制。 比较两个任意的表达式树，以确定如果它们表示相同的算法，是否也会花费很长的时间来执行。 你可能会发现，通过避免对 LambdaExpression.Compile() 的任何额外调用所节省的计算时间将多于执行代码（该代码确定可导致相同可执行代码的两个不同表达式树）所花费的时间。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>将 lambda 表达式编译为委托并调用该委托是可对表达式树执行的最简单的操作之一。 但是，即使是执行这个简单的操作，也存在一些必须注意的事项。</p>
<p>Lambda 表达式将对表达式中引用的任何局部变量创建闭包。 必须保证作为委托的一部分的任何变量在调用 Compile 的位置处和执行结果委托时可用。</p>
<p>一般情况下，编译器会确保这一点。 但是，如果表达式访问实现 IDisposable 的变量，则代码可能在表达式树仍保留有对象时释放该对象。</p>
<p>例如，此代码工作正常，因为 int 不实现 IDisposable：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; <span class="title">CreateBoundFunc</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> constant = <span class="number">5</span>; <span class="comment">// constant is captured by the expression tree</span></span><br><span class="line">    Expression&lt;Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;&gt; expression = (b) =&gt; constant + b;</span><br><span class="line">    <span class="keyword">var</span> rVal = expression.Compile();</span><br><span class="line">    <span class="keyword">return</span> rVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>委托已捕获对局部变量 constant 的引用。 在稍后执行 CreateBoundFunc 返回的函数之后，可随时访问该变量。</p>
<p>但是，请考虑实现 IDisposable 的此（人为设计的）类：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Resource</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isDisposed = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Argument</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isDisposed)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> ObjectDisposedException(<span class="string">&quot;Resource&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        isDisposed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果将其用于如下所示的表达式中，则在执行 Resource.Argument 属性引用的代码时将出现 ObjectDisposedException：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; <span class="title">CreateBoundResource</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> constant = <span class="keyword">new</span> Resource()) <span class="comment">// constant is captured by the expression tree</span></span><br><span class="line">    &#123;</span><br><span class="line">        Expression&lt;Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;&gt; expression = (b) =&gt; constant.Argument + b;</span><br><span class="line">        <span class="keyword">var</span> rVal = expression.Compile();</span><br><span class="line">        <span class="keyword">return</span> rVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从此方法返回的委托已对释放了的 constant 对象闭包。 （它已被释放，因为它已在 using 语句中进行声明。）</p>
<p>现在，在执行从此方法返回的委托时，将在执行时引发 ObjectDisposedException。</p>
<p>定义表达式时，请谨慎访问局部变量，且在创建可由公共 API 返回的表达式树时，谨慎访问当前对象（由 this 表示）中的状态。</p>
<p>表达式中的代码可能引用其他程序集中的方法或属性。 对表达式进行定义、编译或在调用结果委托时，该程序集必须可访问。 在它不存在的情况下，将遇到 ReferencedAssemblyNotFoundException。</p>
<h1 id="生成表达式树"><a href="#生成表达式树" class="headerlink" title="生成表达式树"></a>生成表达式树</h1><p>到目前为止，你所看到的所有表达式树都是由 C# 编译器创建的。 你所要做的是创建一个 lambda 表达式，将其分配给一个类型为 Expression&lt;Func<T>&gt; 或某种相似类型的变量。 这不是创建表达式树的唯一方法。 很多情况下，可能需要在运行时在内存中生成一个表达式。</T></p>
<p>由于这些表达式树是不可变的，所以生成表达式树很复杂。 不可变意味着必须以从叶到根的方式生成表达式树。 用于生成表达式树的 API 体现了这一点：用于生成节点的方法将其所有子级用作参数。 让我们通过几个示例来了解相关技巧。</p>
<h2 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h2><p>让我们再次从相对简单的内容开始。 我们将使用在这些部分中一直使用的加法表达式：</p>
<h2 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h2><p>这是在内存中生成表达式树的基础知识。 更复杂的树通常意味着更多的节点类型，并且树中有更多的节点。 让我们再浏览一个示例，了解通常在创建表达式树时创建的其他两个节点类型：参数节点和方法调用节点。</p>
<p>生成一个表达式树以创建此表达式：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expression&lt;Func&lt;<span class="built_in">double</span>, <span class="built_in">double</span>, <span class="built_in">double</span>&gt;&gt; distanceCalc =</span><br><span class="line">    (x, y) =&gt; Math.Sqrt(x * x + y * y);</span><br></pre></td></tr></table></figure>
<p>首先，创建 x 和 y 的参数表达式：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xParameter = Expression.Parameter(<span class="keyword">typeof</span>(<span class="built_in">double</span>), <span class="string">&quot;x&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> yParameter = Expression.Parameter(<span class="keyword">typeof</span>(<span class="built_in">double</span>), <span class="string">&quot;y&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>按照你所看到的模式创建乘法和加法表达式：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xSquared = Expression.Multiply(xParameter, xParameter);</span><br><span class="line"><span class="keyword">var</span> ySquared = Expression.Multiply(yParameter, yParameter);</span><br><span class="line"><span class="keyword">var</span> sum = Expression.Add(xSquared, ySquared);</span><br></pre></td></tr></table></figure>
<p>接下来，需要为调用 Math.Sqrt 创建方法调用表达式。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sqrtMethod = <span class="keyword">typeof</span>(Math).GetMethod(<span class="string">&quot;Sqrt&quot;</span>, <span class="keyword">new</span>[] &#123; <span class="keyword">typeof</span>(<span class="built_in">double</span>) &#125;);</span><br><span class="line"><span class="keyword">var</span> distance = Expression.Call(sqrtMethod, sum);</span><br></pre></td></tr></table></figure>
<p>最后，将方法调用放入 Lambda 表达式，并确保定义 Lambda 表达式的参数：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> distanceLambda = Expression.Lambda(</span><br><span class="line">    distance,</span><br><span class="line">    xParameter,</span><br><span class="line">    yParameter);</span><br></pre></td></tr></table></figure>
<p>在这个更复杂的示例中，你看到了创建表达式树通常使用的其他几种技巧。</p>
<p>首先，在使用它们之前，需要创建表示参数或局部变量的对象。 创建这些对象后，可以在表达式树中任何需要的位置使用它们。</p>
<p>其次，需要使用反射 API 的一个子集来创建 MethodInfo 对象，以便创建表达式树以访问该方法。 必须仅限于 .NET Core 平台上提供的反射 API 的子集。 同样，这些技术将扩展到其他表达式树。</p>
<h2 id="深度生成代码"><a href="#深度生成代码" class="headerlink" title="深度生成代码"></a>深度生成代码</h2><p>不仅限于使用这些 API 可以生成的代码。 但是，要生成的表达式树越复杂，代码就越难以管理和阅读。</p>
<p>让我们生成一个与此代码等效的表达式树：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; factorialFunc = (n) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res = res * n;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>请注意上面我未生成表达式树，只是生成了委托。 使用 Expression 类不能生成语句 lambda。 下面是生成相同的功能所需的代码。 它很复杂，这是因为没有用于生成 while 循环的 API，而是需要生成一个包含条件测试的循环和一个用于中断循环的标签目标。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nArgument = Expression.Parameter(<span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="string">&quot;n&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> result = Expression.Variable(<span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="string">&quot;result&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creating a label that represents the return value</span></span><br><span class="line">LabelTarget label = Expression.Label(<span class="keyword">typeof</span>(<span class="built_in">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> initializeResult = Expression.Assign(result, Expression.Constant(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is the inner block that performs the multiplication,</span></span><br><span class="line"><span class="comment">// and decrements the value of &#x27;n&#x27;</span></span><br><span class="line"><span class="keyword">var</span> block = Expression.Block(</span><br><span class="line">    Expression.Assign(result,</span><br><span class="line">        Expression.Multiply(result, nArgument)),</span><br><span class="line">    Expression.PostDecrementAssign(nArgument)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creating a method body.</span></span><br><span class="line">BlockExpression body = Expression.Block(</span><br><span class="line">    <span class="keyword">new</span>[] &#123; result &#125;,</span><br><span class="line">    initializeResult,</span><br><span class="line">    Expression.Loop(</span><br><span class="line">        Expression.IfThenElse(</span><br><span class="line">            Expression.GreaterThan(nArgument, Expression.Constant(<span class="number">1</span>)),</span><br><span class="line">            block,</span><br><span class="line">            Expression.Break(label, result)</span><br><span class="line">        ),</span><br><span class="line">        label</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>用于生成阶乘函数的表达式树的代码相对更长、更复杂，它充满了标签和 break 语句以及我们在日常编码任务中想要避免的其他元素。</p>
<h1 id="转换表达式树"><a href="#转换表达式树" class="headerlink" title="转换表达式树"></a>转换表达式树</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/02/28/linq/LINQ-TO-SQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/28/linq/LINQ-TO-SQL/" class="post-title-link" itemprop="url">LINQ TO SQL</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-28 17:26:36" itemprop="dateCreated datePublished" datetime="2023-02-28T17:26:36+08:00">2023-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-01 12:30:53" itemprop="dateModified" datetime="2023-03-01T12:30:53+08:00">2023-03-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>通过使用 LINQ to SQL，可以使用 LINQ 技术访问 SQL 数据库，就像访问内存中的集合一样。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/02/16/angular/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/16/angular/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/" class="post-title-link" itemprop="url">依赖注入</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-16 13:16:46" itemprop="dateCreated datePublished" datetime="2023-02-16T13:16:46+08:00">2023-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-23 17:57:06" itemprop="dateModified" datetime="2024-01-23T17:57:06+08:00">2024-01-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>@Injectable() 装饰器把一个类定义为 Angular 中的服务，并且允许 Angular 把它作为依赖注入到组件中。 类似的，@Injectable() 装饰器会标记出某个组件、类、管道或 NgModule 具有对某个服务的依赖。</p>
<ul>
<li>Angular 会在启动过程中为你创建全应用级注入器以及所需的其它注入器。你不用自己创建注入器。</li>
<li>该注入器会创建依赖、维护一个容器来管理这些依赖，并尽可能复用它们。</li>
<li>提供者(provider)是一个对象，用来告诉注入器应该如何获取或创建依赖</li>
</ul>
<p>你的应用中所需的任何依赖，都必须使用该应用的注入器来注册一个提供者，以便注入器可以使用这个提供者来创建新实例。对于服务，该提供者通常就是服务类本身。</p>
<blockquote>
<p>依赖不一定是服务 —— 它还可能是函数或值。</p>
</blockquote>
<p>当 Angular 创建组件类的新实例时，它会通过查看该组件类的构造函数，来决定该组件依赖哪些服务或其它依赖项。比如 HeroListComponent 的构造函数中需要 HeroService：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> service: HeroService</span>) &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>当 Angular 发现某个组件依赖某个服务时，它会首先检查是否该注入器中已经有了那个服务的任何现有实例。如果所请求的服务尚不存在，注入器就会使用以前注册的服务提供者来制作一个，并把它加入注入器中，然后把该服务返回给 Angular。</p>
<h1 id="Angular-如何知道-class-有哪些依赖？"><a href="#Angular-如何知道-class-有哪些依赖？" class="headerlink" title="Angular 如何知道 class 有哪些依赖？"></a>Angular 如何知道 class 有哪些依赖？</h1><p>JS 没有反射，那 Angular 怎么能从 ServiceB 的 constructor 感知到其依赖 ServiceA 呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ServiceB</span> &#123;</span><br><span class="line">  constructor(serviceA: ServiceA) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案是黑魔法 Compilation。 ServiceB 经过 compile 后会变成这样</p>
<p><img src="d884e55cc9e0bb48b83fc367a4c94e435698c8f51a669624a6f8ac2bec73ff42.png" alt="图 0">  </p>
<p>它多了一个 ɵfac 静态方法。</p>
<p>从代码上可以推测出 injector.get(ServiceB)，其实并不是直接执行了 new ServiceB(new ServiceA())，它只是调用了 ServiceB.ɵfac()。</p>
<p>而 ɵfac 内容才是 new ServiceB( inject(ServiceA) )。这句代码便是 compiler 透过反射 constructor 得知 ServiceB 依赖 ServiceA 后写出来的。</p>
<p>另外，inject(ServiceA) 是一个递归实例化依赖函数，里面一定是调用了 ServiceA.ɵfac()。以此类推，一直到所有的依赖全部被实例化。</p>
<p>简而言之，虽然 JS 没有反射，但是 Angular compiler 可以反射，然后自动编写出实例化依赖的代码。这就是 Angular DI 的实现秘诀啦。</p>
<h1 id="提供服务范围"><a href="#提供服务范围" class="headerlink" title="提供服务范围"></a>提供服务范围</h1><p>对于要用到的任何服务，你必须至少注册一个提供者。服务可以在自己的元数据中把自己注册为提供者，这样可以让自己随处可用。或者，你也可以为特定的模块或组件注册提供者。要注册提供者，就要在服务的 @Injectable() 装饰器中提供它的元数据，或者在 @NgModule() 或 @Component() 的元数据中。</p>
<ul>
<li>默认情况下，Angular CLI 的 ng generate service 命令会在 @Injectable() 装饰器中提供元数据来把它注册到根注入器中。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Injectable</span>(&#123;</span><br><span class="line"> <span class="attr">providedIn</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当你在根一级提供服务时，Angular 会为 HeroService 创建一个单一的共享实例，并且把它注入到任何想要它的类中。</p>
<p>这种在 @Injectable 元数据中注册提供者的方式还让 Angular 能够通过移除那些从未被用过的服务来优化大小,这个过程称为摇树优化（tree-shaking）。</p>
<ul>
<li>当你使用特定的 NgModule 注册提供者时，该服务的同一个实例将会对该 NgModule 中的所有组件可用。要想在这一层注册，请用 @NgModule() 装饰器中的 providers 属性：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  <span class="attr">providers</span>: [</span><br><span class="line">  <span class="title class_">BackendService</span>,</span><br><span class="line">  <span class="title class_">Logger</span></span><br><span class="line"> ],</span><br><span class="line"> …</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>当你在组件级注册提供者时，你会为该组件的每一个新实例提供该服务的一个新实例。要在组件级注册，就要在 @Component() 元数据的 providers 属性中注册服务提供者。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>:    <span class="string">&#x27;app-hero-list&#x27;</span>,</span><br><span class="line">  <span class="attr">templateUrl</span>: <span class="string">&#x27;./hero-list.component.html&#x27;</span>,</span><br><span class="line">  <span class="attr">providers</span>:  [ <span class="title class_">HeroService</span> ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="抽象理解-provider-和-injector"><a href="#抽象理解-provider-和-injector" class="headerlink" title="抽象理解 provider 和 injector"></a>抽象理解 provider 和 injector</h1><h2 id="provider-的特性"><a href="#provider-的特性" class="headerlink" title="provider 的特性"></a>provider 的特性</h2><p>抽象的看，provider 是一个 key value pair 对象。</p>
<p>key 的作用是为了识别。</p>
<p>value 则是一个提供最终值的 factory 函数。</p>
<p>只要能满足这 2 点，那它就可以被作为 provider。</p>
<h2 id="Injector-的特性"><a href="#Injector-的特性" class="headerlink" title="Injector 的特性"></a>Injector 的特性</h2><p>Injector 不仅仅是实例化机器。</p>
<p>抽象的看，injector 第一个任务是通过 key 查找出指定的 provider，这个 key 只要具备可识别性就可以了。比如：string，class，symbol 等等都具备识别性。</p>
<p>第二个任务是通过 provider value factory 生产出最终的值。当然如果这个 factory 需要依赖，injector 会先查找它所需要的依赖，注入给 factory 函数。</p>
<h2 id="Provider-amp-StaticProvider"><a href="#Provider-amp-StaticProvider" class="headerlink" title="Provider &amp; StaticProvider"></a>Provider &amp; StaticProvider</h2><p>Injector.create 的 interface 长这样<br><img src="a6ce3607b7544cf3dde1e291f3bb1b77f26677400cd4f615fbb269a50763b9ec.png" alt="图 1">  </p>
<p>Angular 有多种不同形态的 Provider.<br>Provider 和 StaticProvider 是所有 Provider 的抽象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Provider</span> = <span class="title class_">TypeProvider</span> | <span class="title class_">ValueProvider</span> | <span class="title class_">ClassProvider</span> | <span class="title class_">ConstructorProvider</span> | <span class="title class_">ExistingProvider</span> | <span class="title class_">FactoryProvider</span> | any[];</span><br><span class="line"></span><br><span class="line">type <span class="title class_">StaticProvider</span> = <span class="title class_">ValueProvider</span> | <span class="title class_">ExistingProvider</span> | <span class="title class_">StaticClassProvider</span> | <span class="title class_">ConstructorProvider</span> | <span class="title class_">FactoryProvider</span> | any[];</span><br></pre></td></tr></table></figure>
<p>它俩是有重叠的，总的来说是 TypeProvider、ClassProvider、StaticClassProvider、ConstructorProvider、FactoryProvider、ValueProvider、ExistingProvider。</p>
<h1 id="配置依赖提供者"><a href="#配置依赖提供者" class="headerlink" title="配置依赖提供者"></a>配置依赖提供者</h1><p>你还可以用其他值作为依赖项，例如 Boolean、字符串、日期和对象。 Angular DI 提供了一些必要的 API 来让依赖的配置方式更加灵活，以便你可以把这些值在 DI 中可用。</p>
<h2 id="指定提供者令牌"><a href="#指定提供者令牌" class="headerlink" title="指定提供者令牌"></a>指定提供者令牌</h2><p>如果你用服务类作为提供者令牌，则其默认行为是注入器使用 new 运算符实例化该类。</p>
<p>在下面这个例子中，Logger 类提供了 Logger 的实例。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">providers</span>: [<span class="title class_">Logger</span>]</span><br></pre></td></tr></table></figure>
<p>但是，你可以将 DI 配置为使用不同的类或任何其他不同的值来与 Logger 类关联。因此，当注入 Logger 时，会改为使用这个新值。</p>
<p>实际上，类提供者语法是一个简写表达式，可以扩展为由 Provider 接口定义的提供者配置信息。</p>
<p>在这种情况下，Angular 将 providers 值展开为完整的提供者对象，如下所示：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123; <span class="attr">provide</span>: <span class="title class_">Logger</span>, <span class="attr">useClass</span>: <span class="title class_">Logger</span> &#125;]</span><br></pre></td></tr></table></figure>
<p>展开后的提供者配置是一个具有两个属性的对象字面量：</p>
<ul>
<li><p>provide 属性包含一个令牌，该令牌会作为定位依赖值和配置注入器时的键。</p>
</li>
<li><p>第二个属性是一个提供者定义对象，它会告诉注入器如何创建依赖值。 提供者定义对象中的键可以是以下值之一：</p>
<ul>
<li><p>useClass -此选项告诉 Angular DI 在注入依赖项时要实例化这里提供的类</p>
</li>
<li><p>useExisting - 允许你为令牌起一个别名，并引用任意一个现有令牌。</p>
</li>
<li><p>useFactory - 允许你定义一个用来构造依赖项的函数</p>
</li>
<li><p>useValue - 提供了一个应该作为依赖项使用的静态值。</p>
</li>
</ul>
</li>
</ul>
<p>下面的部分介绍如何使用这里所说的“提供者定义”键。</p>
<h3 id="类提供者：useClass"><a href="#类提供者：useClass" class="headerlink" title="类提供者：useClass"></a>类提供者：useClass</h3><p>useClass 能让你创建并返回指定类的新实例。</p>
<p>你可以用这种类型的提供者来作为通用类或默认类的替代实现。<br>例如，替代实现可以实现不同的策略、扩展默认类或模拟测试用例中真实类的行为。在以下示例中，当在组件或任何其他类中请求 Logger 依赖项时，将转而实例化 BetterLogger 类。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123; <span class="attr">provide</span>: <span class="title class_">Logger</span>, <span class="attr">useClass</span>: <span class="title class_">BetterLogger</span> &#125;]</span><br></pre></td></tr></table></figure>
<p>如果替代类提供者有自己的依赖项，请在父模块或组件的 providers 元数据属性中指定这两个提供者。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="title class_">UserService</span>,</span><br><span class="line">&#123; <span class="attr">provide</span>: <span class="title class_">Logger</span>, <span class="attr">useClass</span>: <span class="title class_">EvenBetterLogger</span> &#125;]</span><br></pre></td></tr></table></figure>
<p>在这个例子中，EvenBetterLogger 会在日志信息里显示用户名。这个 logger 要从注入的 UserService 实例中来获取该用户。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">EvenBetterLogger</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Logger</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> userService: UserService</span>) &#123; <span class="variable language_">super</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="title function_">log</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="variable language_">this</span>.<span class="property">userService</span>.<span class="property">user</span>.<span class="property">name</span>;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">log</span>(<span class="string">`Message to <span class="subst">$&#123;name&#125;</span>: <span class="subst">$&#123;message&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="别名提供者：useExisting"><a href="#别名提供者：useExisting" class="headerlink" title="别名提供者：useExisting"></a>别名提供者：useExisting</h3><p>useExisting 允许你将一个令牌映射到另一个。实际上，第一个令牌是与第二个令牌关联的服务的别名，创建了两种访问同一个服务对象的方式。</p>
<p>在下面的例子中，当组件请求新的或旧的记录器时，注入器都会注入一个 NewLogger 的实例。通过这种方式，OldLogger 就成了 NewLogger 的别名。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="title class_">NewLogger</span>,</span><br><span class="line">  <span class="comment">// Alias OldLogger w/ reference to NewLogger</span></span><br><span class="line">  &#123; <span class="attr">provide</span>: <span class="title class_">OldLogger</span>, <span class="attr">useExisting</span>: <span class="title class_">NewLogger</span>&#125;]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>确保你没有使用 OldLogger 将 NewLogger 别名为 useClass ，因为这会创建两个不同 NewLogger 实例。</p>
</blockquote>
<h3 id="工厂提供者：useFactory"><a href="#工厂提供者：useFactory" class="headerlink" title="工厂提供者：useFactory"></a>工厂提供者：useFactory</h3><p>useFactory 允许你通过调用工厂函数来创建依赖对象。使用这种方法，你可以根据 DI 和应用程序中其他地方的可用信息创建动态值。</p>
<p>在下面的例子中，只有授权用户才能看到 HeroService 中的秘密英雄。授权可能在单个应用会话期间发生变化，比如改用其他用户登录。</p>
<p>要想在 UserService 和 HeroService 中保存敏感信息，就要给 HeroService 的构造函数传一个逻辑标志来控制秘密英雄的显示。</p>
<blockquote>
<p>hero.service.ts</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="keyword">private</span> logger: Logger,</span></span><br><span class="line"><span class="params">  <span class="keyword">private</span> isAuthorized: <span class="built_in">boolean</span></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getHeroes</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> auth = <span class="variable language_">this</span>.<span class="property">isAuthorized</span> ? <span class="string">&#x27;authorized &gt; &#x27;</span> : <span class="string">&#x27;unauthorized&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">logger</span>.<span class="title function_">log</span>(<span class="string">`Getting heroes for <span class="subst">$&#123;auth&#125;</span> user.`</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="variable constant_">HEROES</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">hero</span> =&gt;</span> <span class="variable language_">this</span>.<span class="property">isAuthorized</span> || !hero.<span class="property">isSecret</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要实现 isAuthorized 标志，可以用工厂提供者来为 HeroService 创建一个新的 logger 实例。</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">heroServiceFactory</span> = (<span class="params">logger: Logger, userService: UserService</span>) =&gt;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">HeroService</span>(logger, userService.<span class="property">user</span>.<span class="property">isAuthorized</span>);</span><br></pre></td></tr></table></figure>
<p>这个工厂函数可以访问 UserService。你可以同时把 Logger 和 UserService 注入到工厂提供者中，这样注入器就可以把它们传给工厂函数了。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> heroServiceProvider =</span><br><span class="line">  &#123; <span class="attr">provide</span>: <span class="title class_">HeroService</span>,</span><br><span class="line">    <span class="attr">useFactory</span>: heroServiceFactory,</span><br><span class="line">    <span class="attr">deps</span>: [<span class="title class_">Logger</span>, <span class="title class_">UserService</span>]</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>useFactory 字段指定该提供者是一个工厂函数，其实现代码是 heroServiceFactory。</p>
</li>
<li><p>deps 属性是一个提供者令牌的数组。 Logger 和 UserService 类作为它们自己的类提供者的令牌。注入器会解析这些令牌，并将相应的服务注入到匹配的 heroServiceFactory 工厂函数参数中。</p>
</li>
</ul>
<p>通过把工厂提供者导出为变量 heroServiceProvider，就能让工厂提供者变得可复用。</p>
<h3 id="值提供者：useValue"><a href="#值提供者：useValue" class="headerlink" title="值提供者：useValue"></a>值提供者：useValue</h3><p>useValue 允许你将固定值与某个 DI 令牌相关联。可以用此技术提供运行时配置常量，例如网站基址和特性标志。你还可以在单元测试中使用值提供者来提供模拟数据以代替生产级数据服务。</p>
<h2 id="使用-InjectionToken-对象"><a href="#使用-InjectionToken-对象" class="headerlink" title="使用 InjectionToken 对象"></a>使用 InjectionToken 对象</h2><p>可以定义和使用一个 InjectionToken 对象来为非类的依赖选择一个提供者令牌。下列例子定义了一个类型为 InjectionToken 的 APP_CONFIG。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">InjectionToken</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">APP_CONFIG</span> = <span class="keyword">new</span> <span class="title class_">InjectionToken</span>&lt;<span class="title class_">AppConfig</span>&gt;(<span class="string">&#x27;app.config&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>可选的参数 <AppConfig> 和令牌描述 app.config 指明了此令牌的用途。</AppConfig></p>
<p>接着，用 APP_CONFIG 这个 InjectionToken 对象在组件中注册依赖提供者。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">providers</span>: [&#123; <span class="attr">provide</span>: <span class="variable constant_">APP_CONFIG</span>, <span class="attr">useValue</span>: <span class="variable constant_">HERO_DI_CONFIG</span> &#125;]</span><br></pre></td></tr></table></figure>
<p>现在，借助参数装饰器 @Inject()，你可以把这个配置对象注入到构造函数中。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params"><span class="meta">@Inject</span>(APP_CONFIG) config: AppConfig</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">title</span> = config.<span class="property">title</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="使用参数装饰器来限定依赖查找方式"><a href="#使用参数装饰器来限定依赖查找方式" class="headerlink" title="使用参数装饰器来限定依赖查找方式"></a>使用参数装饰器来限定依赖查找方式</h1><p>默认情况下，DI 框架会在注入器树中查找一个提供者，从该组件的局部注入器开始，如果需要，则沿着注入器树向上冒泡，直到根注入器。</p>
<ul>
<li><p>第一个配置过该提供者的注入器就会把依赖（服务实例或值）提供给这个构造函数</p>
</li>
<li><p>如果在根注入器中也没有找到提供者，则 DI 框架将会抛出一个错误</p>
</li>
</ul>
<p>通过在类的构造函数中对服务参数使用参数装饰器，可以提供一些选项来修改默认的搜索行为。</p>
<h2 id="用-Optional-来让依赖是可选的，以及使用-Host-来限定搜索方式"><a href="#用-Optional-来让依赖是可选的，以及使用-Host-来限定搜索方式" class="headerlink" title="用 @Optional 来让依赖是可选的，以及使用 @Host 来限定搜索方式"></a>用 @Optional 来让依赖是可选的，以及使用 @Host 来限定搜索方式</h2><p>某些情况下，你需要限制搜索，或容忍依赖项的缺失。你可以使用组件构造函数参数上的 @Host 和 @Optional 这两个限定装饰器来修改 Angular 的搜索行为。</p>
<ul>
<li><p>@Optional 属性装饰器告诉 Angular 当找不到依赖时就返回 null</p>
</li>
<li><p>@Host 属性装饰器会禁止在宿主组件以上的搜索。宿主组件通常就是请求该依赖的那个组件。不过，当该组件投影进某个父组件时，那个父组件就会变成宿主。</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template: `</span><br><span class="line">  <span class="tag">&lt;<span class="name">app-hero-bio</span> [<span class="attr">heroId</span>]=<span class="string">&quot;1&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">app-hero-contact</span>&gt;</span><span class="tag">&lt;/<span class="name">app-hero-contact</span>&gt;</span> <span class="tag">&lt;/<span class="name">app-hero-bio</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-hero-bio</span> [<span class="attr">heroId</span>]=<span class="string">&quot;2&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">app-hero-contact</span>&gt;</span><span class="tag">&lt;/<span class="name">app-hero-contact</span>&gt;</span> <span class="tag">&lt;/<span class="name">app-hero-bio</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-hero-bio</span> [<span class="attr">heroId</span>]=<span class="string">&quot;3&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">app-hero-contact</span>&gt;</span><span class="tag">&lt;/<span class="name">app-hero-contact</span>&gt;</span> <span class="tag">&lt;/<span class="name">app-hero-bio</span>&gt;</span>`,</span><br></pre></td></tr></table></figure>
<p>  在 <hero-bio> 标签中是一个新的 <hero-contact> 元素。Angular 就会把相应的 HeroContactComponent投影(transclude)进 HeroBioComponent 的视图里，将它放在 HeroBioComponent 模板的 <ng-content> 标签槽里。<br>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template: `</span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;&#123;hero.name&#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ng-content</span>&gt;</span><span class="tag">&lt;/<span class="name">ng-content</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">cols</span>=<span class="string">&quot;25&quot;</span> [(<span class="attr">ngModel</span>)]=<span class="string">&quot;hero.description&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span>`,</span><br></pre></td></tr></table></figure></ng-content></hero-contact></hero-bio></p>
<h2 id="使用-Inject-指定自定义提供者"><a href="#使用-Inject-指定自定义提供者" class="headerlink" title="使用 @Inject 指定自定义提供者"></a>使用 @Inject 指定自定义提供者</h2><p>  自定义提供者让你可以为隐式依赖提供一个具体的实现，比如内置浏览器 API。下面的例子使用 InjectionToken 来提供 localStorage，将其作为 BrowserStorageService 的依赖项。<br>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">import</span> &#123; <span class="title class_">Inject</span>, <span class="title class_">Injectable</span>, <span class="title class_">InjectionToken</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">BROWSER_STORAGE</span> = <span class="keyword">new</span> <span class="title class_">InjectionToken</span>&lt;<span class="title class_">Storage</span>&gt;(<span class="string">&#x27;Browser Storage&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">providedIn</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">  <span class="attr">factory</span>: <span class="function">() =&gt;</span> <span class="variable language_">localStorage</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>(&#123;</span><br><span class="line">  <span class="attr">providedIn</span>: <span class="string">&#x27;root&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">BrowserStorageService</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="meta">@Inject</span>(BROWSER_STORAGE) <span class="keyword">public</span> storage: Storage</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">key: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">storage</span>.<span class="title function_">getItem</span>(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">key: <span class="built_in">string</span>, value: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">storage</span>.<span class="title function_">setItem</span>(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">remove</span>(<span class="params">key: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">storage</span>.<span class="title function_">removeItem</span>(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">storage</span>.<span class="title function_">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>factory 函数返回 window 对象上的 localStorage 属性。Inject 装饰器修饰一个构造函数参数，用于为某个依赖提供自定义提供者。</p>
<h2 id="使用-Self-和-SkipSelf-来修改提供者的搜索方式"><a href="#使用-Self-和-SkipSelf-来修改提供者的搜索方式" class="headerlink" title="使用 @Self 和 @SkipSelf 来修改提供者的搜索方式"></a>使用 @Self 和 @SkipSelf 来修改提供者的搜索方式</h2><p>注入器也可以通过构造函数的参数装饰器来指定范围。下面的例子就在 Component 类的 providers 中使用浏览器的 sessionStorage API 覆盖了 BROWSER_STORAGE 令牌。同一个 BrowserStorageService 在构造函数中使用 @Self 和 @SkipSelf 装饰器注入了两次，来分别指定由哪个注入器来提供依赖。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span>, <span class="title class_">OnInit</span>, <span class="title class_">Self</span>, <span class="title class_">SkipSelf</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">BROWSER_STORAGE</span>, <span class="title class_">BrowserStorageService</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./storage.service&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-storage&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    Open the inspector to see the local/session storage keys:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;h3&gt;Session Storage&lt;/h3&gt;</span></span><br><span class="line"><span class="string">    &lt;button type=&quot;button&quot; (click)=&quot;setSession()&quot;&gt;Set Session Storage&lt;/button&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;h3&gt;Local Storage&lt;/h3&gt;</span></span><br><span class="line"><span class="string">    &lt;button type=&quot;button&quot; (click)=&quot;setLocal()&quot;&gt;Set Local Storage&lt;/button&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  <span class="attr">providers</span>: [</span><br><span class="line">    <span class="title class_">BrowserStorageService</span>,</span><br><span class="line">    &#123; <span class="attr">provide</span>: <span class="variable constant_">BROWSER_STORAGE</span>, <span class="attr">useFactory</span>: <span class="function">() =&gt;</span> sessionStorage &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">StorageComponent</span> <span class="keyword">implements</span> <span class="title class_">OnInit</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="meta">@Self</span>() <span class="keyword">private</span> sessionStorageService: BrowserStorageService,</span></span><br><span class="line"><span class="params">    <span class="meta">@SkipSelf</span>() <span class="keyword">private</span> localStorageService: BrowserStorageService,</span></span><br><span class="line"><span class="params">  </span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">ngOnInit</span>(<span class="params"></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setSession</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sessionStorageService</span>.<span class="title function_">set</span>(<span class="string">&#x27;hero&#x27;</span>, <span class="string">&#x27;Dr Nice - Session&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setLocal</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">localStorageService</span>.<span class="title function_">set</span>(<span class="string">&#x27;hero&#x27;</span>, <span class="string">&#x27;Dr Nice - Local&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 @Self 装饰器时，注入器只在该组件的注入器中查找提供者。@SkipSelf 装饰器可以让你跳过局部注入器，并在注入器树中向上查找，以发现哪个提供者满足该依赖。sessionStorageService 实例使用浏览器的 sessionStorage 来跟 BrowserStorageService 打交道，而 localStorageService 跳过了局部注入器，使用根注入器提供的 BrowserStorageService，它使用浏览器的 localStorage API。</p>
<h1 id="注入器层次结构的类型"><a href="#注入器层次结构的类型" class="headerlink" title="注入器层次结构的类型"></a>注入器层次结构的类型</h1><p>Angular 中有两个注入器层次结构：</p>
<table>
<thead>
<tr>
<th>注入器层次结构</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td>ModuleInjector 层次结构</td>
<td>使用 @NgModule() 或 @Injectable() 注解在此层次结构中配置 ModuleInjector。</td>
</tr>
<tr>
<td>ElementInjector 层次结构</td>
<td>在每个 DOM 元素上隐式创建。默认情况下，ElementInjector 是空的，除非你在 @Directive() 或 @Component() 的 providers 属性中配置它。</td>
</tr>
</tbody></table>
<h2 id="ModuleInjector"><a href="#ModuleInjector" class="headerlink" title="ModuleInjector"></a>ModuleInjector</h2><p>可以通过以下两种方式之一配置 ModuleInjector ：</p>
<ul>
<li><p>使用 @Injectable() 的 providedIn 属性引用 @NgModule() 或 root</p>
</li>
<li><p>使用 @NgModule() 的 providers 数组</p>
</li>
</ul>
<h3 id="摇树优化与-Injectable"><a href="#摇树优化与-Injectable" class="headerlink" title="摇树优化与 @Injectable()"></a>摇树优化与 @Injectable()</h3><p>使用 @Injectable() 的 providedIn 属性优于 @NgModule() 的 providers 数组。使用 @Injectable() 的 providedIn 时，优化工具可以进行摇树优化，从而删除你的应用程序中未使用的服务，以减小捆绑包尺寸。</p>
<h3 id="平台注入器"><a href="#平台注入器" class="headerlink" title="平台注入器"></a>平台注入器</h3><p>在 root 之上还有两个注入器，一个是额外的 ModuleInjector，一个是 NullInjector()。</p>
<p>思考下 Angular 要如何通过 main.ts 中的如下代码引导应用程序：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">platformBrowserDynamic</span>().<span class="title function_">bootstrapModule</span>(<span class="title class_">AppModule</span>).<span class="title function_">then</span>(<span class="function"><span class="params">ref</span> =&gt;</span> &#123;…&#125;)</span><br></pre></td></tr></table></figure>
<p>bootstrapModule() 方法会创建一个由 AppModule 配置的注入器作为平台注入器的子注入器。也就是 root ModuleInjector。</p>
<p>platformBrowserDynamic() 方法创建一个由 PlatformModule 配置的注入器，该注入器包含特定平台的依赖项。这允许多个应用共享同一套平台配置。比如，无论你运行多少个应用程序，浏览器都只有一个 URL 栏。你可以使用 platformBrowser() 函数提供 extraProviders，从而在平台级别配置特定平台的额外提供者。</p>
<p>层次结构中的下一个父注入器是 NullInjector()，它是树的顶部。如果你在树中向上走了很远，以至于要在 NullInjector() 中寻找服务，那么除非使用 @Optional()，否则将收到错误消息，因为最终所有东西都将以 NullInjector() 结束并返回错误，或者对于 @Optional()，返回 null。</p>
<blockquote>
<p>NullInjector()</p>
<p>(always throws an error unless you use @Optional)</p>
<p>↓</p>
<p>ModuleInjector</p>
<p>(configured by PlatformModule)<br>has special things like DomSanitizer&#x3D;&gt;platformBrowser()</p>
<p>↓<br>root ModuleInjector<br>(configured by YourAppModule)<br>has things for your app&#x3D;&gt;bootstrapModule(YourAPPModule)</p>
</blockquote>
<p>虽然 root 是一个特殊的别名，但其它 ModuleInjector 都没有别名。每当创建动态加载组件时，你还会创建 ModuleInjector，比如路由器，它还会创建子 ModuleInjector。</p>
<p>无论是使用 bootstrapModule() 的方法配置它，还是将所有提供者都用 root 注册到其自己的服务中，所有请求最终都会转发到 root 注入器。</p>
<blockquote>
<p>如果你在 AppModule 的 @NgModule() 中配置应用级提供者，它就会覆盖一个在 @Injectable() 的 root 元数据中配置的提供者。你可以用这种方式，来配置供多个应用共享的服务的非默认提供者。</p>
</blockquote>
<h2 id="ElementInjector"><a href="#ElementInjector" class="headerlink" title="ElementInjector"></a>ElementInjector</h2><p>Angular 会为每个 DOM 元素隐式创建 ElementInjector。</p>
<p>可以用 @Component() 装饰器中的 providers 或 viewProviders 属性来配置 ElementInjector 以提供服务。比如，下面的 TestComponent 通过提供此服务来配置 ElementInjector</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  …</span><br><span class="line">  <span class="attr">providers</span>: [&#123; <span class="attr">provide</span>: <span class="title class_">ItemService</span>, <span class="attr">useValue</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;lamp&#x27;</span> &#125; &#125;]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">TestComponent</span></span><br></pre></td></tr></table></figure>

<h3 id="Directive-和-Component"><a href="#Directive-和-Component" class="headerlink" title="@Directive() 和 @Component()"></a>@Directive() 和 @Component()</h3><p>组件是一种特殊类型的指令，这意味着 @Directive() 具有 providers 属性，@Component() 也同样如此。 这意味着指令和组件都可以使用 providers 属性来配置提供者。当使用 providers 属性为组件或指令配置提供者时，该提供程商就属于该组件或指令的 ElementInjector。同一元素上的组件和指令共享同一个注入器。</p>
<h2 id="解析规则"><a href="#解析规则" class="headerlink" title="解析规则"></a>解析规则</h2><p>当为组件&#x2F;指令解析令牌时，Angular 分为两个阶段来解析它：</p>
<ul>
<li><p>针对 ElementInjector 层次结构中它的父级。</p>
</li>
<li><p>针对 ModuleInjector 层次结构中它的父级。</p>
</li>
</ul>
<p>当组件声明依赖项时，Angular 会尝试使用它自己的 ElementInjector 来满足该依赖。 如果组件的注入器缺少提供者，它将把请求传给其父组件的 ElementInjector。</p>
<p>这些请求将继续转发，直到 Angular 找到可以处理该请求的注入器或用完祖先 ElementInjector。</p>
<p>如果 Angular 在任何 ElementInjector 中都找不到提供者，它将返回到发起请求的元素，并在 ModuleInjector 层次结构中进行查找。如果 Angular 仍然找不到提供者，它将引发错误。</p>
<p>如果你已在不同级别注册了相同 DI 令牌的提供者，则 Angular 会用遇到的第一个来解析该依赖。比如，如果提供者已经在需要此服务的组件中本地注册了，则 Angular 不会再寻找同一服务的其它提供者。</p>
<h2 id="模板的逻辑结构"><a href="#模板的逻辑结构" class="headerlink" title="模板的逻辑结构"></a>模板的逻辑结构</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-root</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-child</span>&gt;</span><span class="tag">&lt;/<span class="name">app-child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">app-root</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面是如何将 <app-root> 和 <app-child> 视图树组合为单个逻辑树的范例：</app-child></app-root></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-root</span>&gt;</span></span><br><span class="line">  &lt;#VIEW&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">app-child</span>&gt;</span></span><br><span class="line">     &lt;#VIEW&gt;</span><br><span class="line">       …content goes here…</span><br><span class="line">     &lt;/#VIEW&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">app-child</span>&gt;</span></span><br><span class="line">  &lt;/#VIEW&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">app-root</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当你在组件类中配置服务时，了解这种 &lt;#VIEW&gt; 划界的思想尤其重要。</p>
<h3 id="使用-viewProviders-数组"><a href="#使用-viewProviders-数组" class="headerlink" title="使用 viewProviders 数组"></a>使用 viewProviders 数组</h3><p>使用 viewProviders 数组是在 @Component() 装饰器中提供服务的另一种方法。使用 viewProviders 使服务在 &lt;#VIEW&gt; 中可见。</p>
<blockquote>
<p>除了使用 viewProviders 数组外，其它步骤与使用 providers 数组相同。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-root</span> @<span class="attr">NgModule</span>(<span class="attr">AppModule</span>)</span></span><br><span class="line"><span class="tag">         @<span class="attr">Inject</span>(<span class="attr">AnimalService</span>) <span class="attr">animal</span>=&gt;</span>&quot;🐳&quot;&gt;</span><br><span class="line">  &lt;#VIEW&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">app-child</span>&gt;</span></span><br><span class="line">      &lt;#VIEW @Provide(AnimalService=&quot;🐶&quot;)</span><br><span class="line">            @Inject(AnimalService=&gt;&quot;🐶&quot;)&gt;</span><br><span class="line">        <span class="comment">&lt;!-- ^^using viewProviders means AnimalService is available in &lt;#VIEW&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Emoji from AnimalService: &#123;&#123;animal.emoji&#125;&#125; (🐶)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Content projection<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">app-inspector</span> @<span class="attr">Inject</span>(<span class="attr">AnimalService</span>) <span class="attr">animal</span>=&gt;</span>&quot;🐳&quot;&gt;</span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>Emoji from AnimalService: &#123;&#123;animal.emoji&#125;&#125; (🐳)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">app-inspector</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">      &lt;/#VIEW&gt;</span><br><span class="line">      <span class="tag">&lt;<span class="name">app-inspector</span>&gt;</span></span><br><span class="line">        &lt;#VIEW&gt;</span><br><span class="line">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>Emoji from AnimalService: &#123;&#123;animal.emoji&#125;&#125; (🐶)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        &lt;/#VIEW&gt;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">app-inspector</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">app-child</span>&gt;</span></span><br><span class="line">  &lt;/#VIEW&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">app-root</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这四个绑定说明了 providers 和 viewProviders 之间的区别。由于🐶（小狗）在 &lt;#VIEW&gt; 中声明，因此投影内容不可见。投影的内容中会看到🐳（鲸鱼）。</p>
<p>但是下一部分，InspectorComponent 是 ChildComponent 的子组件，InspectorComponent 在 &lt;#VIEW&gt; 内部，因此当它请求 AnimalService 时，它会看到🐶（小狗）。</p>
<p><app-inspector> 的投影内容中看到了🐳（鲸鱼），而不是🐶（小狗），因为🐶（小狗）在 <app-child> 的 &lt;#VIEW&gt; 中。如果 <app-inspector> 也位于 &lt;#VIEW&gt; 则只能看到🐶（小狗）。</app-inspector></app-child></app-inspector></p>
<h3 id="Host-和-viewProviders"><a href="#Host-和-viewProviders" class="headerlink" title="@Host() 和 viewProviders"></a>@Host() 和 viewProviders</h3><p> @Host() 将搜索的上限限制为父节点的 &lt;#VIEW&gt;</p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-root</span> @<span class="attr">NgModule</span>(<span class="attr">AppModule</span>)</span></span><br><span class="line"><span class="tag">        @<span class="attr">Inject</span>(<span class="attr">AnimalService</span>=&gt;</span>&quot;🐳&quot;)&gt;</span><br><span class="line">  &lt;#VIEW @Provide(AnimalService=&quot;🦔&quot;)</span><br><span class="line">         @Inject(AnimalService, @Optional)=&gt;&quot;🦔&quot;&gt;</span><br><span class="line">    <span class="comment">&lt;!-- ^^@SkipSelf() starts here,  @Host() stops here^^ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">app-child</span>&gt;</span></span><br><span class="line">      &lt;#VIEW @Provide(AnimalService=&quot;🐶&quot;)</span><br><span class="line">             @Inject(AnimalService, @SkipSelf, @Host, @Optional)=&gt;&quot;🦔&quot;&gt;</span><br><span class="line">               <span class="comment">&lt;!-- Add @SkipSelf ^^--&gt;</span></span><br><span class="line">      &lt;/#VIEW&gt;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">app-child</span>&gt;</span></span><br><span class="line">  &lt;/#VIEW&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">app-root</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>@SkipSelf() 导致注入器从 <app-root> 而不是 <app-child> 处开始对 AnimalService 进行搜索，而 @Host() 会在 <app-root> 的 &lt;#VIEW&gt; 处停止搜索。 由于 AnimalService 是通过 viewProviders 数组提供的，因此注入程序会在 &lt;#VIEW&gt; 找到🦔（刺猬）。</app-root></app-child></app-root></p>
<h1 id="Inject-、Provider-deps、inject"><a href="#Inject-、Provider-deps、inject" class="headerlink" title="@Inject()、Provider.deps、inject"></a>@Inject()、Provider.deps、inject</h1><h2 id="Inject"><a href="#Inject" class="headerlink" title="@Inject()"></a>@Inject()</h2><p>@inject 主要的使用场景是在 class constructor 注入 token。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">VALUE_TOKEN</span> = <span class="keyword">new</span> <span class="title class_">InjectionToken</span>&lt;string&gt;(<span class="string">&#x27;Value&#x27;</span>);</span><br><span class="line">@<span class="title class_">Injectable</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServiceA</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">@Inject(VALUE_TOKEN) value: string</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> injector = <span class="title class_">Injector</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">providers</span>: [<span class="title class_">ServiceA</span>, &#123; <span class="attr">provide</span>: <span class="variable constant_">VALUE_TOKEN</span>, <span class="attr">useValue</span>: <span class="string">&#x27;Hello World&#x27;</span> &#125;],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> serviceA = injector.<span class="title function_">get</span>(<span class="title class_">ServiceA</span>);</span><br></pre></td></tr></table></figure>
<p><strong>注: 要搭配 @Injectable 指令</strong></p>
<p>inject 函数可以完全取代 @Inject()，上面代码可以改成这样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ServiceA</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="title function_">inject</span>(<span class="variable constant_">VALUE_TOKEN</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>连 @Injectable() 也可以省略掉</strong></p>
<h2 id="Provider-deps"><a href="#Provider-deps" class="headerlink" title="Provider.deps"></a>Provider.deps</h2><p>除了 @Inject()，还有一种注入方式是通过 Provider.deps</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">VALUE_1_TOKEN</span> = <span class="keyword">new</span> <span class="title class_">InjectionToken</span>&lt;string&gt;(<span class="string">&#x27;Value1&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">VALUE_2_TOKEN</span> = <span class="keyword">new</span> <span class="title class_">InjectionToken</span>&lt;string&gt;(<span class="string">&#x27;Value2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> injector = <span class="title class_">Injector</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">providers</span>: [</span><br><span class="line">    &#123; <span class="attr">provide</span>: <span class="variable constant_">VALUE_1_TOKEN</span>, <span class="attr">useValue</span>: <span class="string">&#x27;value 1&#x27;</span> &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">provide</span>: <span class="variable constant_">VALUE_2_TOKEN</span>,</span><br><span class="line">      <span class="attr">useFactory</span>: <span class="function">(<span class="params">value1: string</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;value1&#125;</span> and value2`</span>,</span><br><span class="line">      <span class="attr">deps</span>: [<span class="variable constant_">VALUE_1_TOKEN</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> value2 = injector.<span class="title function_">get</span>(<span class="variable constant_">VALUE_2_TOKEN</span>);</span><br></pre></td></tr></table></figure>
<p>这个同样可以被 inject 函数替代。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">providers</span>: [</span><br><span class="line">  &#123; <span class="attr">provide</span>: <span class="variable constant_">VALUE_1_TOKEN</span>, <span class="attr">useValue</span>: <span class="string">&#x27;value 1&#x27;</span> &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">provide</span>: <span class="variable constant_">VALUE_2_TOKEN</span>,</span><br><span class="line">    <span class="attr">useFactory</span>: <span class="function">(<span class="params">value1: string</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;inject(VALUE_1_TOKEN)&#125;</span> and value2`</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<h2 id="inject-函数"><a href="#inject-函数" class="headerlink" title="inject 函数"></a>inject 函数</h2><p>显然，inject 函数就是用来替代 @Inject 和 Provider.deps 的，所以尽量用 inject 少用 @Inject 和 Provider.deps。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/02/10/angular/%E9%AA%8C%E8%AF%81%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/10/angular/%E9%AA%8C%E8%AF%81%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5/" class="post-title-link" itemprop="url">验证表单输入</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-10 11:53:19" itemprop="dateCreated datePublished" datetime="2023-02-10T11:53:19+08:00">2023-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-20 08:52:58" itemprop="dateModified" datetime="2024-02-20T08:52:58+08:00">2024-02-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="在模板驱动表单中验证输入"><a href="#在模板驱动表单中验证输入" class="headerlink" title="在模板驱动表单中验证输入"></a>在模板驱动表单中验证输入</h1><p>为了往模板驱动表单中添加验证机制，你要添加一些验证属性，就像原生的 HTML 表单验证器一样。 Angular 会用指令来匹配这些具有验证功能的指令。</p>
<p>每当表单控件中的值发生变化时，Angular 就会进行验证，并生成一个验证错误的列表（对应着 INVALID 状态）或者 null（对应着 VALID 状态）。</p>
<p>你可以通过把 ngModel 导出成局部模板变量来查看该控件的状态。 比如下面这个例子就把 NgModel 导出成了一个名叫 name 的变量：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="keyword">type</span>=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;name&quot;</span> name=<span class="string">&quot;name&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;form-control&quot;</span></span><br><span class="line">      required minlength=<span class="string">&quot;4&quot;</span> appForbiddenName=<span class="string">&quot;bob&quot;</span></span><br><span class="line">      [(ngModel)]=<span class="string">&quot;hero.name&quot;</span> #name=<span class="string">&quot;ngModel&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngIf</span>=<span class="string">&quot;name.invalid &amp;&amp; (name.dirty || name.touched)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">class</span>=<span class="string">&quot;alert&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngIf</span>=<span class="string">&quot;name.errors?.[&#x27;required&#x27;]&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Name is required.</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngIf</span>=<span class="string">&quot;name.errors?.[&#x27;minlength&#x27;]&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Name must be at least 4 characters long.</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngIf</span>=<span class="string">&quot;name.errors?.[&#x27;forbiddenName&#x27;]&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Name cannot be Bob.</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>注意这个例子讲解的如下特性。</p>
<ul>
<li><p><code>&lt;input&gt;</code> 元素带有一些 HTML 验证属性：required 和 minlength。它还带有一个自定义的验证器指令 forbiddenName。欲知详情，参阅自定义验证器一节。</p>
</li>
<li><p>#name&#x3D;”ngModel” 把 NgModel 导出成了一个名叫 name 的局部变量。NgModel 把自己控制的 FormControl 实例的属性映射出去，让你能在模板中检查控件的状态，比如 valid 和 dirty。要了解完整的控件属性，参阅 API 参考手册中的AbstractControl。</p>
<ul>
<li><p><code>&lt;div&gt;</code> 元素的 *ngIf 展示了一组嵌套的消息 div，但是只在有“name”错误和控制器为 dirty 或者 touched 时才出现。</p>
</li>
<li><p>每个嵌套的 <code>&lt;div&gt;</code> 为其中一个可能出现的验证错误显示一条自定义消息。比如 required、minlength 和 forbiddenName。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>为防止验证程序在用户有机会编辑表单之前就显示错误，你应该检查控件的 dirty 状态或 touched 状态。</p>
<ul>
<li>当用户在被监视的字段中修改该值时，控件就会被标记为 dirty（脏）</li>
<li>当用户的表单控件失去焦点时，该控件就会被标记为 touched（已接触）</li>
</ul>
</blockquote>
<h1 id="在响应式表单中验证输入"><a href="#在响应式表单中验证输入" class="headerlink" title="在响应式表单中验证输入"></a>在响应式表单中验证输入</h1><p>在响应式表单中，事实之源是其组件类。不应该通过模板上的属性来添加验证器，而应该在组件类中直接把验证器函数添加到表单控件模型上（FormControl）。然后，一旦控件发生了变化，Angular 就会调用这些函数。</p>
<h2 id="验证器（Validator）函数"><a href="#验证器（Validator）函数" class="headerlink" title="验证器（Validator）函数"></a>验证器（Validator）函数</h2><p>验证器函数可以是同步函数，也可以是异步函数。</p>
<table>
<thead>
<tr>
<th>验证器类型</th>
<th>详细信息</th>
</tr>
</thead>
<tbody><tr>
<td>同步验证器</td>
<td>这些同步函数接受一个控件实例，然后返回一组验证错误或 null。可以在实例化一个 FormControl 时把它作为构造函数的第二个参数传进去。</td>
</tr>
<tr>
<td>异步验证器</td>
<td>这些异步函数接受一个控件实例并返回一个 Promise 或 Observable，它稍后会发出一组验证错误或 null。在实例化 FormControl 时，可以把它们作为第三个参数传入。</td>
</tr>
</tbody></table>
<p>出于性能方面的考虑，只有在所有同步验证器都通过之后，Angular 才会运行异步验证器。当每一个异步验证器都执行完之后，才会设置这些验证错误。</p>
<h3 id="内置验证器函数"><a href="#内置验证器函数" class="headerlink" title="内置验证器函数"></a>内置验证器函数</h3><p>在模板驱动表单中用作属性的那些内置验证器，比如 required 和 minlength，也都可以作为 Validators 类中的函数使用。</p>
<ul>
<li>min(min:number) 此验证器要求控件的值大于或等于指定的数字。 它只有函数形式，没有指令形式。</li>
<li>max(max: number) 此验证器要求控件的值小于等于指定的数字。 它只有函数形式，没有指令形式。</li>
<li>required 此验证器要求控件具有非空值。</li>
<li>requiredTrue 此验证器要求控件的值为真。它通常用来验证检查框。</li>
<li>email 此验证器要求控件的值能通过 email 格式验证。</li>
<li>minLength 此验证器要求控件值的长度大于等于所指定的最小长度。当使用 HTML5 的 minlength 属性时，此验证器也会生效。</li>
<li>maxLength 此验证器要求控件值的长度小于等于所指定的最大长度。当使用 HTML5 的 maxlength 属性时，此验证器也会生效。</li>
<li>pattern 此验证器要求控件的值匹配某个正则表达式。当使用 HTML5 的 pattern 属性时，它也会生效。</li>
<li>nullValidator 此验证器什么也不做。</li>
<li>compose 把多个验证器合并成一个函数，它会返回指定控件的各个错误映射表的并集。</li>
<li>composeAsync 把多个异步验证器合并成一个函数，它会返回指定控件的各个错误映射表的并集。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">ngOnInit</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">heroForm</span> = <span class="keyword">new</span> <span class="title class_">FormGroup</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="variable language_">this</span>.<span class="property">hero</span>.<span class="property">name</span>, [</span><br><span class="line">      <span class="title class_">Validators</span>.<span class="property">required</span>,</span><br><span class="line">      <span class="title class_">Validators</span>.<span class="title function_">minLength</span>(<span class="number">4</span>),</span><br><span class="line">      <span class="title function_">forbiddenNameValidator</span>(<span class="regexp">/bob/i</span>) <span class="comment">// &lt;-- Here&#x27;s how you pass in the custom validator.</span></span><br><span class="line">    ]),</span><br><span class="line">    <span class="attr">alterEgo</span>: <span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="variable language_">this</span>.<span class="property">hero</span>.<span class="property">alterEgo</span>),</span><br><span class="line">    <span class="attr">power</span>: <span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="variable language_">this</span>.<span class="property">hero</span>.<span class="property">power</span>, <span class="title class_">Validators</span>.<span class="property">required</span>)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">get</span> <span class="title function_">name</span>() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">heroForm</span>.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">get</span> <span class="title function_">power</span>() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">heroForm</span>.<span class="title function_">get</span>(<span class="string">&#x27;power&#x27;</span>); &#125;</span><br></pre></td></tr></table></figure>
<p>所有这些验证器都是同步的，所以它们作为第二个参数传递。注意，你可以通过把这些函数放到一个数组中传入来支持多个验证器。</p>
<p>如果你到模板中找到 name 输入框，就会发现它和模板驱动的例子很相似。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">formControlName</span>=<span class="string">&quot;name&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngIf</span>=<span class="string">&quot;name.invalid &amp;&amp; (name.dirty || name.touched)&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;alert alert-danger&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngIf</span>=<span class="string">&quot;name.errors?.[&#x27;required&#x27;]&quot;</span>&gt;</span></span><br><span class="line">    Name is required.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngIf</span>=<span class="string">&quot;name.errors?.[&#x27;minlength&#x27;]&quot;</span>&gt;</span></span><br><span class="line">    Name must be at least 4 characters long.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngIf</span>=<span class="string">&quot;name.errors?.[&#x27;forbiddenName&#x27;]&quot;</span>&gt;</span></span><br><span class="line">    Name cannot be Bob.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个表单与模板驱动的版本不同，它不再导出任何指令。相反，它使用组件类中定义的 name 读取器（getter）。</p>
<h1 id="自定义验证器"><a href="#自定义验证器" class="headerlink" title="自定义验证器"></a>自定义验证器</h1><p>内置的验证器并不是总能精确匹配应用中的用例，因此有时你需要创建一个自定义验证器。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** A hero&#x27;s name can&#x27;t match the given regular expression */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">forbiddenNameValidator</span>(<span class="params">nameRe: <span class="built_in">RegExp</span></span>): <span class="title class_">ValidatorFn</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="attr">control</span>: <span class="title class_">AbstractControl</span>): <span class="title class_">ValidationErrors</span> | <span class="function"><span class="params">null</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> forbidden = nameRe.<span class="title function_">test</span>(control.<span class="property">value</span>);</span><br><span class="line">    <span class="keyword">return</span> forbidden ? &#123;<span class="attr">forbiddenName</span>: &#123;<span class="attr">value</span>: control.<span class="property">value</span>&#125;&#125; : <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>forbiddenNameValidator 工厂函数返回配置好的验证器函数。 该函数接受一个 Angular control 对象，并在control值有效时返回 null，或无效时返回验证错误信息。 验证错误信息通常有一个名为 验证器名称（forbiddenName）的属性。其值为 K-V形式的字典，你可以插入错误信息。</p>
<p>自定义异步验证器和同步验证器很像，只是它们必须返回一个稍后会输出 null 或“验证错误对象”的承诺（Promise）或可观察对象，如果是可观察对象，那么它必须在某个时间点被完成（complete），那时候这个表单就会使用它输出的最后一个值作为验证结果。</p>
<h2 id="把自定义验证器添加到响应式表单中"><a href="#把自定义验证器添加到响应式表单中" class="headerlink" title="把自定义验证器添加到响应式表单中"></a>把自定义验证器添加到响应式表单中</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">heroForm</span> = <span class="keyword">new</span> <span class="title class_">FormGroup</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="variable language_">this</span>.<span class="property">hero</span>.<span class="property">name</span>, [</span><br><span class="line">    <span class="title class_">Validators</span>.<span class="property">required</span>,</span><br><span class="line">    <span class="title class_">Validators</span>.<span class="title function_">minLength</span>(<span class="number">4</span>),</span><br><span class="line">    <span class="title function_">forbiddenNameValidator</span>(<span class="regexp">/bob/i</span>) <span class="comment">// &lt;-- Here&#x27;s how you pass in the custom validator.</span></span><br><span class="line">  ]),</span><br><span class="line">  <span class="attr">alterEgo</span>: <span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="variable language_">this</span>.<span class="property">hero</span>.<span class="property">alterEgo</span>),</span><br><span class="line">  <span class="attr">power</span>: <span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="variable language_">this</span>.<span class="property">hero</span>.<span class="property">power</span>, <span class="title class_">Validators</span>.<span class="property">required</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="为模板驱动表单中添加自定义验证器"><a href="#为模板驱动表单中添加自定义验证器" class="headerlink" title="为模板驱动表单中添加自定义验证器"></a>为模板驱动表单中添加自定义验证器</h2><p>在模板驱动表单中，要为模板添加一个指令，该指令包含了一个 validator 函数。比如，ForbiddenValidatorDirective 指令中 包含了 forbiddenNameValidator 验证函数。</p>
<p>Angular 在验证过程中会识别出该指令的作用，因为该指令把自己注册成了 NG_VALIDATORS 提供者，如下例所示。NG_VALIDATORS 是一个带有可扩展验证器集合的预定义提供者。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Directive</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;[appForbiddenName]&#x27;</span>,</span><br><span class="line">  <span class="attr">providers</span>: [&#123;<span class="attr">provide</span>: <span class="variable constant_">NG_VALIDATORS</span>, <span class="attr">useExisting</span>: <span class="title class_">ForbiddenValidatorDirective</span>, <span class="attr">multi</span>: <span class="literal">true</span>&#125;]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ForbiddenValidatorDirective</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line">  <span class="meta">@Input</span>(<span class="string">&#x27;appForbiddenName&#x27;</span>) forbiddenName = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">validate</span>(<span class="attr">control</span>: <span class="title class_">AbstractControl</span>): <span class="title class_">ValidationErrors</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">forbiddenName</span> ? <span class="title function_">forbiddenNameValidator</span>(<span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="variable language_">this</span>.<span class="property">forbiddenName</span>, <span class="string">&#x27;i&#x27;</span>))(control): <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦 ForbiddenValidatorDirective 写好了，你只要把 选择器 forbiddenName 添加到输入框上就可以激活这个验证器了。比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">required</span> <span class="attr">minlength</span>=<span class="string">&quot;4&quot;</span> <span class="attr">appForbiddenName</span>=<span class="string">&quot;bob&quot;</span></span></span><br><span class="line"><span class="tag">      [(<span class="attr">ngModel</span>)]=<span class="string">&quot;hero.name&quot;</span> #<span class="attr">name</span>=<span class="string">&quot;ngModel&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，自定义验证指令是用 useExisting 而不是 useClass 来实例化的。注册的验证程序必须是 ForbiddenValidatorDirective 实例本身 - 表单中的实例，也就是表单中 forbiddenName 属性被绑定到了”bob”的那个。</p>
<p>如果用 useClass 来代替 useExisting，就会注册一个新的类实例，而它是没有 forbiddenName 的。</p>
</blockquote>
<h1 id="表示控件状态的-CSS-类"><a href="#表示控件状态的-CSS-类" class="headerlink" title="表示控件状态的 CSS 类"></a>表示控件状态的 CSS 类</h1><p>Angular 会自动把很多控件属性作为 CSS 类映射到控件所在的元素上。你可以使用这些类来根据表单状态给表单控件元素添加样式。目前支持下列类：</p>
<ul>
<li><p>.ng-valid</p>
</li>
<li><p>.ng-invalid</p>
</li>
<li><p>.ng-pending</p>
</li>
<li><p>.ng-pristine</p>
</li>
<li><p>.ng-dirty</p>
</li>
<li><p>.ng-untouched</p>
</li>
<li><p>.ng-touched</p>
</li>
<li><p>.ng-submitted (只对 form 元素添加)</p>
</li>
</ul>
<p>在下面的例子中，这个英雄表单使用 .ng-valid 和 .ng-invalid 来设置每个表单控件的边框颜色。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.ng-valid</span><span class="selector-attr">[required]</span>, <span class="selector-class">.ng-valid</span><span class="selector-class">.required</span>  &#123;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">5px</span> solid <span class="number">#42A948</span>; <span class="comment">/* green */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.ng-invalid</span><span class="selector-pseudo">:not</span>(<span class="selector-tag">form</span>)  &#123;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">5px</span> solid <span class="number">#a94442</span>; <span class="comment">/* red */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="跨字段交叉验证"><a href="#跨字段交叉验证" class="headerlink" title="跨字段交叉验证"></a>跨字段交叉验证</h1><p>跨字段交叉验证器是一种自定义验证器，可以对表单中不同字段的值进行比较，并针对它们的组合进行接受或拒绝。</p>
<h2 id="为响应式表单添加交叉验证"><a href="#为响应式表单添加交叉验证" class="headerlink" title="为响应式表单添加交叉验证"></a>为响应式表单添加交叉验证</h2><p>该表单具有以下结构：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> heroForm = <span class="keyword">new</span> <span class="title class_">FormGroup</span>(&#123;</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span>: <span class="keyword">new</span> <span class="title class_">FormControl</span>(),</span><br><span class="line">  <span class="string">&#x27;alterEgo&#x27;</span>: <span class="keyword">new</span> <span class="title class_">FormControl</span>(),</span><br><span class="line">  <span class="string">&#x27;power&#x27;</span>: <span class="keyword">new</span> <span class="title class_">FormControl</span>()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>name 和 alterEgo 是兄弟控件。要想在单个自定义验证器中计算这两个控件，你就必须在它们共同的祖先控件中执行验证：FormGroup。</p>
<p>要想给 FormGroup 添加验证器，就要在创建时把一个新的验证器传给它的第二个参数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> heroForm = <span class="keyword">new</span> <span class="title class_">FormGroup</span>(&#123;</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span>: <span class="keyword">new</span> <span class="title class_">FormControl</span>(),</span><br><span class="line">  <span class="string">&#x27;alterEgo&#x27;</span>: <span class="keyword">new</span> <span class="title class_">FormControl</span>(),</span><br><span class="line">  <span class="string">&#x27;power&#x27;</span>: <span class="keyword">new</span> <span class="title class_">FormControl</span>()</span><br><span class="line">&#125;, &#123; <span class="attr">validators</span>: identityRevealedValidator &#125;);</span><br></pre></td></tr></table></figure>
<p>验证器的代码如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** A hero&#x27;s name can&#x27;t match the hero&#x27;s alter ego */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">identityRevealedValidator</span>: <span class="title class_">ValidatorFn</span> = (<span class="attr">control</span>: <span class="title class_">AbstractControl</span>): <span class="title class_">ValidationErrors</span> | <span class="function"><span class="params">null</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> name = control.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> alterEgo = control.<span class="title function_">get</span>(<span class="string">&#x27;alterEgo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> name &amp;&amp; alterEgo &amp;&amp; name.<span class="property">value</span> === alterEgo.<span class="property">value</span> ? &#123; <span class="attr">identityRevealed</span>: <span class="literal">true</span> &#125; : <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该验证器通过调用 FormGroup 的 get 方法来检索这些子控件，然后比较 name 和 alterEgo 控件的值。</p>
<p>为了提供更好的用户体验，当表单无效时，模板还会显示一条恰当的错误信息。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngIf</span>=<span class="string">&quot;heroForm.errors?.[&#x27;identityRevealed&#x27;] &amp;&amp; (heroForm.touched || heroForm.dirty)&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cross-validation-error-message alert alert-danger&quot;</span>&gt;</span></span><br><span class="line">        Name cannot match alter ego.</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果 FormGroup 中有一个由 identityRevealed 验证器返回的交叉验证错误，*ngIf 就会显示错误，但只有当该用户已经与表单进行过交互的时候才显示。</p>
<h2 id="为模板驱动表单添加交叉验证"><a href="#为模板驱动表单添加交叉验证" class="headerlink" title="为模板驱动表单添加交叉验证"></a>为模板驱动表单添加交叉验证</h2><p>对于模板驱动表单，你必须创建一个指令来包装验证器函数。你可以使用NG_VALIDATORS 令牌来把该指令提供为验证器，如下例所示。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Directive</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;[appIdentityRevealed]&#x27;</span>,</span><br><span class="line">  <span class="attr">providers</span>: [&#123; <span class="attr">provide</span>: <span class="variable constant_">NG_VALIDATORS</span>, <span class="attr">useExisting</span>: <span class="title class_">IdentityRevealedValidatorDirective</span>, <span class="attr">multi</span>: <span class="literal">true</span> &#125;]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">IdentityRevealedValidatorDirective</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line">  <span class="title function_">validate</span>(<span class="attr">control</span>: <span class="title class_">AbstractControl</span>): <span class="title class_">ValidationErrors</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">identityRevealedValidator</span>(control);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你必须把这个新指令添加到 HTML 模板中。由于验证器必须注册在表单的最高层，因此下列模板会把该指令放在 form 标签上。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> #<span class="attr">heroForm</span>=<span class="string">&quot;ngForm&quot;</span> <span class="attr">appIdentityRevealed</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了提供更好的用户体验，当表单无效时，我们要显示一个恰当的错误信息。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngIf</span>=<span class="string">&quot;heroForm.errors?.[&#x27;identityRevealed&#x27;] &amp;&amp; (heroForm.touched || heroForm.dirty)&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cross-validation-error-message alert&quot;</span>&gt;</span></span><br><span class="line">    Name cannot match alter ego.</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这在模板驱动表单和响应式表单中都是一样的。</p>
<h1 id="创建异步验证器"><a href="#创建异步验证器" class="headerlink" title="创建异步验证器"></a>创建异步验证器</h1><p>异步验证器实现了 AsyncValidatorFn 和 AsyncValidator 接口。它们与其同步版本非常相似，但有以下不同之处。</p>
<p>validate() 函数必须返回一个 Promise 或可观察对象，</p>
<p>返回的可观察对象必须是有尽的，这意味着它必须在某个时刻完成（complete）。要把无尽的可观察对象转换成有尽的，可以在管道中加入过滤操作符，比如 first、last、take 或 takeUntil。</p>
<p>异步验证在同步验证完成后才会发生，并且只有在同步验证成功时才会执行。如果更基本的验证方法已经发现了无效输入，那么这种检查顺序就可以让表单避免使用昂贵的异步验证流程（比如 HTTP 请求）。</p>
<p>异步验证开始之后，表单控件就会进入 pending 状态。可以检查控件的 pending 属性，并用它来给出对验证中的视觉反馈。</p>
<p>一种常见的 UI 模式是在执行异步验证时显示 Spinner（转轮）。下面的例子展示了如何在模板驱动表单中实现这一点。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> [(<span class="attr">ngModel</span>)]=<span class="string">&quot;name&quot;</span> #<span class="attr">model</span>=<span class="string">&quot;ngModel&quot;</span> <span class="attr">appSomeAsyncValidator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">app-spinner</span> *<span class="attr">ngIf</span>=<span class="string">&quot;model.pending&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">app-spinner</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="实现自定义异步验证器"><a href="#实现自定义异步验证器" class="headerlink" title="实现自定义异步验证器"></a>实现自定义异步验证器</h2><p>下面的代码创建了一个验证器类 UniqueAlterEgoValidator，它实现了 AsyncValidator 接口</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Injectable</span>(&#123; <span class="attr">providedIn</span>: <span class="string">&#x27;root&#x27;</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">UniqueAlterEgoValidator</span> <span class="keyword">implements</span> <span class="title class_">AsyncValidator</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> heroesService: HeroesService</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">validate</span>(</span><br><span class="line">    <span class="attr">control</span>: <span class="title class_">AbstractControl</span></span><br><span class="line">  ): <span class="title class_">Observable</span>&lt;<span class="title class_">ValidationErrors</span> | <span class="literal">null</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">heroesService</span>.<span class="title function_">isAlterEgoTaken</span>(control.<span class="property">value</span>).<span class="title function_">pipe</span>(</span><br><span class="line">      <span class="title function_">map</span>(<span class="function"><span class="params">isTaken</span> =&gt;</span> (isTaken ? &#123; <span class="attr">uniqueAlterEgo</span>: <span class="literal">true</span> &#125; : <span class="literal">null</span>)),</span><br><span class="line">      <span class="title function_">catchError</span>(<span class="function">() =&gt;</span> <span class="title function_">of</span>(<span class="literal">null</span>))</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数中注入了 HeroesService，它定义了如下接口。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">HeroesService</span> &#123;</span><br><span class="line">  <span class="attr">isAlterEgoTaken</span>: <span class="function">(<span class="params">alterEgo: <span class="built_in">string</span></span>) =&gt;</span> <span class="title class_">Observable</span>&lt;<span class="built_in">boolean</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与任何验证器一样，如果表单有效，该方法返回 null，如果无效，则返回 ValidationErrors。这个验证器使用 catchError 操作符来处理任何潜在的错误。在这个例子中，验证器将 isAlterEgoTaken() 错误视为成功的验证，因为未能发出验证请求并不一定意味着这个第二人格无效。你也可以用不同的方式处理这种错误，比如返回 ValidationError 对象。</p>
<p>一段时间过后，这条可观察对象链完成，异步验证也就完成了。pending 标志位也设置为 false，该表单的有效性也已更新。</p>
<h2 id="将异步验证器添加到响应式表单"><a href="#将异步验证器添加到响应式表单" class="headerlink" title="将异步验证器添加到响应式表单"></a>将异步验证器添加到响应式表单</h2><p>要以响应式表单使用异步验证器，请首先将验证器注入组件类的构造函数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> alterEgoValidator: UniqueAlterEgoValidator</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>然后，将验证器函数直接传递给 FormControl 以应用它。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> alterEgoControl = <span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="string">&#x27;&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">asyncValidators</span>: [<span class="variable language_">this</span>.<span class="property">alterEgoValidator</span>.<span class="property">validate</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>.<span class="property">alterEgoValidator</span>)],</span><br><span class="line">  <span class="attr">updateOn</span>: <span class="string">&#x27;blur&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="将异步验证器添加到模板驱动表单"><a href="#将异步验证器添加到模板驱动表单" class="headerlink" title="将异步验证器添加到模板驱动表单"></a>将异步验证器添加到模板驱动表单</h2><p>要在模板驱动表单中使用异步验证器，请创建一个新指令并在其上注册 NG_ASYNC_VALIDATORS 提供者。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Directive</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;[appUniqueAlterEgo]&#x27;</span>,</span><br><span class="line">  <span class="attr">providers</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">provide</span>: <span class="variable constant_">NG_ASYNC_VALIDATORS</span>,</span><br><span class="line">      <span class="attr">useExisting</span>: <span class="title function_">forwardRef</span>(<span class="function">() =&gt;</span> <span class="title class_">UniqueAlterEgoValidatorDirective</span>),</span><br><span class="line">      <span class="attr">multi</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">UniqueAlterEgoValidatorDirective</span> <span class="keyword">implements</span> <span class="title class_">AsyncValidator</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> validator: UniqueAlterEgoValidator</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">validate</span>(</span><br><span class="line">    <span class="attr">control</span>: <span class="title class_">AbstractControl</span></span><br><span class="line">  ): <span class="title class_">Observable</span>&lt;<span class="title class_">ValidationErrors</span> | <span class="literal">null</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">validator</span>.<span class="title function_">validate</span>(control);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，与使用同步验证器一样，将指令的选择器添加到输入以激活它。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">id</span>=<span class="string">&quot;alterEgo&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">name</span>=<span class="string">&quot;alterEgo&quot;</span></span></span><br><span class="line"><span class="tag">         #<span class="attr">alterEgo</span>=<span class="string">&quot;ngModel&quot;</span></span></span><br><span class="line"><span class="tag">         [(<span class="attr">ngModel</span>)]=<span class="string">&quot;hero.alterEgo&quot;</span></span></span><br><span class="line"><span class="tag">         [<span class="attr">ngModelOptions</span>]=<span class="string">&quot;&#123; updateOn: &#x27;blur&#x27; &#125;&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">appUniqueAlterEgo</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，所有验证程序在每次表单值更改后都会运行。对于同步验证器，这通常不会对应用性能产生明显的影响。但是，异步验证器通常会执行某种 HTTP 请求来验证控件。每次按键后调度一次 HTTP 请求都会给后端 API 带来压力，应该尽可能避免。</p>
<p>你可以把 updateOn 属性从 change（默认值）改成 submit 或 blur 来推迟表单验证的更新时机。</p>
<p>使用模板驱动表单时，可以在模板中设置该属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> [(<span class="attr">ngModel</span>)]=<span class="string">&quot;name&quot;</span> [<span class="attr">ngModelOptions</span>]=<span class="string">&quot;&#123;updateOn: &#x27;blur&#x27;&#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用响应式表单时，可以在 FormControl 实例中设置该属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="string">&#x27;&#x27;</span>, &#123;<span class="attr">updateOn</span>: <span class="string">&#x27;blur&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/02/08/angular/%E8%A1%A8%E5%8D%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/08/angular/%E8%A1%A8%E5%8D%95/" class="post-title-link" itemprop="url">表单</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-08 22:04:27" itemprop="dateCreated datePublished" datetime="2023-02-08T22:04:27+08:00">2023-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-22 16:43:01" itemprop="dateModified" datetime="2024-02-22T16:43:01+08:00">2024-02-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Angular 提供了两种不同的方法来通过表单处理用户输入：响应式表单和模板驱动表单。 两者都从视图中捕获用户输入事件、验证用户输入、创建表单模型、修改数据模型，并提供跟踪这些更改的途径。</p>
<h1 id="选择一种方法"><a href="#选择一种方法" class="headerlink" title="选择一种方法"></a>选择一种方法</h1><p>响应式表单和模板驱动表单以不同的方式处理和管理表单数据。每种方法都有各自的优点。</p>
<table>
<thead>
<tr>
<th>表单</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td>响应式表单</td>
<td>提供对底层表单对象模型直接、显式的访问。它们与模板驱动表单相比，更加健壮：它们的可扩展性、可复用性和可测试性都更高。如果表单是你的应用程序的关键部分，或者你已经在使用响应式表单来构建应用，那就使用响应式表单。</td>
</tr>
<tr>
<td>模板驱动表单</td>
<td>依赖模板中的指令来创建和操作底层的对象模型。它们对于向应用添加一个简单的表单非常有用，比如电子邮件列表注册表单。它们很容易添加到应用中，但在扩展性方面不如响应式表单。如果你有可以只在模板中管理的非常基本的表单需求和逻辑，那么模板驱动表单就很合适。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="建立表单模型"><a href="#建立表单模型" class="headerlink" title="建立表单模型"></a>建立表单模型</h1><p>响应式表单和模板驱动型表单都会跟踪用户与之交互的表单输入元素和组件模型中的表单数据之间的值变更。这两种方法共享同一套底层构建块，只在如何创建和管理常用表单控件实例方面有所不同。</p>
<h2 id="常用表单基础类"><a href="#常用表单基础类" class="headerlink" title="常用表单基础类"></a>常用表单基础类</h2><p>响应式表单和模板驱动表单都建立在下列基础类之上。</p>
<table>
<thead>
<tr>
<th>基础类</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td>FormControl</td>
<td>追踪单个表单控件的值和验证状态。</td>
</tr>
<tr>
<td>FormGroup</td>
<td>追踪一个表单控件组的值和状态。</td>
</tr>
<tr>
<td>FormArray</td>
<td>追踪表单控件数组的值和状态。</td>
</tr>
<tr>
<td>ControlValueAccessor</td>
<td>在 Angular 的 FormControl 实例和内置 DOM 元素之间创建一个桥梁</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="建立响应式表单"><a href="#建立响应式表单" class="headerlink" title="建立响应式表单"></a>建立响应式表单</h2><p>对于响应式表单，你可以直接在组件类中定义表单模型。[formControl] 指令会通过内部值访问器来把显式创建的 FormControl 实例与视图中的特定表单元素联系起来。</p>
<p>下面的组件使用响应式表单为单个控件实现了一个输入字段。在这个例子中，表单模型是 FormControl 实例。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">FormControl</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/forms&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-reactive-favorite-color&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    Favorite Color: &lt;input type=&quot;text&quot; [formControl]=&quot;favoriteColorControl&quot;&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">FavoriteColorComponent</span> &#123;</span><br><span class="line">  favoriteColorControl = <span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="建立模板驱动表单"><a href="#建立模板驱动表单" class="headerlink" title="建立模板驱动表单"></a>建立模板驱动表单</h2><p>在模板驱动表单中，表单模型是隐式的，而不是显式的。指令 NgModel 为指定的表单元素创建并管理一个 FormControl 实例。</p>
<p>下面的组件使用模板驱动表单为单个控件实现了同样的输入字段。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-template-favorite-color&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    Favorite Color: &lt;input type=&quot;text&quot; [(ngModel)]=&quot;favoriteColor&quot;&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">FavoriteColorComponent</span> &#123;</span><br><span class="line">  favoriteColor = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="响应式表单"><a href="#响应式表单" class="headerlink" title="响应式表单"></a>响应式表单</h1><p>响应式表单使用显式的、不可变的方式，管理表单在特定的时间点上的状态。对表单状态的每一次变更都会返回一个新的状态，这样可以在变化时维护模型的整体性。响应式表单是围绕 Observable 流构建的，表单的输入和值都是通过这些输入值组成的流来提供的，它可以同步访问。</p>
<h2 id="添加基础表单控件"><a href="#添加基础表单控件" class="headerlink" title="添加基础表单控件"></a>添加基础表单控件</h2><p>下面的例子展示了如何添加一个表单控件。在这个例子中，用户在输入字段中输入自己的名字，捕获其输入值，并显示表单控件的当前值。</p>
<table>
<thead>
<tr>
<th>动作</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td>注册响应式表单模块</td>
<td>要使用响应式表单控件，就要从 @angular&#x2F;forms 包中导入 ReactiveFormsModule，并把它添加到你的 NgModule 的 imports 数组中。</td>
</tr>
</tbody></table>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ReactiveFormsModule</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/forms&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [</span><br><span class="line">    <span class="comment">// other imports ...</span></span><br><span class="line">    <span class="title class_">ReactiveFormsModule</span></span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppModule</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>生成新的 FormControl</td>
<td>可以用 FormControl 的构造函数设置初始值，这个例子中它是空字符串。通过在你的组件类中创建这些控件，你可以直接对表单控件的状态进行监听、修改和校验。</td>
</tr>
</tbody></table>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">FormControl</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/forms&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-name-editor&#x27;</span>,</span><br><span class="line">  <span class="attr">templateUrl</span>: <span class="string">&#x27;./name-editor.component.html&#x27;</span>,</span><br><span class="line">  <span class="attr">styleUrls</span>: [<span class="string">&#x27;./name-editor.component.css&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">NameEditorComponent</span> &#123;</span><br><span class="line">  name = <span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>在模板中注册该控件</td>
<td>在组件类中创建了控件之后，你还要把它和模板中的一个表单控件关联起来。修改模板，为表单控件添加 formControl 绑定，formControl 是由 ReactiveFormsModule 中的 FormControlDirective 提供的。</td>
</tr>
</tbody></table>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">&quot;name&quot;</span>&gt;<span class="title class_">Name</span>: &lt;/label&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> [<span class="attr">formControl</span>]=<span class="string">&quot;name&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>使用这种模板绑定语法，把该表单控件注册给了模板中名为 name 的输入元素。这样，表单控件和 DOM 元素就可以互相通讯了：视图会反映模型的变化，模型也会反映视图中的变化。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>显示该组件</td>
<td>把该组件添加到模板时，将显示指派给 name 的表单控件。</td>
</tr>
</tbody></table>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;app-name-editor&gt;&lt;/app-name-editor&gt;</span><br></pre></td></tr></table></figure>

<h3 id="显示表单控件的值"><a href="#显示表单控件的值" class="headerlink" title="显示表单控件的值"></a>显示表单控件的值</h3><p>你可以用下列方式显示它的值。</p>
<ul>
<li>通过可观察对象 valueChanges，你可以在模板中使用 AsyncPipe 或在组件类中使用 subscribe() 方法来监听表单值的变化。</li>
<li>使用 value 属性。它能让你获得当前值的一份快照。</li>
</ul>
<p>一旦你修改了表单控件所关联的元素，这里显示的值也跟着变化了。</p>
<h3 id="替换表单控件的值"><a href="#替换表单控件的值" class="headerlink" title="替换表单控件的值"></a>替换表单控件的值</h3><p><code>FormControl</code>实例提供了一个<code>setValue()</code>方法，它会修改这个表单控件的值，并且验证与控件结构相对应的值的结构。比如，当从后端 API 或服务接收到了表单数据时，可以通过<code>setValue()</code>方法来把原来的值替换为新的值。</p>
<p>下列的例子往组件类中添加了一个方法，它使用<code>setValue()</code> 方法来将控件的值修改为 Nancy。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">updateName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span>.<span class="title function_">setValue</span>(<span class="string">&#x27;Nancy&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这个例子中，你只使用单个控件，但是当调用 FormGroup 或 FormArray 实例的 setValue() 方法时，传入的值就必须匹配控件组或控件数组的结构才行。</p>
</blockquote>
<h2 id="把表单控件分组"><a href="#把表单控件分组" class="headerlink" title="把表单控件分组"></a>把表单控件分组</h2><p>就像 FormControl 的实例能让你控制单个输入框所对应的控件一样，FormGroup 的实例也能跟踪一组 FormControl 实例（比如一个表单）的表单状态。当创建 FormGroup 时，其中的每个控件都会根据其名字进行跟踪。下面的例子展示了如何管理单个控件组中的多个 FormControl 实例。</p>
<p>生成一个 ProfileEditor 组件并从 @angular&#x2F;forms 包中导入 FormGroup 和 FormControl 类。</p>
<p><code>import &#123; FormGroup, FormControl &#125; from &#39;@angular/forms&#39;;</code></p>
<ol>
<li><p>创建一个 FormGroup 实例。</p>
<p> 在组件类中创建一个名叫 profileForm 的属性，并设置为 FormGroup 的一个新实例。要初始化这个 FormGroup，请为构造函数提供一个由控件组成的对象，对象中的每个名字都要和表单控件的名字一一对应。对此个人档案表单，要添加两个 FormControl 实例，名字分别为 firstName 和 lastName。</p>
 <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">FormGroup</span>, <span class="title class_">FormControl</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/forms&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line"><span class="attr">selector</span>: <span class="string">&#x27;app-profile-editor&#x27;</span>,</span><br><span class="line"><span class="attr">templateUrl</span>: <span class="string">&#x27;./profile-editor.component.html&#x27;</span>,</span><br><span class="line"><span class="attr">styleUrls</span>: [<span class="string">&#x27;./profile-editor.component.css&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ProfileEditorComponent</span> &#123;</span><br><span class="line"> profileForm = <span class="keyword">new</span> <span class="title class_">FormGroup</span>(&#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="string">&#x27;&#x27;</span>),</span><br><span class="line">    <span class="attr">lastName</span>: <span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="string">&#x27;&#x27;</span>),</span><br><span class="line">    <span class="attr">address</span>: <span class="keyword">new</span> <span class="title class_">FormGroup</span>(&#123;</span><br><span class="line">        <span class="attr">street</span>: <span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="string">&#x27;&#x27;</span>),</span><br><span class="line">        <span class="attr">city</span>: <span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="string">&#x27;&#x27;</span>),</span><br><span class="line">        <span class="attr">state</span>: <span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="string">&#x27;&#x27;</span>),</span><br><span class="line">        <span class="attr">zip</span>: <span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这些独立的表单控件被收集到了一个控件组中。这个 FormGroup 用对象的形式提供了它的模型值，这个值来自组中每个控件的值。FormGroup 实例拥有和 FormControl 实例相同的属性（比如 value、untouched）和方法（比如 setValue()）。</p>
</li>
<li><p>把这个 FormGroup 模型关联到视图。<br> 这个表单组还能跟踪其中每个控件的状态及其变化，所以如果其中的某个控件的状态或值变化了，父控件也会发出一次新的状态变更或值变更事件。该控件组的模型来自它的所有成员。在定义了这个模型之后，你必须更新模板，来把该模型反映到视图中。</p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> [<span class="attr">formGroup</span>]=<span class="string">&quot;profileForm&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;first-name&quot;</span>&gt;</span>First Name: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;first-name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">formControlName</span>=<span class="string">&quot;firstName&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;last-name&quot;</span>&gt;</span>Last Name: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;last-name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">formControlName</span>=<span class="string">&quot;lastName&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">formGroupName</span>=<span class="string">&quot;address&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Address<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;street&quot;</span>&gt;</span>Street: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;street&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">formControlName</span>=<span class="string">&quot;street&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;city&quot;</span>&gt;</span>City: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;city&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">formControlName</span>=<span class="string">&quot;city&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;state&quot;</span>&gt;</span>State: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;state&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">formControlName</span>=<span class="string">&quot;state&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;zip&quot;</span>&gt;</span>Zip Code: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;zip&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">formControlName</span>=<span class="string">&quot;zip&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>就像 FormGroup 所包含的那控件一样，profileForm 这个 FormGroup 也通过 FormGroup 指令绑定到了 form 元素，在该模型和表单中的输入框之间创建了一个通讯层。</p>
</blockquote>
<p> 由 FormControlName 指令提供的 formControlName 属性把每个输入框和 FormGroup 中定义的表单控件绑定起来。这些表单控件会和相应的元素通讯，它们还把更改传给 FormGroup，这个 FormGroup 是模型值的事实之源。</p>
</li>
<li><p>保存表单数据<br> ProfileEditor 组件从用户那里获得输入，但在真实的场景中，你可能想要先捕获表单的值，等将来在组件外部进行处理。FormGroup 指令会监听 form 元素发出的 submit 事件，并发出一个 ngSubmit 事件，让你可以绑定一个回调函数。把 onSubmit() 回调方法添加为 form 标签上的 ngSubmit 事件监听器。</p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> [<span class="attr">formGroup</span>]=<span class="string">&quot;profileForm&quot;</span> (<span class="attr">ngSubmit</span>)=<span class="string">&quot;onSubmit()&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> ProfileEditor 组件上的 onSubmit() 方法会捕获 profileForm 的当前值。要保持该表单的封装性，就要使用 EventEmitter 向组件外部提供该表单的值。下面的例子会使用 console.warn 把这个值记录到浏览器的控制台中。</p>
 <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onSubmit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Use EventEmitter with form value</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="variable language_">this</span>.<span class="property">profileForm</span>.<span class="property">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示此组件</p>
<p> 要显示包含此表单的 ProfileEditor 组件，请把它添加到组件模板中。</p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-profile-editor</span>&gt;</span><span class="tag">&lt;/<span class="name">app-profile-editor</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> ProfileEditor 让你能管理 FormGroup 中的 firstName 和 lastName 等 FormControl 实例。</p>
</li>
</ol>
<h3 id="更新部分数据模型"><a href="#更新部分数据模型" class="headerlink" title="更新部分数据模型"></a>更新部分数据模型</h3><p>当修改包含多个 FormGroup 实例的值时，你可能只希望更新模型中的一部分，而不是完全替换掉。<br>有两种更新模型值的方式：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td>setValue()</td>
<td>使用 setValue() 方法来为单个控件设置新值。setValue() 方法会严格遵循表单组的结构，并整体性替换控件的值。</td>
</tr>
<tr>
<td>patchValue()</td>
<td>用此对象中定义的任意属性对表单模型进行替换。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>setValue() 方法的严格检查可以帮助你捕获复杂表单嵌套中的错误，而 patchValue() 在遇到那些错误时可能会默默的失败。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">updateProfile</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">profileForm</span>.<span class="title function_">patchValue</span>(&#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Nancy&#x27;</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">      <span class="attr">street</span>: <span class="string">&#x27;123 Drew Street&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>profileForm 模型中只有 firstName 和 street 被修改了。注意，street 是在 address 属性的对象中被修改的。这种结构是必须的，因为 patchValue() 方法要针对模型的结构进行更新。patchValue() 只会更新表单模型中所定义的那些属性。</p>
<h3 id="使用-FormBuilder-服务生成控件"><a href="#使用-FormBuilder-服务生成控件" class="headerlink" title="使用 FormBuilder 服务生成控件"></a>使用 FormBuilder 服务生成控件</h3><p>手动创建多个表单控件实例会非常繁琐。FormBuilder 服务提供了一些便捷方法来生成表单控件。FormBuilder 在幕后也使用同样的方式来创建和返回这些实例，只是用起来更简单。<br>通过下列步骤可以利用这项服务。</p>
<ol>
<li><p>导入 FormBuilder 类。</p>
<p> 从 @angular&#x2F;forms 包中导入 FormBuilder 类。</p>
 <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">FormBuilder</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/forms&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注入这个 FormBuilder 服务。</p>
<p> FormBuilder 是一个可注入的服务提供者，它是由 ReactiveFormModule 提供的。只要把它添加到组件的构造函数中就可以注入这个依赖。<br> <code>constructor(private fb: FormBuilder) &#123; &#125;</code></p>
</li>
<li><p>生成表单内容。</p>
<p>FormBuilder 服务有三个方法：control()、group() 和 array()。这些方法都是工厂方法，用于在组件类中分别生成 FormControl、FormGroup 和 FormArray。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"> <span class="keyword">import</span> &#123; <span class="title class_">FormBuilder</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/forms&#x27;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Component</span>(&#123;</span><br><span class="line">     <span class="attr">selector</span>: <span class="string">&#x27;app-profile-editor&#x27;</span>,</span><br><span class="line">     <span class="attr">templateUrl</span>: <span class="string">&#x27;./profile-editor.component.html&#x27;</span>,</span><br><span class="line">     <span class="attr">styleUrls</span>: [<span class="string">&#x27;./profile-editor.component.css&#x27;</span>]</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ProfileEditorComponent</span> &#123;</span><br><span class="line">     profileForm = <span class="variable language_">this</span>.<span class="property">fb</span>.<span class="title function_">group</span>(&#123;</span><br><span class="line">         <span class="attr">firstName</span>: [<span class="string">&#x27;&#x27;</span>],</span><br><span class="line">         <span class="attr">lastName</span>: [<span class="string">&#x27;&#x27;</span>],</span><br><span class="line">         <span class="attr">address</span>: <span class="variable language_">this</span>.<span class="property">fb</span>.<span class="title function_">group</span>(&#123;</span><br><span class="line">         <span class="attr">street</span>: [<span class="string">&#x27;&#x27;</span>],</span><br><span class="line">         <span class="attr">city</span>: [<span class="string">&#x27;&#x27;</span>],</span><br><span class="line">         <span class="attr">state</span>: [<span class="string">&#x27;&#x27;</span>],</span><br><span class="line">         <span class="attr">zip</span>: [<span class="string">&#x27;&#x27;</span>]</span><br><span class="line">         &#125;),</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">     <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> fb: FormBuilder</span>) &#123; &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p> 在上面的例子中，你可以使用 group() 方法，用和前面一样的名字来定义这些属性。这里，每个控件名对应的值都是一个数组，这个数组中的第一项是其初始值。</p>
</li>
</ol>
<h2 id="响应式表单-API-汇总"><a href="#响应式表单-API-汇总" class="headerlink" title="响应式表单 API 汇总"></a>响应式表单 API 汇总</h2><p>下表给出了用于创建和管理响应式表单控件的基础类和服务。要了解完整的语法，请参阅 API 文档中的 Forms 包。</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><table>
<thead>
<tr>
<th>类</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td>AbstractControl</td>
<td>所有三种表单控件类（FormControl、FormGroup 和 FormArray）的抽象基类。它提供了一些公共的行为和属性。</td>
</tr>
<tr>
<td>FormControl</td>
<td>管理单体表单控件的值和有效性状态。它对应于 HTML 的表单控件，比如 <input> 或 <select>。</select></td>
</tr>
<tr>
<td>FormGroup</td>
<td>管理一组 AbstractControl 实例的值和有效性状态。该组的属性中包括了它的子控件。组件中的顶层表单就是 FormGroup。</td>
</tr>
<tr>
<td>FormArray</td>
<td>管理一些 AbstractControl 实例数组的值和有效性状态。</td>
</tr>
<tr>
<td>FormBuilder</td>
<td>一个可注入的服务，提供一些用于提供创建控件实例的工厂方法。</td>
</tr>
<tr>
<td>FormRecord</td>
<td>跟踪 FormControl 实例集合的值和有效性状态，每个实例都具有相同的值类型。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td>FormControlDirective</td>
<td>把一个独立的 FormControl 实例绑定到表单控件元素。</td>
</tr>
<tr>
<td>FormControlName</td>
<td>把一个现有 FormGroup 中的 FormControl 实例根据名字绑定到表单控件元素。</td>
</tr>
<tr>
<td>FormGroupDirective</td>
<td>把一个现有的 FormGroup 实例绑定到 DOM 元素。</td>
</tr>
<tr>
<td>FormGroupName</td>
<td>把一个内嵌的 FormGroup 实例绑定到一个 DOM 元素。</td>
</tr>
<tr>
<td>FormArrayName</td>
<td>把一个内嵌的 FormArray 实例绑定到一个 DOM 元素。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="类型化表单"><a href="#类型化表单" class="headerlink" title="类型化表单"></a>类型化表单</h2><h3 id="自动无类型表单迁移"><a href="#自动无类型表单迁移" class="headerlink" title="自动无类型表单迁移"></a>自动无类型表单迁移</h3><p>升级到 Angular 14 时，包含的迁移将自动使用相应的无类型版本替换代码中的所有表单类。例如，上面的代码段将变为：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> login = <span class="keyword">new</span> <span class="title class_">UntypedFormGroup</span>(&#123;</span><br><span class="line">    <span class="attr">email</span>: <span class="keyword">new</span> <span class="title class_">UntypedFormControl</span>(<span class="string">&#x27;&#x27;</span>),</span><br><span class="line">    <span class="attr">password</span>: <span class="keyword">new</span> <span class="title class_">UntypedFormControl</span>(<span class="string">&#x27;&#x27;</span>),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>每个 Untyped 符号都与以前的 Angular 版本具有完全相同的语义，因此你的应用程序应该像以前一样继续编译。通过删除 Untyped 前缀，你可以增量启用这些类型。</p>
<h3 id="FormControl-：入门"><a href="#FormControl-：入门" class="headerlink" title="FormControl ：入门"></a>FormControl ：入门</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> email = <span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="string">&#x27;angularrox@gmail.com&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>此控件将被自动推断为 FormControl&lt;string|null&gt; 类型。TypeScript 会在整个FormControl API中自动强制执行此类型，例如 email.value 、 email.valueChanges 、 email.setValue(…) 等。</p>
<h4 id="可空性"><a href="#可空性" class="headerlink" title="可空性"></a>可空性</h4><p>你可能想知道：为什么此控件的类型包含 null ？这是因为控件可以随时通过调用 reset 变为 null</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> email = <span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="string">&#x27;angularrox@gmail.com&#x27;</span>);</span><br><span class="line">email.<span class="title function_">reset</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(email.<span class="property">value</span>); <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>TypeScript 将强制你始终处理控件已变为 null 的可能性。如果要使此控件不可为空，可以用 nonNullable 选项。这将导致控件重置为其初始值，而不是 null ：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> email = <span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="string">&#x27;angularrox@gmail.com&#x27;</span>, &#123;<span class="attr">nonNullable</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">email.<span class="title function_">reset</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(email.<span class="property">value</span>); <span class="comment">// angularrox@gmail.com</span></span><br></pre></td></tr></table></figure>
<h4 id="指定显式类型"><a href="#指定显式类型" class="headerlink" title="指定显式类型"></a>指定显式类型</h4><p>可以指定类型，而不是依赖推理。考虑一个初始化为 null 的控件。因为初始值为 null，所以 TypeScript 将推断 FormControl<null>，这比我们想要的要窄。</null></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> email = <span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="literal">null</span>);</span><br><span class="line">email.<span class="title function_">setValue</span>(<span class="string">&#x27;angularrox@gmail.com&#x27;</span>); <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure>
<p>为防止这种情况，我们将类型显式指定为 string|null</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> email = <span class="keyword">new</span> <span class="title class_">FormControl</span>&lt;<span class="built_in">string</span>|<span class="literal">null</span>&gt;(<span class="literal">null</span>);</span><br><span class="line">email.<span class="title function_">setValue</span>(<span class="string">&#x27;angularrox@gmail.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="FormArray-：动态的、同质的集合"><a href="#FormArray-：动态的、同质的集合" class="headerlink" title="FormArray ：动态的、同质的集合"></a>FormArray ：动态的、同质的集合</h4><p>FormArray 包含一个开放式控件列表。type 参数对应于每个内部控件的类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> names = <span class="keyword">new</span> <span class="title class_">FormArray</span>([<span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="string">&#x27;Alex&#x27;</span>)]);</span><br><span class="line">names.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="string">&#x27;Jess&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>此 FormArray 将具有内部控件类型 FormControl&lt;string|null&gt;。</p>
<p>如果你想在数组中有多个不同的元素类型，则必须使用 UntypedFormArray，因为 TypeScript 无法推断哪种元素类型将出现在哪个位置。</p>
<h4 id="FormGroup-和-FormRecord"><a href="#FormGroup-和-FormRecord" class="headerlink" title="FormGroup 和 FormRecord"></a>FormGroup 和 FormRecord</h4><p>Angular 为具有枚举键集的表单提供了 FormGroup 类型，并为开放式或动态组提供了一种名为 FormRecord 的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> login = <span class="keyword">new</span> <span class="title class_">FormGroup</span>(&#123;</span><br><span class="line">    <span class="attr">email</span>: <span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="string">&#x27;&#x27;</span>, &#123;<span class="attr">nonNullable</span>: <span class="literal">true</span>&#125;),</span><br><span class="line">    <span class="attr">password</span>: <span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="string">&#x27;&#x27;</span>, &#123;<span class="attr">nonNullable</span>: <span class="literal">true</span>&#125;),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在任何 FormGroup 上，都可以禁用控件。任何禁用的控件都不会出现在组的值中。</p>
<p>因此，login.value 的类型是 Partial&lt;{email: string, password: string}&gt;。这种类型的 Partial 意味着每个成员可能是未定义的。</p>
<p>更具体地说，login.value.email 的类型是 string|undefined，TypeScript 将强制你处理可能 undefined 的值（如果你启用了 strictNullChecks）。</p>
<p>如果你想访问包括禁用控件的值，从而绕过可能的 undefined 字段，可以用 login.getRawValue()。</p>
<h4 id="FormBuilder-和-NonNullableFormBuilder"><a href="#FormBuilder-和-NonNullableFormBuilder" class="headerlink" title="FormBuilder 和 NonNullableFormBuilder"></a>FormBuilder 和 NonNullableFormBuilder</h4><p>FormBuilder 类已升级为支持新类型，方式与上面的示例相同。</p>
<p>此外，还有一个额外的构建器：NonNullableFormBuilder。它是在所有控件都上指定 {nonNullable: true} 的简写，用来在大型非空表单中消除主要的样板代码。你可以用 FormBuilder 上的 nonNullable 属性访问它：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fb = <span class="keyword">new</span> <span class="title class_">FormBuilder</span>();</span><br><span class="line"><span class="keyword">const</span> login = fb.<span class="property">nonNullable</span>.<span class="title function_">group</span>(&#123;</span><br><span class="line">    <span class="attr">email</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，两个内部控件都将不可为空</p>
<h1 id="表单常用-元素"><a href="#表单常用-元素" class="headerlink" title="表单常用 元素"></a>表单常用 元素</h1><h2 id="NgForm"><a href="#NgForm" class="headerlink" title="NgForm"></a>NgForm</h2><h3 id="类型：DIRECTIVE"><a href="#类型：DIRECTIVE" class="headerlink" title="类型：DIRECTIVE"></a>类型：DIRECTIVE</h3><p>选择器：<br>form:not([ngNoForm]):not([formGroup])<br>ng-form<br>[ngForm]</p>
<p>属性：<br>submitted: boolean	返回是否已触发表单提交。</p>
<p>form: FormGroup	为此表单创建的 FormGroup</p>
<p>@Output()ngSubmit: EventEmitter	“ngSubmit” 的事件发射器</p>
<p>@Input(‘ngFormOptions’) options  NgForm 实例的选项。接受下列属性：updateOn：为所有子级的 NgModel 设置 updateOn 的默认值（除非子 NgModel 通过 ngModelOptions 显式指定了这个值）。可能的值有：’change’ | ‘blur’ | ‘submit’.</p>
<p>formDirective: Form 指令实例。</p>
<p>control: FormGroup 内部 FormGroup 实例。</p>
<p>path: string[] 返回表示该组路径的数组。由于此指令始终位于调用表单的顶层，因此它始终是一个空数组。</p>
<p>controls: {[key: string]: AbstractControl;}	返回此组中控件的映射表。</p>
<p>#myTemplateVar&#x3D;”ngForm”</p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>创建一个顶级的 FormGroup 实例，并把它绑定到一个表单，以跟踪表单的聚合值及其验证状态。</p>
<p>只要你导入了 FormsModule，该指令就会默认在所有 <form> 标签上生效。你不需要再添加任何特殊的选择器。</form></p>
<p>你可以以 ngForm 作为 key 把该指令导出到一个局部模板变量（如 #myForm&#x3D;”ngForm”）。这是可选的，但很有用。来自本指令背后的 FormGroup 实例的很多属性，都被复制到了指令自身，所以拿到一个对该指令的引用就可以让你访问此表单的聚合值和验证状态， 还有那些用户交互类的属性，比如 dirty 和 touched。</p>
<p>要使用该表单注册的子控件，请使用带有 name 属性的 NgModel。你可以使用 NgModelGroup 在表单中创建子组。</p>
<p>如果需要，还可以监听该指令的 ngSubmit 事件，以便当用户触发了一次表单提交时得到通知。发出 ngSubmit 事件时，会携带原始的 DOM 表单提交事件。</p>
<p>在模板驱动表单中，所有 <form> 标签都会自动应用上 NgForm 指令。 如果你只想导入 FormsModule 而不想把它应用于某些表单中，比如，要想使用 HTML5 验证，你可以添加 ngNoForm 属性，这样标签就不会在 <form> 上创建 NgForm 指令了。在响应式表单中，则不需要用 ngNoForm，因为 NgForm 指令不会自动应用到 <form> 标签上，你只要别主动添加 formGroup 指令就可以了。</form></form></form></p>
<h2 id="NgModelGroup"><a href="#NgModelGroup" class="headerlink" title="NgModelGroup"></a>NgModelGroup</h2><h3 id="类型：DIRECTIVE-1"><a href="#类型：DIRECTIVE-1" class="headerlink" title="类型：DIRECTIVE"></a>类型：DIRECTIVE</h3><p>选择器：[ngModelGroup]</p>
<p>属性： @Input(‘ngModelGroup’) name: string 跟踪绑定到指令 NgModelGroup 的名称。该名称对应于父 NgForm 中的键名。</p>
<p>模板变量参考手册： #myTemplateVar&#x3D;”ngModelGroup”</p>
<h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><p>创建 FormGroup 的实例并将其绑定到 DOM 元素。</p>
<p>此指令只能用作 NgForm 的子级（在 <form> 标记内）。</form></p>
<p>使用此指令可以独立于表单的其余部分来验证表单的子组，或者当把领域模型中的某些值和嵌套对象一起使用更有意义时。</p>
<h3 id="在表单组中使用控件"><a href="#在表单组中使用控件" class="headerlink" title="在表单组中使用控件"></a>在表单组中使用控件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;example-app&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;form #f=&quot;ngForm&quot; (ngSubmit)=&quot;onSubmit(f)&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;p *ngIf=&quot;nameCtrl.invalid&quot;&gt;Name is invalid.&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      &lt;div ngModelGroup=&quot;name&quot; #nameCtrl=&quot;ngModelGroup&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;input name=&quot;first&quot; [ngModel]=&quot;name.first&quot; minlength=&quot;2&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;input name=&quot;middle&quot; [ngModel]=&quot;name.middle&quot; maxlength=&quot;2&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;input name=&quot;last&quot; [ngModel]=&quot;name.last&quot; required&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      &lt;input name=&quot;email&quot; ngModel&gt;</span></span><br><span class="line"><span class="string">      &lt;button&gt;Submit&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/form&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;button (click)=&quot;setValue()&quot;&gt;Set value&lt;/button&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">NgModelGroupComp</span> &#123;</span><br><span class="line">  name = &#123;<span class="attr">first</span>: <span class="string">&#x27;Nancy&#x27;</span>, <span class="attr">middle</span>: <span class="string">&#x27;J&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;Drew&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onSubmit</span>(<span class="params">f: NgForm</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">value</span>);  <span class="comment">// &#123;name: &#123;first: &#x27;Nancy&#x27;, middle: &#x27;J&#x27;, last: &#x27;Drew&#x27;&#125;, email: &#x27;&#x27;&#125;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">valid</span>);  <span class="comment">// true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = &#123;<span class="attr">first</span>: <span class="string">&#x27;Bess&#x27;</span>, <span class="attr">middle</span>: <span class="string">&#x27;S&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;Marvin&#x27;</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="NgModel"><a href="#NgModel" class="headerlink" title="NgModel"></a>NgModel</h2><h3 id="类型：DIRECTIVE-2"><a href="#类型：DIRECTIVE-2" class="headerlink" title="类型：DIRECTIVE"></a>类型：DIRECTIVE</h3><p>选择器：<br>[ngModel]:not([formControlName]):not([formControl])</p>
<p>属性：<br>@Input(‘ngModelOptions’) options: {<br>    name?: string;<br>    standalone?: boolean;<br>    updateOn?: FormHooks;<br>}	</p>
<p>跟踪该 ngModel 实例的配置项。name：用来设置表单控件元素的 name 属性的另一种方式。参见把 ngModel 用作独立控件的那个例子。</p>
<p>standalone：如果为 true，则此 ngModel 不会把自己注册进它的父表单中，其行为就像没在表单中一样。默认为 false。</p>
<p>updateOn: 用来定义该何时更新表单控件的值和有效性。默认为 ‘change’。可能的取值为：’change’ | ‘blur’ | ‘submit’。</p>
<p>模板变量参考手册： #myTemplateVar&#x3D;”ngModel”</p>
<h3 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h3><p>根据领域对象创建一个 FormControl 实例，并把它绑定到一个表单控件元素上。</p>
<p>当在 <form> 标签中使用 ngModel 时，你还需要提供一个 name 属性，以便该控件可以使用这个名字把自己注册到父表单中。</form></p>
<p>如果你只是要为表单设置初始值，对 ngModel 使用单向绑定就够了。在提交时，你可以使用从表单导出的值，而不必使用领域模型的值。</p>
<h2 id="FormControl"><a href="#FormControl" class="headerlink" title="FormControl"></a>FormControl</h2><h3 id="类型：CLASS"><a href="#类型：CLASS" class="headerlink" title="类型：CLASS"></a>类型：CLASS</h3><h3 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h3><p>追踪单个表单控件的值和验证状态。</p>
<p>这是 Angular 表单的四个基本构建块之一，与 FormGroup、FormArray 和 FormRecord。它扩展了 AbstractControl 类，该类实现了用于访问值、验证状态、用户交互和事件的大多数基础特性。</p>
<p>FormControl 接受一个通用参数，该参数描述其值的类型。此参数始终隐式包含 null，因为控件可以重置。要更改此行为，请设置 nonNullable 或查看下面的使用说明。</p>
<h2 id="FormGroup"><a href="#FormGroup" class="headerlink" title="FormGroup"></a>FormGroup</h2><h3 id="类型：CLASS-1"><a href="#类型：CLASS-1" class="headerlink" title="类型：CLASS"></a>类型：CLASS</h3><h3 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h3><p>跟踪一组 FormControl 实例的值和有效状态。</p>
<p>FormGroup 是用于在 Angular 中定义表单的四个基本构建块之一，与 FormControl、FormArray 和 FormRecord。</p>
<p>当实例化 FormGroup 时，请传入子控件的集合作为第一个参数。每个子项的键都会注册控件的名称。</p>
<p>FormGroup 适用于提前知道密钥的用例。如果你需要动态添加和删除控件，请改用 FormRecord。</p>
<p>FormGroup 接受一个可选的类型参数 TControl，它是一种以内部控件类型作为值的对象类型。</p>
<h2 id="FormRecord"><a href="#FormRecord" class="headerlink" title="FormRecord"></a>FormRecord</h2><h3 id="类型：CLASS-2"><a href="#类型：CLASS-2" class="headerlink" title="类型：CLASS"></a>类型：CLASS</h3><h3 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h3><p>跟踪 FormControl 实例集合的值和有效性状态，每个实例都具有相同的值类型。</p>
<p>FormRecord 与 FormGroup 非常相似，除了它可以与动态键一起使用，并根据需要添加和删除控件。</p>
<p>FormRecord 接受一个通用参数，该参数描述了它包含的控件的类型。</p>
<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = <span class="keyword">new</span> <span class="title class_">FormRecord</span>(&#123;<span class="attr">bill</span>: <span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="string">&#x27;415-123-456&#x27;</span>)&#125;);</span><br><span class="line">numbers.<span class="title function_">addControl</span>(<span class="string">&#x27;bob&#x27;</span>, <span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="string">&#x27;415-234-567&#x27;</span>));</span><br><span class="line">numbers.<span class="title function_">removeControl</span>(<span class="string">&#x27;bill&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>一个非常简单的例子如下:如何在事先不知道key的情况下,动态地将控件添加到现有的表单中?</p>
<p>对 FormGroup 类进行严格的类型化,这种工作可能会很复杂。</p>
<p>Angular 添加了一个新的 API 来解决这个问题,FormRecord</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> languages = <span class="keyword">new</span> <span class="title class_">FormRecord</span>(&#123;</span><br><span class="line">  <span class="attr">french</span>: <span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="literal">false</span>, &#123; <span class="attr">nonNullable</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">  <span class="attr">english</span>: <span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="literal">false</span>, &#123; <span class="attr">nonNullable</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">languages.<span class="title function_">addControl</span>(<span class="string">&#x27;italian&#x27;</span>, <span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="number">0</span>, &#123; <span class="attr">nonNullable</span>: <span class="literal">true</span> &#125;); <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">languages.<span class="title function_">addControl</span>(<span class="string">&#x27;italian&#x27;</span>, <span class="keyword">new</span> <span class="title class_">FormControl</span>(<span class="literal">false</span>, &#123; <span class="attr">nonNullable</span>: <span class="literal">true</span> &#125;); <span class="comment">// no error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>FormRecord 类允许您动态添加其值必须具有相同类型的控件。</p>
<h2 id="FormArray"><a href="#FormArray" class="headerlink" title="FormArray"></a>FormArray</h2><h3 id="类型：CLASS-3"><a href="#类型：CLASS-3" class="headerlink" title="类型：CLASS"></a>类型：CLASS</h3><h3 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a>说明</h3><p>跟踪 FormControl、FormGroup 或 FormArray 实例的数组的值和有效状态。</p>
<p>FormArray 是 FormGroup 之外的另一个选择，用于管理任意数量的匿名控件。像 FormGroup 实例一样，你也可以往 FormArray 中动态插入和移除控件，并且 FormArray 实例的值和验证状态也是根据它的子控件计算得来的。不过，你不需要为每个控件定义一个名字作为 key，因此，如果你事先不知道子控件的数量，这就是一个很好的选择。</p>
<h3 id="使用说明-1"><a href="#使用说明-1" class="headerlink" title="使用说明"></a>使用说明</h3><ol>
<li>定义 FormArray 控件：<br>为 profileForm 添加一个 aliases 属性，把它定义为 FormArray 类型。<br>使用 FormBuilder.array() 方法来定义该数组，并用 FormBuilder.control() 方法来往该数组中添加一个初始控件。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">profileForm = <span class="variable language_">this</span>.<span class="property">fb</span>.<span class="title function_">group</span>(&#123;</span><br><span class="line">  <span class="attr">firstName</span>: [<span class="string">&#x27;&#x27;</span>, <span class="title class_">Validators</span>.<span class="property">required</span>],</span><br><span class="line">  <span class="attr">lastName</span>: [<span class="string">&#x27;&#x27;</span>],</span><br><span class="line">  <span class="attr">address</span>: <span class="variable language_">this</span>.<span class="property">fb</span>.<span class="title function_">group</span>(&#123;</span><br><span class="line">    <span class="attr">street</span>: [<span class="string">&#x27;&#x27;</span>],</span><br><span class="line">    <span class="attr">city</span>: [<span class="string">&#x27;&#x27;</span>],</span><br><span class="line">    <span class="attr">state</span>: [<span class="string">&#x27;&#x27;</span>],</span><br><span class="line">    <span class="attr">zip</span>: [<span class="string">&#x27;&#x27;</span>]</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">aliases</span>: <span class="variable language_">this</span>.<span class="property">fb</span>.<span class="title function_">array</span>([</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fb</span>.<span class="title function_">control</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  ])</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>访问 FormArray 控件<br>使用 getter 语法创建类属性 aliases，以从父表单组中接收表示绰号的表单数组控件。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> <span class="title function_">aliases</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">profileForm</span>.<span class="title function_">get</span>(<span class="string">&#x27;aliases&#x27;</span>) <span class="keyword">as</span> <span class="title class_">FormArray</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为返回的控件的类型是 AbstractControl，所以你要为该方法提供一个显式的类型声明来访问 FormArray 特有的语法。</p>
<ol start="3">
<li>在模板中显示表单数组<br>要想为表单模型添加 aliases，你必须把它加入到模板中供用户输入。和 FormGroupNameDirective 提供的 formGroupName 一样，FormArrayNameDirective 也使用 formArrayName 在这个 FormArray 实例和模板之间建立绑定。<br>在 formGroupName <div> 元素的结束标签下方，添加一段模板 HTML。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">formArrayName</span>=<span class="string">&quot;aliases&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Aliases<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> (<span class="attr">click</span>)=<span class="string">&quot;addAlias()&quot;</span>&gt;</span>+ Add another alias<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngFor</span>=<span class="string">&quot;let alias of aliases.controls; let i=index&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- The repeated alias template --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;alias-&#123;&#123; i &#125;&#125;&quot;</span>&gt;</span>Alias:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;alias-&#123;&#123; i &#125;&#125;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> [<span class="attr">formControlName</span>]=<span class="string">&quot;i&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>*ngFor 指令对 aliases FormArray 提供的每个 FormControl 进行迭代。因为 FormArray 中的元素是匿名的，所以你要把索引号赋值给 i 变量，并且把它传给每个控件的 formControlName 输入属性。</p>
<p>每当新的 alias 加进来时，FormArray 的实例就会基于这个索引号提供它的控件。这将允许你在每次计算根控件的状态和值时跟踪每个控件。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/01/20/linq/%E6%A0%87%E5%87%86%E6%9F%A5%E8%AF%A2%E8%BF%90%E7%AE%97%E7%AC%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/20/linq/%E6%A0%87%E5%87%86%E6%9F%A5%E8%AF%A2%E8%BF%90%E7%AE%97%E7%AC%A6/" class="post-title-link" itemprop="url">标准查询运算符</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-01-20 13:58:14" itemprop="dateCreated datePublished" datetime="2023-01-20T13:58:14+08:00">2023-01-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-01-31 18:29:13" itemprop="dateModified" datetime="2023-01-31T18:29:13+08:00">2023-01-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>标准查询运算符是组成 LINQ 模式的方法。 这些方法中的大多数都作用于序列；其中序列指其类型实现 IEnumerable<T> 接口或 IQueryable<T> 接口的对象。 标准查询运算符提供包括筛选、投影、聚合、排序等在内的查询功能。</T></T></p>
<p>共有两组 LINQ 标准查询运算符，一组作用于类型 IEnumerable<T> 的对象，另一组作用于类型 IQueryable<T> 的对象。 </T></T></p>
<p>构成每个集合的方法分别是 Enumerable 和 Queryable 类的静态成员。 这些方法被定义为作为方法运行目标的类型的扩展方法。 </p>
<p>各个标准查询运算符在执行时间上有所不同，具体情况取决于它们是返回单一值还是值序列。 返回单一实例值的这些方法（例如 Average 和 Sum）立即执行。 返回序列的方法会延迟查询执行，并返回一个可枚举的对象。</p>
<p>对于在内存中集合上运行的方法（即扩展 IEnumerable<T> 的那些方法），返回的可枚举对象将捕获传递到方法的参数。 在枚举该对象时，将使用查询运算符的逻辑，并返回查询结果。</T></p>
<p>相反，扩展 IQueryable<T> 的方法不会实现任何查询行为。 它们生成一个表示要执行的查询的表达式树。 源 IQueryable<T> 对象执行查询处理。</T></T></p>
<p>查询语法和方法语法在语义上是相同的，但是许多人发现查询语法更简单且更易于阅读。 某些查询必须表示为方法调用。</p>
<p>下面的示例演示一个简单查询表达式以及编写为基于方法的查询的语义上等效的查询。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">QueryVMethodSyntax</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] numbers = &#123; <span class="number">5</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">12</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Query syntax:</span></span><br><span class="line">        IEnumerable&lt;<span class="built_in">int</span>&gt; numQuery1 =</span><br><span class="line">            <span class="keyword">from</span> num <span class="keyword">in</span> numbers</span><br><span class="line">            <span class="keyword">where</span> num % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">            <span class="keyword">orderby</span> num</span><br><span class="line">            <span class="keyword">select</span> num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Method syntax:</span></span><br><span class="line">        IEnumerable&lt;<span class="built_in">int</span>&gt; numQuery2 = numbers.Where(num =&gt; num % <span class="number">2</span> == <span class="number">0</span>).OrderBy(n =&gt; n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span> i <span class="keyword">in</span> numQuery1)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(System.Environment.NewLine);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span> i <span class="keyword">in</span> numQuery2)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Keep the console open in debug mode.</span></span><br><span class="line">        Console.WriteLine(System.Environment.NewLine);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Press any key to exit&quot;</span>);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Output:</span></span><br><span class="line"><span class="comment">    6 8 10 12</span></span><br><span class="line"><span class="comment">    6 8 10 12</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p> 这两个示例的输出是相同的。 可以看到查询变量的类型在两种形式中是相同的：IEnumerable<T>。</T></p>
<h2 id="标准查询运算符的查询表达式语法"><a href="#标准查询运算符的查询表达式语法" class="headerlink" title="标准查询运算符的查询表达式语法"></a>标准查询运算符的查询表达式语法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>查询表达式</th>
</tr>
</thead>
<tbody><tr>
<td>Cast</td>
<td>使用显式类型化范围变量，例如：from int i in numbers</td>
</tr>
<tr>
<td>GroupBy</td>
<td>group … by - 或 - group … by … into</td>
</tr>
<tr>
<td>GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;(IEnumerable<TOuter>, IEnumerable<TInner>, Func&lt;TOuter,TKey&gt;, Func&lt;TInner,TKey&gt;, Func&lt;TOuter,IEnumerable<TInner>, TResult&gt;)</TInner></TInner></TOuter></td>
<td>join … in … on … equals … into …</td>
</tr>
<tr>
<td>Join&lt;TOuter,TInner,TKey,TResult&gt;(IEnumerable<TOuter>, IEnumerable<TInner>, Func&lt;TOuter,TKey&gt;, Func&lt;TInner,TKey&gt;, Func&lt;TOuter,TInner,TResult&gt;)</TInner></TOuter></td>
<td>join … in … on … equals …</td>
</tr>
<tr>
<td>OrderBy&lt;TSource,TKey&gt;(IEnumerable<TSource>, Func&lt;TSource,TKey&gt;)</TSource></td>
<td>orderby</td>
</tr>
<tr>
<td>OrderByDescending&lt;TSource,TKey&gt;(IEnumerable<TSource>, Func&lt;TSource,TKey&gt;)</TSource></td>
<td>orderby … descending</td>
</tr>
<tr>
<td>Select</td>
<td>select</td>
</tr>
<tr>
<td>SelectMany</td>
<td>多个 from 子句</td>
</tr>
<tr>
<td>ThenBy&lt;TSource,TKey&gt;(IOrderedEnumerable<TSource>, Func&lt;TSource,TKey&gt;)</TSource></td>
<td>orderby …, …</td>
</tr>
<tr>
<td>ThenByDescending&lt;TSource,TKey&gt;(IOrderedEnumerable<TSource>, Func&lt;TSource,TKey&gt;)</TSource></td>
<td>orderby …, … descending</td>
</tr>
<tr>
<td>Where</td>
<td>where</td>
</tr>
</tbody></table>
<h2 id="标准查询运算符按执行方式的分类"><a href="#标准查询运算符按执行方式的分类" class="headerlink" title="标准查询运算符按执行方式的分类"></a>标准查询运算符按执行方式的分类</h2><p>标准查询运算符方法的 <code>LINQ to Objects</code> 实现主要通过两种方法之一执行：立即执行和延迟执行。 使用延迟执行的查询运算符可以进一步分为两种类别：流式处理和非流式处理。 </p>
<h3 id="即时"><a href="#即时" class="headerlink" title="即时"></a>即时</h3><p>立即执行指的是读取数据源并执行一次运算。 返回标量结果的所有标准查询运算符都立即执行。 </p>
<p>可以使用 Enumerable.ToList 或 Enumerable.ToArray 方法强制查询立即执行。</p>
<p>立即执行可重用查询结果，而不是查询声明。 结果被检索一次，然后存储以供将来使用。</p>
<h3 id="推迟"><a href="#推迟" class="headerlink" title="推迟"></a>推迟</h3><p>延迟执行指的是不在代码中声明查询的位置执行运算。 仅当对查询变量进行枚举时才执行运算，例如通过使用 foreach 语句执行。 </p>
<p>这意味着，查询的执行结果取决于执行查询而非定义查询时的数据源内容。 </p>
<p>如果多次枚举查询变量，则每次结果可能都不同。 </p>
<p>几乎所有返回类型为 IEnumerable<T> 或 IOrderedEnumerable<TElement> 的标准查询运算符皆以延迟方式执行。 </TElement></T></p>
<p>延迟执行提供了查询重用功能，因为在每次循环访问查询结果时，查询都会从数据源中提取更新的数据。</p>
<h4 id="流式处理"><a href="#流式处理" class="headerlink" title="流式处理"></a>流式处理</h4><p>流式处理运算符不需要在生成元素前读取所有源数据。 在执行时，流式处理运算符一边读取每个源元素，一边对该源元素执行运算，并在可行时生成元素。 </p>
<p>流式处理运算符将持续读取源元素直到可以生成结果元素。 这意味着可能要读取多个源元素才能生成一个结果元素。</p>
<h3 id="非流式处理"><a href="#非流式处理" class="headerlink" title="非流式处理"></a>非流式处理</h3><p>非流式处理运算符必须先读取所有源数据，然后才能生成结果元素。 </p>
<p>排序或分组等运算均属于此类别。 在执行时，非流式处理查询运算符将读取所有源数据，将其放入数据结构，执行运算，然后生成结果元素。</p>
<h2 id="分类表"><a href="#分类表" class="headerlink" title="分类表"></a>分类表</h2><table>
<thead>
<tr>
<th>标准查询运算符</th>
<th>返回类型</th>
<th>立即执行</th>
<th>延迟的流式处理执行</th>
<th>延迟非流式处理执行</th>
</tr>
</thead>
<tbody><tr>
<td>Aggregate</td>
<td>TSource</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>All</td>
<td>Boolen</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Any</td>
<td>Boolen</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>AsEnumerable</td>
<td><code>IEnumerable&lt;T&gt;</code></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>Average</td>
<td>单个数值</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Cast</td>
<td><code>IEnumerable&lt;T&gt;</code></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>Concat</td>
<td><code>IEnumerable&lt;T&gt;</code></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>Contains</td>
<td>Boolen</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Count</td>
<td>Int32</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>DefaultIfEmpty</td>
<td><code>IEnumerable&lt;T&gt;</code></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>Distinct</td>
<td><code>IEnumerable&lt;T&gt;</code></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>ElementAt</td>
<td>TSource</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ElementAtOrDefault</td>
<td>TSource</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Empty</td>
<td>TSource</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Except</td>
<td>TSource</td>
<td></td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>First</td>
<td>TSource</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>FirstOrDefault</td>
<td>TSource</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>GroupBy</td>
<td>TSource</td>
<td></td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>GroupJoin</td>
<td>TSource</td>
<td></td>
<td>X</td>
<td>X</td>
</tr>
</tbody></table>
<h3 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate"></a>Aggregate</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TResult <span class="title">Aggregate</span>&lt;<span class="title">TSource</span>,<span class="title">TAccumulate</span>,<span class="title">TResult</span>&gt; (<span class="params"><span class="keyword">this</span> System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func, Func&lt;TAccumulate,TResult&gt; resultSelector</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>对序列应用累加器函数。 将指定的种子值用作累加器的初始值，并使用指定的函数选择结果值。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TAccumulate <span class="title">Aggregate</span>&lt;<span class="title">TSource</span>,<span class="title">TAccumulate</span>&gt; (<span class="params"><span class="keyword">this</span> System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>对序列应用累加器函数。 将指定的种子值用作累加器初始值。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TSource <span class="title">Aggregate</span>&lt;<span class="title">TSource</span>&gt; (<span class="params"><span class="keyword">this</span> System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TSource,TSource&gt; func</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>对序列应用累加器函数。</p>
<h3 id="ALL"><a href="#ALL" class="headerlink" title="ALL"></a>ALL</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">All</span>&lt;<span class="title">TSource</span>&gt; (<span class="params"><span class="keyword">this</span> System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,<span class="built_in">bool</span>&gt; predicate</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>确定序列中的所有元素是否都满足条件。如果源序列中的每个元素都通过指定谓词中的测试，或者序列为空，则为 true；否则为 false。</p>
<h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">Any</span>&lt;<span class="title">TSource</span>&gt; (<span class="params"><span class="keyword">this</span> System.Collections.Generic.IEnumerable&lt;TSource&gt; source</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>确定序列是否包含任何元素。<br>此方法不返回集合中的任何一个元素， 而是确定集合是否包含任何元素。</p>
<p>一旦可以确定结果，就会停止枚举 source 。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">Any</span>&lt;<span class="title">TSource</span>&gt; (<span class="params"><span class="keyword">this</span> System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,<span class="built_in">bool</span>&gt; predicate</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>确定序列中是否存在任意一个元素满足条件。</p>
<p>如果源序列不为空，并且至少有一个元素通过指定谓词中的测试，则为 true；否则为 false。</p>
<h3 id="AsEnumerable"><a href="#AsEnumerable" class="headerlink" title="AsEnumerable"></a>AsEnumerable</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> System.Collections.Generic.<span class="function"><span class="title">IEnumerable</span>&lt;<span class="title">TSource</span>&gt; <span class="title">AsEnumerable</span>&lt;<span class="title">TSource</span>&gt; (<span class="params"><span class="keyword">this</span> System.Collections.Generic.IEnumerable&lt;TSource&gt; source</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>返回类型化为 <code>IEnumerable&lt;T&gt;</code> 的输入。</p>
<h3 id="Average"><a href="#Average" class="headerlink" title="Average"></a>Average</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">Average</span> (<span class="params"><span class="keyword">this</span> System.Collections.Generic.IEnumerable&lt;<span class="built_in">float</span>&gt; source</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>计算 Single 值序列的平均值。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span>? Average&lt;TSource&gt; (<span class="keyword">this</span> System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,<span class="built_in">int</span>?&gt; selector);</span><br></pre></td></tr></table></figure>
<p>计算可以为 null 的 Int32 值序列的平均值，这些值可通过对输入序列的每个元素调用转换函数获得。</p>
<p>如果源序列为空或仅包含为 null 的值，则为null；否则为值序列的平均值。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>[] fruits = &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;mango&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;passionfruit&quot;</span>, <span class="string">&quot;grape&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">double</span> average = fruits.Average(s =&gt; s.Length);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;The average string length is &#123;0&#125;.&quot;</span>, average);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The average string length is 6.5.</span></span><br></pre></td></tr></table></figure>

<h3 id="Cast"><a href="#Cast" class="headerlink" title="Cast"></a>Cast</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> System.Collections.Generic.<span class="function"><span class="title">IEnumerable</span>&lt;<span class="title">TResult</span>&gt; <span class="title">Cast</span>&lt;<span class="title">TResult</span>&gt; (<span class="params"><span class="keyword">this</span> System.Collections.IEnumerable source</span>)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将 IEnumerable 的元素强制转换为指定的类型。</p>
<h3 id="Concat"><a href="#Concat" class="headerlink" title="Concat"></a>Concat</h3><p>连接两个序列。</p>
<h3 id="ElementAtOrDefault"><a href="#ElementAtOrDefault" class="headerlink" title="ElementAtOrDefault"></a>ElementAtOrDefault</h3><p>返回序列中指定索引处的元素；如果索引超出范围，则返回默认值。</p>
<h3 id="Empty"><a href="#Empty" class="headerlink" title="Empty"></a>Empty</h3><p>返回具有指定类型参数的空 <code>IEnumerable&lt;T&gt;</code>。</p>
<h3 id="Except"><a href="#Except" class="headerlink" title="Except"></a>Except</h3><p>生成两个序列的差集。</p>
<h3 id="First"><a href="#First" class="headerlink" title="First"></a>First</h3><p>返回序列中的第一个元素。</p>
<h3 id="FirstOrDefault"><a href="#FirstOrDefault" class="headerlink" title="FirstOrDefault"></a>FirstOrDefault</h3><p>返回序列中的第一个元素；如果未找到该元素，则返回默认值。</p>
<h3 id="GroupBy"><a href="#GroupBy" class="headerlink" title="GroupBy"></a>GroupBy</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> System.Collections.Generic.<span class="function"><span class="title">IEnumerable</span>&lt;<span class="title">TResult</span>&gt; <span class="title">GroupBy</span>&lt;<span class="title">TSource</span>,<span class="title">TKey</span>,<span class="title">TElement</span>,<span class="title">TResult</span>&gt; (<span class="params"><span class="keyword">this</span> System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt; resultSelector</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>根据指定的键选择器函数对序列中的元素进行分组，并且从每个组及其键中创建结果值。 通过使用指定的函数对每个组的元素进行投影。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GroupBy&lt;TSource,TKey,TElement,TResult&gt;(IEnumerable&lt;TSource&gt;, Func&lt;TSource, TKey&gt;, Func&lt;TSource,TElement&gt;, Func&lt;TKey,IEnumerable&lt;TElement&gt;, TResult&gt;, IEqualityComparer&lt;TKey&gt;)</span><br></pre></td></tr></table></figure>


<h3 id="GroupJoin"><a href="#GroupJoin" class="headerlink" title="GroupJoin"></a>GroupJoin</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;(IEnumerable&lt;TOuter&gt;, IEnumerable&lt;TInner&gt;, Func&lt;TOuter,TKey&gt;, Func&lt;TInner,TKey&gt;, Func&lt;TOuter,IEnumerable&lt;TInner&gt;, TResult&gt;, IEqualityComparer&lt;TKey&gt;)</span><br></pre></td></tr></table></figure>
<p>基于键值等同性对两个序列的元素进行关联，并对结果进行分组。使用指定的 <code>IEqualityComparer&lt;T&gt;</code> 对键进行比较。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
