<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"leetao50.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
<meta property="og:type" content="website">
<meta property="og:title" content="InfoPool">
<meta property="og:url" content="https://leetao50.github.io/page/4/index.html">
<meta property="og:site_name" content="InfoPool">
<meta property="og:description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
<meta property="og:locale" content="zh_CN">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://leetao50.github.io/page/4/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>InfoPool</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">InfoPool</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">私人信息记录</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">记录信息来源网络，内容只为方便查找，非公开信息，非请勿入</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/01/20/linq/%E6%A0%87%E5%87%86%E6%9F%A5%E8%AF%A2%E8%BF%90%E7%AE%97%E7%AC%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/20/linq/%E6%A0%87%E5%87%86%E6%9F%A5%E8%AF%A2%E8%BF%90%E7%AE%97%E7%AC%A6/" class="post-title-link" itemprop="url">标准查询运算符</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-01-20 13:58:14" itemprop="dateCreated datePublished" datetime="2023-01-20T13:58:14+08:00">2023-01-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-01-31 18:29:13" itemprop="dateModified" datetime="2023-01-31T18:29:13+08:00">2023-01-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>标准查询运算符是组成 LINQ 模式的方法。 这些方法中的大多数都作用于序列；其中序列指其类型实现 IEnumerable<T> 接口或 IQueryable<T> 接口的对象。 标准查询运算符提供包括筛选、投影、聚合、排序等在内的查询功能。</T></T></p>
<p>共有两组 LINQ 标准查询运算符，一组作用于类型 IEnumerable<T> 的对象，另一组作用于类型 IQueryable<T> 的对象。 </T></T></p>
<p>构成每个集合的方法分别是 Enumerable 和 Queryable 类的静态成员。 这些方法被定义为作为方法运行目标的类型的扩展方法。 </p>
<p>各个标准查询运算符在执行时间上有所不同，具体情况取决于它们是返回单一值还是值序列。 返回单一实例值的这些方法（例如 Average 和 Sum）立即执行。 返回序列的方法会延迟查询执行，并返回一个可枚举的对象。</p>
<p>对于在内存中集合上运行的方法（即扩展 IEnumerable<T> 的那些方法），返回的可枚举对象将捕获传递到方法的参数。 在枚举该对象时，将使用查询运算符的逻辑，并返回查询结果。</T></p>
<p>相反，扩展 IQueryable<T> 的方法不会实现任何查询行为。 它们生成一个表示要执行的查询的表达式树。 源 IQueryable<T> 对象执行查询处理。</T></T></p>
<p>查询语法和方法语法在语义上是相同的，但是许多人发现查询语法更简单且更易于阅读。 某些查询必须表示为方法调用。</p>
<p>下面的示例演示一个简单查询表达式以及编写为基于方法的查询的语义上等效的查询。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">QueryVMethodSyntax</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] numbers = &#123; <span class="number">5</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">12</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Query syntax:</span></span><br><span class="line">        IEnumerable&lt;<span class="built_in">int</span>&gt; numQuery1 =</span><br><span class="line">            <span class="keyword">from</span> num <span class="keyword">in</span> numbers</span><br><span class="line">            <span class="keyword">where</span> num % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">            <span class="keyword">orderby</span> num</span><br><span class="line">            <span class="keyword">select</span> num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Method syntax:</span></span><br><span class="line">        IEnumerable&lt;<span class="built_in">int</span>&gt; numQuery2 = numbers.Where(num =&gt; num % <span class="number">2</span> == <span class="number">0</span>).OrderBy(n =&gt; n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span> i <span class="keyword">in</span> numQuery1)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(System.Environment.NewLine);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span> i <span class="keyword">in</span> numQuery2)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Keep the console open in debug mode.</span></span><br><span class="line">        Console.WriteLine(System.Environment.NewLine);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Press any key to exit&quot;</span>);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Output:</span></span><br><span class="line"><span class="comment">    6 8 10 12</span></span><br><span class="line"><span class="comment">    6 8 10 12</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p> 这两个示例的输出是相同的。 可以看到查询变量的类型在两种形式中是相同的：IEnumerable<T>。</T></p>
<h2 id="标准查询运算符的查询表达式语法"><a href="#标准查询运算符的查询表达式语法" class="headerlink" title="标准查询运算符的查询表达式语法"></a>标准查询运算符的查询表达式语法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>查询表达式</th>
</tr>
</thead>
<tbody><tr>
<td>Cast</td>
<td>使用显式类型化范围变量，例如：from int i in numbers</td>
</tr>
<tr>
<td>GroupBy</td>
<td>group … by - 或 - group … by … into</td>
</tr>
<tr>
<td>GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;(IEnumerable<TOuter>, IEnumerable<TInner>, Func&lt;TOuter,TKey&gt;, Func&lt;TInner,TKey&gt;, Func&lt;TOuter,IEnumerable<TInner>, TResult&gt;)</TInner></TInner></TOuter></td>
<td>join … in … on … equals … into …</td>
</tr>
<tr>
<td>Join&lt;TOuter,TInner,TKey,TResult&gt;(IEnumerable<TOuter>, IEnumerable<TInner>, Func&lt;TOuter,TKey&gt;, Func&lt;TInner,TKey&gt;, Func&lt;TOuter,TInner,TResult&gt;)</TInner></TOuter></td>
<td>join … in … on … equals …</td>
</tr>
<tr>
<td>OrderBy&lt;TSource,TKey&gt;(IEnumerable<TSource>, Func&lt;TSource,TKey&gt;)</TSource></td>
<td>orderby</td>
</tr>
<tr>
<td>OrderByDescending&lt;TSource,TKey&gt;(IEnumerable<TSource>, Func&lt;TSource,TKey&gt;)</TSource></td>
<td>orderby … descending</td>
</tr>
<tr>
<td>Select</td>
<td>select</td>
</tr>
<tr>
<td>SelectMany</td>
<td>多个 from 子句</td>
</tr>
<tr>
<td>ThenBy&lt;TSource,TKey&gt;(IOrderedEnumerable<TSource>, Func&lt;TSource,TKey&gt;)</TSource></td>
<td>orderby …, …</td>
</tr>
<tr>
<td>ThenByDescending&lt;TSource,TKey&gt;(IOrderedEnumerable<TSource>, Func&lt;TSource,TKey&gt;)</TSource></td>
<td>orderby …, … descending</td>
</tr>
<tr>
<td>Where</td>
<td>where</td>
</tr>
</tbody></table>
<h2 id="标准查询运算符按执行方式的分类"><a href="#标准查询运算符按执行方式的分类" class="headerlink" title="标准查询运算符按执行方式的分类"></a>标准查询运算符按执行方式的分类</h2><p>标准查询运算符方法的 <code>LINQ to Objects</code> 实现主要通过两种方法之一执行：立即执行和延迟执行。 使用延迟执行的查询运算符可以进一步分为两种类别：流式处理和非流式处理。 </p>
<h3 id="即时"><a href="#即时" class="headerlink" title="即时"></a>即时</h3><p>立即执行指的是读取数据源并执行一次运算。 返回标量结果的所有标准查询运算符都立即执行。 </p>
<p>可以使用 Enumerable.ToList 或 Enumerable.ToArray 方法强制查询立即执行。</p>
<p>立即执行可重用查询结果，而不是查询声明。 结果被检索一次，然后存储以供将来使用。</p>
<h3 id="推迟"><a href="#推迟" class="headerlink" title="推迟"></a>推迟</h3><p>延迟执行指的是不在代码中声明查询的位置执行运算。 仅当对查询变量进行枚举时才执行运算，例如通过使用 foreach 语句执行。 </p>
<p>这意味着，查询的执行结果取决于执行查询而非定义查询时的数据源内容。 </p>
<p>如果多次枚举查询变量，则每次结果可能都不同。 </p>
<p>几乎所有返回类型为 IEnumerable<T> 或 IOrderedEnumerable<TElement> 的标准查询运算符皆以延迟方式执行。 </TElement></T></p>
<p>延迟执行提供了查询重用功能，因为在每次循环访问查询结果时，查询都会从数据源中提取更新的数据。</p>
<h4 id="流式处理"><a href="#流式处理" class="headerlink" title="流式处理"></a>流式处理</h4><p>流式处理运算符不需要在生成元素前读取所有源数据。 在执行时，流式处理运算符一边读取每个源元素，一边对该源元素执行运算，并在可行时生成元素。 </p>
<p>流式处理运算符将持续读取源元素直到可以生成结果元素。 这意味着可能要读取多个源元素才能生成一个结果元素。</p>
<h3 id="非流式处理"><a href="#非流式处理" class="headerlink" title="非流式处理"></a>非流式处理</h3><p>非流式处理运算符必须先读取所有源数据，然后才能生成结果元素。 </p>
<p>排序或分组等运算均属于此类别。 在执行时，非流式处理查询运算符将读取所有源数据，将其放入数据结构，执行运算，然后生成结果元素。</p>
<h2 id="分类表"><a href="#分类表" class="headerlink" title="分类表"></a>分类表</h2><table>
<thead>
<tr>
<th>标准查询运算符</th>
<th>返回类型</th>
<th>立即执行</th>
<th>延迟的流式处理执行</th>
<th>延迟非流式处理执行</th>
</tr>
</thead>
<tbody><tr>
<td>Aggregate</td>
<td>TSource</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>All</td>
<td>Boolen</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Any</td>
<td>Boolen</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>AsEnumerable</td>
<td><code>IEnumerable&lt;T&gt;</code></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>Average</td>
<td>单个数值</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Cast</td>
<td><code>IEnumerable&lt;T&gt;</code></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>Concat</td>
<td><code>IEnumerable&lt;T&gt;</code></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>Contains</td>
<td>Boolen</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Count</td>
<td>Int32</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>DefaultIfEmpty</td>
<td><code>IEnumerable&lt;T&gt;</code></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>Distinct</td>
<td><code>IEnumerable&lt;T&gt;</code></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>ElementAt</td>
<td>TSource</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ElementAtOrDefault</td>
<td>TSource</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Empty</td>
<td>TSource</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Except</td>
<td>TSource</td>
<td></td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>First</td>
<td>TSource</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>FirstOrDefault</td>
<td>TSource</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>GroupBy</td>
<td>TSource</td>
<td></td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>GroupJoin</td>
<td>TSource</td>
<td></td>
<td>X</td>
<td>X</td>
</tr>
</tbody></table>
<h3 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate"></a>Aggregate</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TResult <span class="title">Aggregate</span>&lt;<span class="title">TSource</span>,<span class="title">TAccumulate</span>,<span class="title">TResult</span>&gt; (<span class="params"><span class="keyword">this</span> System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func, Func&lt;TAccumulate,TResult&gt; resultSelector</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>对序列应用累加器函数。 将指定的种子值用作累加器的初始值，并使用指定的函数选择结果值。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TAccumulate <span class="title">Aggregate</span>&lt;<span class="title">TSource</span>,<span class="title">TAccumulate</span>&gt; (<span class="params"><span class="keyword">this</span> System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>对序列应用累加器函数。 将指定的种子值用作累加器初始值。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TSource <span class="title">Aggregate</span>&lt;<span class="title">TSource</span>&gt; (<span class="params"><span class="keyword">this</span> System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TSource,TSource&gt; func</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>对序列应用累加器函数。</p>
<h3 id="ALL"><a href="#ALL" class="headerlink" title="ALL"></a>ALL</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">All</span>&lt;<span class="title">TSource</span>&gt; (<span class="params"><span class="keyword">this</span> System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,<span class="built_in">bool</span>&gt; predicate</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>确定序列中的所有元素是否都满足条件。如果源序列中的每个元素都通过指定谓词中的测试，或者序列为空，则为 true；否则为 false。</p>
<h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">Any</span>&lt;<span class="title">TSource</span>&gt; (<span class="params"><span class="keyword">this</span> System.Collections.Generic.IEnumerable&lt;TSource&gt; source</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>确定序列是否包含任何元素。<br>此方法不返回集合中的任何一个元素， 而是确定集合是否包含任何元素。</p>
<p>一旦可以确定结果，就会停止枚举 source 。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">Any</span>&lt;<span class="title">TSource</span>&gt; (<span class="params"><span class="keyword">this</span> System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,<span class="built_in">bool</span>&gt; predicate</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>确定序列中是否存在任意一个元素满足条件。</p>
<p>如果源序列不为空，并且至少有一个元素通过指定谓词中的测试，则为 true；否则为 false。</p>
<h3 id="AsEnumerable"><a href="#AsEnumerable" class="headerlink" title="AsEnumerable"></a>AsEnumerable</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> System.Collections.Generic.<span class="function"><span class="title">IEnumerable</span>&lt;<span class="title">TSource</span>&gt; <span class="title">AsEnumerable</span>&lt;<span class="title">TSource</span>&gt; (<span class="params"><span class="keyword">this</span> System.Collections.Generic.IEnumerable&lt;TSource&gt; source</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>返回类型化为 <code>IEnumerable&lt;T&gt;</code> 的输入。</p>
<h3 id="Average"><a href="#Average" class="headerlink" title="Average"></a>Average</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">Average</span> (<span class="params"><span class="keyword">this</span> System.Collections.Generic.IEnumerable&lt;<span class="built_in">float</span>&gt; source</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>计算 Single 值序列的平均值。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span>? Average&lt;TSource&gt; (<span class="keyword">this</span> System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,<span class="built_in">int</span>?&gt; selector);</span><br></pre></td></tr></table></figure>
<p>计算可以为 null 的 Int32 值序列的平均值，这些值可通过对输入序列的每个元素调用转换函数获得。</p>
<p>如果源序列为空或仅包含为 null 的值，则为null；否则为值序列的平均值。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>[] fruits = &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;mango&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;passionfruit&quot;</span>, <span class="string">&quot;grape&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">double</span> average = fruits.Average(s =&gt; s.Length);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;The average string length is &#123;0&#125;.&quot;</span>, average);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The average string length is 6.5.</span></span><br></pre></td></tr></table></figure>

<h3 id="Cast"><a href="#Cast" class="headerlink" title="Cast"></a>Cast</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> System.Collections.Generic.<span class="function"><span class="title">IEnumerable</span>&lt;<span class="title">TResult</span>&gt; <span class="title">Cast</span>&lt;<span class="title">TResult</span>&gt; (<span class="params"><span class="keyword">this</span> System.Collections.IEnumerable source</span>)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将 IEnumerable 的元素强制转换为指定的类型。</p>
<h3 id="Concat"><a href="#Concat" class="headerlink" title="Concat"></a>Concat</h3><p>连接两个序列。</p>
<h3 id="ElementAtOrDefault"><a href="#ElementAtOrDefault" class="headerlink" title="ElementAtOrDefault"></a>ElementAtOrDefault</h3><p>返回序列中指定索引处的元素；如果索引超出范围，则返回默认值。</p>
<h3 id="Empty"><a href="#Empty" class="headerlink" title="Empty"></a>Empty</h3><p>返回具有指定类型参数的空 <code>IEnumerable&lt;T&gt;</code>。</p>
<h3 id="Except"><a href="#Except" class="headerlink" title="Except"></a>Except</h3><p>生成两个序列的差集。</p>
<h3 id="First"><a href="#First" class="headerlink" title="First"></a>First</h3><p>返回序列中的第一个元素。</p>
<h3 id="FirstOrDefault"><a href="#FirstOrDefault" class="headerlink" title="FirstOrDefault"></a>FirstOrDefault</h3><p>返回序列中的第一个元素；如果未找到该元素，则返回默认值。</p>
<h3 id="GroupBy"><a href="#GroupBy" class="headerlink" title="GroupBy"></a>GroupBy</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> System.Collections.Generic.<span class="function"><span class="title">IEnumerable</span>&lt;<span class="title">TResult</span>&gt; <span class="title">GroupBy</span>&lt;<span class="title">TSource</span>,<span class="title">TKey</span>,<span class="title">TElement</span>,<span class="title">TResult</span>&gt; (<span class="params"><span class="keyword">this</span> System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt; resultSelector</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>根据指定的键选择器函数对序列中的元素进行分组，并且从每个组及其键中创建结果值。 通过使用指定的函数对每个组的元素进行投影。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GroupBy&lt;TSource,TKey,TElement,TResult&gt;(IEnumerable&lt;TSource&gt;, Func&lt;TSource, TKey&gt;, Func&lt;TSource,TElement&gt;, Func&lt;TKey,IEnumerable&lt;TElement&gt;, TResult&gt;, IEqualityComparer&lt;TKey&gt;)</span><br></pre></td></tr></table></figure>


<h3 id="GroupJoin"><a href="#GroupJoin" class="headerlink" title="GroupJoin"></a>GroupJoin</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;(IEnumerable&lt;TOuter&gt;, IEnumerable&lt;TInner&gt;, Func&lt;TOuter,TKey&gt;, Func&lt;TInner,TKey&gt;, Func&lt;TOuter,IEnumerable&lt;TInner&gt;, TResult&gt;, IEqualityComparer&lt;TKey&gt;)</span><br></pre></td></tr></table></figure>
<p>基于键值等同性对两个序列的元素进行关联，并对结果进行分组。使用指定的 <code>IEqualityComparer&lt;T&gt;</code> 对键进行比较。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2022/12/17/linq/LINQ%E6%9F%A5%E8%AF%A2%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/17/linq/LINQ%E6%9F%A5%E8%AF%A2%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">post</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-17 23:26:42" itemprop="dateCreated datePublished" datetime="2022-12-17T23:26:42+08:00">2022-12-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-01-20 09:52:01" itemprop="dateModified" datetime="2023-01-20T09:52:01+08:00">2023-01-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="查询操作的三个部分"><a href="#查询操作的三个部分" class="headerlink" title="查询操作的三个部分"></a>查询操作的三个部分</h1><p>所有 LINQ 查询操作都由以下三个不同的操作组成：</p>
<ol>
<li>获取数据源。</li>
<li>创建查询。</li>
<li>执行查询。</li>
</ol>
<p>下面的示例演示如何用源代码表示查询操作的三个部分。 为方便起见，此示例将一个整数数组用作数据源；但其中涉及的概念同样适用于其他数据源。 本主题的其余部分也会引用此示例。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">IntroToLINQ</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The Three Parts of a LINQ Query:</span></span><br><span class="line">        <span class="comment">// 1. Data source.</span></span><br><span class="line">        <span class="built_in">int</span>[] numbers = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">7</span>] &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Query creation.</span></span><br><span class="line">        <span class="comment">// numQuery is an IEnumerable&lt;int&gt;</span></span><br><span class="line">        <span class="keyword">var</span> numQuery =</span><br><span class="line">            <span class="function"><span class="keyword">from</span> num <span class="keyword">in</span> numbers</span></span><br><span class="line"><span class="function">            <span class="title">where</span> (<span class="params">num % <span class="number">2</span></span>)</span> == <span class="number">0</span></span><br><span class="line">            <span class="keyword">select</span> num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Query execution.</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span> num <span class="keyword">in</span> numQuery)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(<span class="string">&quot;&#123;0,1&#125; &quot;</span>, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h2><p>上例中，数据源是一个数组，因此它隐式支持泛型 IEnumerable<T> 接口。 这一事实意味着该数据源可以用 LINQ 进行查询。 查询在 foreach 语句中执行，且 foreach 需要 IEnumerable 或 IEnumerable<T>。 支持 IEnumerable<T> 或派生接口（如泛型 IQueryable<T>）的类型称为可查询类型 。</T></T></T></T></p>
<p>可查询类型不需要进行修改或特殊处理就可以用作 LINQ 数据源。 如果源数据还没有作为可查询类型出现在内存中，则 LINQ 提供程序必须以此方式表示源数据。 例如，LINQ to XML 将 XML 文档加载到可查询的 XElement 类型中：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a data source from an XML document.</span></span><br><span class="line"><span class="comment">// using System.Xml.Linq;</span></span><br><span class="line">XElement contacts = XElement.Load(<span class="string">@&quot;c:\myContactList.xml&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>有关如何创建特定类型的数据源的详细信息，请参阅各种 LINQ 提供程序的文档。 但基本规则很简单：LINQ 数据源是支持泛型 IEnumerable<T> 接口或从中继承的接口的任意对象。</T></p>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>查询指定要从数据源中检索的信息。 查询还可以指定在返回这些信息之前如何对其进行排序、分组和结构化。 查询存储在查询变量中，并用查询表达式进行初始化。 为使编写查询的工作变得更加容易，C# 引入了新的查询语法。</p>
<p>上一个示例中的查询从整数数组中返回所有偶数。 该查询表达式包含三个子句：from、where 和 select。 （如果熟悉 SQL，会注意到这些子句的顺序与 SQL 中的顺序相反。）from 子句指定数据源，where 子句应用筛选器，select 子句指定返回的元素的类型。</p>
<h3 id="查询执行"><a href="#查询执行" class="headerlink" title="查询执行"></a>查询执行</h3><h4 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h4><p>如前所述，查询变量本身只存储查询命令。 查询的实际执行将推迟到在 foreach 语句中循环访问查询变量之后进行。 此概念称为延迟执行，下面的示例对此进行了演示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Query execution.</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> num <span class="keyword">in</span> numQuery)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(<span class="string">&quot;&#123;0,1&#125; &quot;</span>, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>foreach 语句也是检索查询结果的地方。 例如，在上一个查询中，迭代变量 num 保存了返回的序列中的每个值（一次保存一个值）。</p>
<p>由于查询变量本身从不保存查询结果，因此可以根据需要随意执行查询。 例如，可以通过一个单独的应用程序持续更新数据库。 在应用程序中，可以创建一个检索最新数据的查询，并可以按某一时间间隔反复执行该查询以便每次检索不同的结果。</p>
<h4 id="强制立即执行"><a href="#强制立即执行" class="headerlink" title="强制立即执行"></a>强制立即执行</h4><p>对一系列源元素执行聚合函数的查询必须首先循环访问这些元素。 Count、Max、Average 和 First 就属于此类查询。 由于查询本身必须使用 foreach 以便返回结果，因此这些查询在执行时不使用显式 foreach 语句。 另外还要注意，这些类型的查询返回单个值，而不是 IEnumerable 集合。 下面的查询返回源数组中偶数的计数：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> evenNumQuery =</span><br><span class="line">    <span class="function"><span class="keyword">from</span> num <span class="keyword">in</span> numbers</span></span><br><span class="line"><span class="function">    <span class="title">where</span> (<span class="params">num % <span class="number">2</span></span>)</span> == <span class="number">0</span></span><br><span class="line">    <span class="keyword">select</span> num;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> evenNumCount = evenNumQuery.Count();</span><br></pre></td></tr></table></figure>

<p>要强制立即执行任何查询并缓存其结果，可调用 ToList 或 ToArray 方法。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; numQuery2 =</span><br><span class="line">    (<span class="function"><span class="keyword">from</span> num <span class="keyword">in</span> numbers</span></span><br><span class="line"><span class="function">     <span class="title">where</span> (<span class="params">num % <span class="number">2</span></span>)</span> == <span class="number">0</span></span><br><span class="line">     <span class="keyword">select</span> num).ToList();</span><br><span class="line"></span><br><span class="line"><span class="comment">// or like this:</span></span><br><span class="line"><span class="comment">// numQuery3 is still an int[]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numQuery3 =</span><br><span class="line">    (<span class="function"><span class="keyword">from</span> num <span class="keyword">in</span> numbers</span></span><br><span class="line"><span class="function">     <span class="title">where</span> (<span class="params">num % <span class="number">2</span></span>)</span> == <span class="number">0</span></span><br><span class="line">     <span class="keyword">select</span> num).ToArray();</span><br></pre></td></tr></table></figure>

<h1 id="查询表达式基础"><a href="#查询表达式基础" class="headerlink" title="查询表达式基础"></a>查询表达式基础</h1><h2 id="查询是什么及其作用是什么？"><a href="#查询是什么及其作用是什么？" class="headerlink" title="查询是什么及其作用是什么？"></a>查询是什么及其作用是什么？</h2><p>查询是一组指令，描述要从给定数据源检索的数据以及返回的数据应具有的形状和组织。 查询与它生成的结果不同。</p>
<p>从应用程序的角度来看，原始源数据的特定类型和结构并不重要。 应用程序始终将源数据视为 <code>IEnumerable&lt;T&gt;</code> 或 <code>IQueryable&lt;T&gt;</code> 集合。 </p>
<p>对于此源序列，查询可能会执行三种操作之一：</p>
<ul>
<li>检索元素的子集以生成新序列，而不修改各个元素。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;<span class="built_in">int</span>&gt; highScoresQuery =</span><br><span class="line">    <span class="keyword">from</span> score <span class="keyword">in</span> scores</span><br><span class="line">    <span class="keyword">where</span> score &gt; <span class="number">80</span></span><br><span class="line">    <span class="keyword">orderby</span> score <span class="keyword">descending</span></span><br><span class="line">    <span class="keyword">select</span> score;</span><br></pre></td></tr></table></figure></li>
<li>如前面的示例所示检索元素的序列，但是将它们转换为新类型的对象.下面的示例演示从 int 到 string 的投影。 请注意 highScoresQuery 的新类型。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;<span class="built_in">string</span>&gt; highScoresQuery2 =</span><br><span class="line">    <span class="keyword">from</span> score <span class="keyword">in</span> scores</span><br><span class="line">    <span class="keyword">where</span> score &gt; <span class="number">80</span></span><br><span class="line">    <span class="keyword">orderby</span> score <span class="keyword">descending</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">$&quot;The score is <span class="subst">&#123;score&#125;</span>&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li>检索有关源数据的单独值<ul>
<li>与特定条件匹配的元素数。</li>
<li>具有最大或最小值的元素。</li>
<li>与某个条件匹配的第一个元素，或指定元素集中特定值的总和。 例如，下面的查询从 scores 整数数组返回大于 80 的分数的数量：<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> highScoreCount = (</span><br><span class="line">    <span class="keyword">from</span> score <span class="keyword">in</span> scores</span><br><span class="line">    <span class="keyword">where</span> score &gt; <span class="number">80</span></span><br><span class="line">    <span class="keyword">select</span> score</span><br><span class="line">).Count();</span><br></pre></td></tr></table></figure>
在前面的示例中，请注意在调用 Count 方法之前，在查询表达式两边使用了括号。 也可以通过使用新变量存储具体结果，来表示此行为。 这种方法更具可读性，因为它使存储查询的变量与存储结果的查询分开。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;<span class="built_in">int</span>&gt; highScoresQuery3 =</span><br><span class="line">    <span class="keyword">from</span> score <span class="keyword">in</span> scores</span><br><span class="line">    <span class="keyword">where</span> score &gt; <span class="number">80</span></span><br><span class="line">    <span class="keyword">select</span> score;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> scoreCount = highScoresQuery3.Count();</span><br></pre></td></tr></table></figure>
在上面的示例中，查询在 Count 调用中执行，因为 Count 必须循环访问结果才能确定 highScoresQuery 返回的元素数。</li>
</ul>
</li>
</ul>
<h2 id="查询表达式是什么？"><a href="#查询表达式是什么？" class="headerlink" title="查询表达式是什么？"></a>查询表达式是什么？</h2><p>查询表达式是以查询语法表示的查询。它如同任何其他表达式一样，可以在 C# 表达式有效的任何上下文中使用。</p>
<p>查询表达式必须以 from 子句开头，且必须以 select 或 group 子句结尾。<br>在第一个 from 子句与最后一个 select 或 group 子句之间，可以包含以下这些可选子句中的一个或多个：where、orderby、join、let，甚至是其他 from 子句。<br>还可以使用 into 关键字，使 join 或 group 子句的结果可以充当相同查询表达式中的其他查询子句的源。</p>
<h2 id="查询变量"><a href="#查询变量" class="headerlink" title="查询变量"></a>查询变量</h2><p>查询变量是存储查询而不是查询结果的任何变量。<br>下面的代码示例演示一个简单查询表达式，它具有一个数据源、一个筛选子句、一个排序子句并且不转换源元素。 该查询以 select 子句结尾。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Data source.</span></span><br><span class="line"><span class="built_in">int</span>[] scores = &#123; <span class="number">90</span>, <span class="number">71</span>, <span class="number">82</span>, <span class="number">93</span>, <span class="number">75</span>, <span class="number">82</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Query Expression.</span></span><br><span class="line">IEnumerable&lt;<span class="built_in">int</span>&gt; scoreQuery = <span class="comment">//query variable</span></span><br><span class="line">    <span class="keyword">from</span> score <span class="keyword">in</span> scores <span class="comment">//required</span></span><br><span class="line">    <span class="keyword">where</span> score &gt; <span class="number">80</span> <span class="comment">// optional</span></span><br><span class="line">    <span class="keyword">orderby</span> score <span class="keyword">descending</span> <span class="comment">// optional</span></span><br><span class="line">    <span class="keyword">select</span> score; <span class="comment">//must end with select or group</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute the query to produce the results</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> testScore <span class="keyword">in</span> scoreQuery)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(testScore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output: 93 90 82 82</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，scoreQuery 是查询变量，它有时仅仅称为查询。 查询变量不存储在 foreach 循环生成中的任何实际结果数据。 并且当 foreach 语句执行时，查询结果不会通过查询变量 scoreQuery 返回。 而是通过迭代变量 testScore 返回。 scoreQuery 变量可以在另一个 foreach 循环中进行循环访问。 只要既没有修改它，也没有修改数据源，便会生成相同结果。</p>
<p>查询变量可以存储采用查询语法、方法语法或是两者的组合进行表示的查询。 在以下示例中，queryMajorCities 和 queryMajorCities2 都是查询变量：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Query syntax</span></span><br><span class="line">IEnumerable&lt;City&gt; queryMajorCities =</span><br><span class="line">    <span class="keyword">from</span> city <span class="keyword">in</span> cities</span><br><span class="line">    <span class="keyword">where</span> city.Population &gt; <span class="number">100000</span></span><br><span class="line">    <span class="keyword">select</span> city;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Method-based syntax</span></span><br><span class="line">IEnumerable&lt;City&gt; queryMajorCities2 = cities.Where(c =&gt; c.Population &gt; <span class="number">100000</span>);</span><br></pre></td></tr></table></figure>
<h2 id="查询变量的显式和隐式类型化"><a href="#查询变量的显式和隐式类型化" class="headerlink" title="查询变量的显式和隐式类型化"></a>查询变量的显式和隐式类型化</h2><p>通常提供查询变量的显式类型以便显示查询变量与 select 子句之间的类型关系。 但是，还可以使用 var 关键字指示编译器在编译时推断查询变量（或任何其他局部变量）的类型</p>
<h2 id="开始查询表达式"><a href="#开始查询表达式" class="headerlink" title="开始查询表达式"></a>开始查询表达式</h2><p>查询表达式必须以 from 子句开头。 它指定数据源以及范围变量。 范围变量表示遍历源序列时，源序列中的每个连续元素。 范围变量基于数据源中元素的类型进行强类型化。 在下面的示例中，因为 countries 是 Country 对象的数组，所以范围变量也类型化为 Country。 因为范围变量是强类型，所以可以使用点运算符访问该类型的任何可用成员。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;Country&gt; countryAreaQuery =</span><br><span class="line">    <span class="keyword">from</span> country <span class="keyword">in</span> countries</span><br><span class="line">    <span class="keyword">where</span> country.Area &gt; <span class="number">500000</span> <span class="comment">//sq km</span></span><br><span class="line">    <span class="keyword">select</span> country;</span><br></pre></td></tr></table></figure>

<p>范围变量一直处于范围中，直到查询使用分号或 continuation 子句退出。</p>
<p>查询表达式可能会包含多个 from 子句。 在源序列中的每个元素本身是集合或包含集合时，可使用其他 from 子句。 例如，假设具有 Country 对象的集合，其中每个对象都包含名为 Cities 的 City 对象集合。 若要查询每个 Country 中的 City 对象，请使用两个 from 子句，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;City&gt; cityQuery =</span><br><span class="line">    <span class="keyword">from</span> country <span class="keyword">in</span> countries</span><br><span class="line">    <span class="keyword">from</span> city <span class="keyword">in</span> country.Cities</span><br><span class="line">    <span class="keyword">where</span> city.Population &gt; <span class="number">10000</span></span><br><span class="line">    <span class="keyword">select</span> city;</span><br></pre></td></tr></table></figure>
<h2 id="结束查询表达式"><a href="#结束查询表达式" class="headerlink" title="结束查询表达式"></a>结束查询表达式</h2><p>查询表达式必须以 group 子句或 select 子句结尾。</p>
<h3 id="group-子句"><a href="#group-子句" class="headerlink" title="group 子句"></a>group 子句</h3><p>使用 group 子句可生成按指定键组织的组的序列。 键可以是任何数据类型。 例如，以下查询会创建包含一个或多个 Country 对象，并且其关键值是数值为国家&#x2F;地区名称首字母的 char 类型。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> queryCountryGroups =</span><br><span class="line">    <span class="keyword">from</span> country <span class="keyword">in</span> countries</span><br><span class="line">    <span class="keyword">group</span> country <span class="keyword">by</span> country.Name[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<h3 id="select-子句"><a href="#select-子句" class="headerlink" title="select 子句"></a>select 子句</h3><p>使用 select 子句可生成所有其他类型的序列。 简单 select 子句只生成类型与数据源中包含的对象相同的对象的序列。 在此示例中，数据源包含 Country 对象。 orderby 子句只按新顺序对元素进行排序，而 select 子句生成重新排序的 Country 对象的序列。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;Country&gt; sortedQuery =</span><br><span class="line">    <span class="keyword">from</span> country <span class="keyword">in</span> countries</span><br><span class="line">    <span class="keyword">orderby</span> country.Area</span><br><span class="line">    <span class="keyword">select</span> country;</span><br></pre></td></tr></table></figure>

<p>select 子句可以用于将源数据转换为新类型的序列。 此转换也称为投影。 在下面的示例中，select 子句对只包含原始元素中的字段子集的匿名类型序列进行投影。 请注意，新对象使用对象初始值设定项进行初始化。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Here var is required because the query</span></span><br><span class="line"><span class="comment">// produces an anonymous type.</span></span><br><span class="line"><span class="keyword">var</span> queryNameAndPop =</span><br><span class="line">    <span class="keyword">from</span> country <span class="keyword">in</span> countries</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">new</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = country.Name,</span><br><span class="line">        Pop = country.Population</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>选择每个源元素的子集<br>有两种主要方法来选择源序列中每个元素的子集：</li>
</ul>
<p>若要仅选择源元素的一个成员，请使用点操作。 在以下示例中，假设 Customer 对象包含多个公共属性，包括名为 City 的字符串。 在执行时，此查询将生成字符串的输出序列。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> query = <span class="keyword">from</span> cust <span class="keyword">in</span> Customers  </span><br><span class="line">            <span class="keyword">select</span> cust.City;  </span><br></pre></td></tr></table></figure>

<p>若要创建包含多个源元素属性的元素，可以使用带有命名对象或匿名类型的对象初始值设定项。 以下示例演示如何使用匿名类型封装每个 Customer 元素的两个属性：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> query = <span class="keyword">from</span> cust <span class="keyword">in</span> Customer  </span><br><span class="line">            <span class="keyword">select</span> <span class="keyword">new</span> &#123;Name = cust.Name, City = cust.City&#125;;  </span><br></pre></td></tr></table></figure>

<ul>
<li>将内存中对象转换为 XML<br>LINQ 查询可以轻松地在内存中数据结构、SQL 数据库、ADO.NET 数据集和 XML 流或文档之间转换数据。 以下示例将内存中数据结构中的对象转换为 XML 元素。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">XMLTransform</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Create the data source by using a collection initializer.</span></span><br><span class="line">        <span class="comment">// The Student class was defined previously in this topic.</span></span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> List&lt;Student&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> Student &#123;First=<span class="string">&quot;Svetlana&quot;</span>, Last=<span class="string">&quot;Omelchenko&quot;</span>, ID=<span class="number">111</span>, Scores = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;&#123;<span class="number">97</span>, <span class="number">92</span>, <span class="number">81</span>, <span class="number">60</span>&#125;&#125;,</span><br><span class="line">            <span class="keyword">new</span> Student &#123;First=<span class="string">&quot;Claire&quot;</span>, Last=<span class="string">&quot;O’Donnell&quot;</span>, ID=<span class="number">112</span>, Scores = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;&#123;<span class="number">75</span>, <span class="number">84</span>, <span class="number">91</span>, <span class="number">39</span>&#125;&#125;,</span><br><span class="line">            <span class="keyword">new</span> Student &#123;First=<span class="string">&quot;Sven&quot;</span>, Last=<span class="string">&quot;Mortensen&quot;</span>, ID=<span class="number">113</span>, Scores = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;&#123;<span class="number">88</span>, <span class="number">94</span>, <span class="number">65</span>, <span class="number">91</span>&#125;&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the query.</span></span><br><span class="line">        <span class="keyword">var</span> studentsToXML = <span class="keyword">new</span> XElement(<span class="string">&quot;Root&quot;</span>,</span><br><span class="line">            <span class="keyword">from</span> student <span class="keyword">in</span> students</span><br><span class="line">            <span class="keyword">let</span> scores = <span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>, student.Scores)</span><br><span class="line">            <span class="function"><span class="keyword">select</span> <span class="keyword">new</span> <span class="title">XElement</span>(<span class="params"><span class="string">&quot;student&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">new</span> XElement(<span class="string">&quot;First&quot;</span>, student.First</span>),</span></span><br><span class="line"><span class="function">                       <span class="keyword">new</span> <span class="title">XElement</span>(<span class="params"><span class="string">&quot;Last&quot;</span>, student.Last</span>),</span></span><br><span class="line"><span class="function">                       <span class="keyword">new</span> <span class="title">XElement</span>(<span class="params"><span class="string">&quot;Scores&quot;</span>, scores</span>)</span></span><br><span class="line"><span class="function">                    ) <span class="comment">// end &quot;student&quot;</span></span></span><br><span class="line"><span class="function">                )</span>; <span class="comment">// end &quot;Root&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Execute the query.</span></span><br><span class="line">        Console.WriteLine(studentsToXML);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Keep the console open in debug mode.</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Press any key to exit.&quot;</span>);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
此代码生成以下 XML 输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;Root&gt;  </span><br><span class="line">  &lt;student&gt;  </span><br><span class="line">    &lt;First&gt;Svetlana&lt;/First&gt;  </span><br><span class="line">    &lt;Last&gt;Omelchenko&lt;/Last&gt;  </span><br><span class="line">    &lt;Scores&gt;97,92,81,60&lt;/Scores&gt;  </span><br><span class="line">  &lt;/student&gt;  </span><br><span class="line">  &lt;student&gt;  </span><br><span class="line">    &lt;First&gt;Claire&lt;/First&gt;  </span><br><span class="line">    &lt;Last&gt;O&#x27;Donnell&lt;/Last&gt;  </span><br><span class="line">    &lt;Scores&gt;75,84,91,39&lt;/Scores&gt;  </span><br><span class="line">  &lt;/student&gt;  </span><br><span class="line">  &lt;student&gt;  </span><br><span class="line">    &lt;First&gt;Sven&lt;/First&gt;  </span><br><span class="line">    &lt;Last&gt;Mortensen&lt;/Last&gt;  </span><br><span class="line">    &lt;Scores&gt;88,94,65,91&lt;/Scores&gt;  </span><br><span class="line">  &lt;/student&gt;  </span><br><span class="line">&lt;/Root&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用“into”延续"><a href="#使用“into”延续" class="headerlink" title="使用“into”延续"></a>使用“into”延续</h3><p>可以在 select 或 group 子句中使用 into 关键字创建存储查询的临时标识符。 如果在分组或选择操作之后必须对查询执行其他查询操作，则可以这样做。 在下面的示例中，countries 按 1000 万范围，根据人口进行分组。 创建这些组之后，附加子句会筛选出一些组，然后按升序对组进行排序。 若要执行这些附加操作，需要由 countryGroup 表示的延续。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// percentileQuery is an IEnumerable&lt;IGrouping&lt;int, Country&gt;&gt;</span></span><br><span class="line"><span class="keyword">var</span> percentileQuery =</span><br><span class="line">    <span class="keyword">from</span> country <span class="keyword">in</span> countries</span><br><span class="line">    <span class="keyword">let</span> percentile = (<span class="built_in">int</span>)country.Population / <span class="number">10</span>_000_000</span><br><span class="line">    <span class="keyword">group</span> country <span class="keyword">by</span> percentile <span class="keyword">into</span> countryGroup</span><br><span class="line">    <span class="keyword">where</span> countryGroup.Key &gt;= <span class="number">20</span></span><br><span class="line">    <span class="keyword">orderby</span> countryGroup.Key</span><br><span class="line">    <span class="keyword">select</span> countryGroup;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grouping is an IGrouping&lt;int, Country&gt;</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> grouping <span class="keyword">in</span> percentileQuery)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(grouping.Key);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> country <span class="keyword">in</span> grouping)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(country.Name + <span class="string">&quot;:&quot;</span> + country.Population);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="筛选、排序和联接"><a href="#筛选、排序和联接" class="headerlink" title="筛选、排序和联接"></a>筛选、排序和联接</h2><p>在开头 from 子句与结尾 select 或 group 子句之间，所有其他子句（where、join、orderby、from、let）都是可选的。 任何可选子句都可以在查询正文中使用零次或多次。</p>
<h3 id="where-子句"><a href="#where-子句" class="headerlink" title="where 子句"></a>where 子句</h3><p>使用 where 子句可基于一个或多个谓词表达式，从源数据中筛选出元素。 以下示例中的 where 子句具有一个谓词及两个条件。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;City&gt; queryCityPop =</span><br><span class="line">    <span class="keyword">from</span> city <span class="keyword">in</span> cities</span><br><span class="line">    <span class="keyword">where</span> city.Population &lt; <span class="number">200000</span> &amp;&amp; city.Population &gt; <span class="number">100000</span></span><br><span class="line">    <span class="keyword">select</span> city;</span><br></pre></td></tr></table></figure>
<h3 id="orderby-子句"><a href="#orderby-子句" class="headerlink" title="orderby 子句"></a>orderby 子句</h3><p>使用 orderby 子句可按升序或降序对结果进行排序。 还可以指定次要排序顺序。 下面的示例使用 Area 属性对 country 对象执行主要排序。 然后使用 Population 属性执行次要排序。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;Country&gt; querySortedCountries =</span><br><span class="line">    <span class="keyword">from</span> country <span class="keyword">in</span> countries</span><br><span class="line">    <span class="keyword">orderby</span> country.Area, country.Population <span class="keyword">descending</span></span><br><span class="line">    <span class="keyword">select</span> country;</span><br></pre></td></tr></table></figure>

<h3 id="join-子句"><a href="#join-子句" class="headerlink" title="join 子句"></a>join 子句</h3><p>使用 join 子句可基于每个元素中指定的键之间的相等比较，将一个数据源中的元素与另一个数据源中的元素进行关联和&#x2F;或合并。</p>
<p>联接操作是对元素属于不同类型的对象序列执行。 联接了两个序列之后，必须使用 select 或 group 语句指定要存储在输出序列中的元素。 </p>
<p>还可以使用匿名类型将每组关联元素中的属性合并到输出序列的新类型中。 下面的示例关联其 Category 属性与 categories 字符串数组中一个类别匹配的 prod 对象。 筛选出 Category 与 categories 中的任何字符串均不匹配的产品。select 语句投影属性取自 cat 和 prod 的新类型。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> categoryQuery =</span><br><span class="line">    <span class="keyword">from</span> cat <span class="keyword">in</span> categories</span><br><span class="line">    <span class="keyword">join</span> prod <span class="keyword">in</span> products <span class="keyword">on</span> cat <span class="keyword">equals</span> prod.Category</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">new</span></span><br><span class="line">    &#123;</span><br><span class="line">        Category = cat,</span><br><span class="line">        Name = prod.Name</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="let-子句"><a href="#let-子句" class="headerlink" title="let 子句"></a>let 子句</h3><p>使用 let 子句可将表达式（如方法调用）的结果存储在新范围变量中。 在下面的示例中，范围变量 firstName 存储 Split 返回的字符串数组的第一个元素。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>[] names = &#123; <span class="string">&quot;Svetlana Omelchenko&quot;</span>, <span class="string">&quot;Claire O&#x27;Donnell&quot;</span>, <span class="string">&quot;Sven Mortensen&quot;</span>, <span class="string">&quot;Cesar Garcia&quot;</span> &#125;;</span><br><span class="line">IEnumerable&lt;<span class="built_in">string</span>&gt; queryFirstNames =</span><br><span class="line">    <span class="keyword">from</span> name <span class="keyword">in</span> names</span><br><span class="line">    <span class="keyword">let</span> firstName = name.Split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">select</span> firstName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> s <span class="keyword">in</span> queryFirstNames)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output: Svetlana Claire Sven Cesar</span></span><br></pre></td></tr></table></figure>

<h2 id="查询表达式中的子查询"><a href="#查询表达式中的子查询" class="headerlink" title="查询表达式中的子查询"></a>查询表达式中的子查询</h2><p>查询子句本身可能包含查询表达式，这有时称为子查询。 每个子查询都以自己的 from 子句开头，该子句不一定指向第一个 from 子句中的相同数据源。 例如，下面的查询演示在 select 语句用于检索分组操作结果的查询表达式。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> queryGroupMax =</span><br><span class="line">    <span class="keyword">from</span> student <span class="keyword">in</span> students</span><br><span class="line">    <span class="keyword">group</span> student <span class="keyword">by</span> student.Year <span class="keyword">into</span> studentGroup</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">new</span></span><br><span class="line">    &#123;</span><br><span class="line">        Level = studentGroup.Key,</span><br><span class="line">        HighestScore = (</span><br><span class="line">            <span class="keyword">from</span> student2 <span class="keyword">in</span> studentGroup</span><br><span class="line">            <span class="keyword">select</span> student2.ExamScores.Average()</span><br><span class="line">        ).Max()</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2022/12/14/ABP/abp-%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%8EABP%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/14/ABP/abp-%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%8EABP%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">abp-现代软件开发与ABP框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-14 17:36:00" itemprop="dateCreated datePublished" datetime="2022-12-14T17:36:00+08:00">2022-12-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-11 17:56:10" itemprop="dateModified" datetime="2023-03-11T17:56:10+08:00">2023-03-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>构建软件系统一直很复杂。尤其是在现代，即使是创建一个基本的业务解决方案，也面临着许多挑战。您通常会发现自己实现了标准的非业务需求，并深入研究了基础架构问题，而不是实现了业务代码（这是您试图构建的系统中真正有价值的部分）。</p>
<p>ABP框架通过提供强大的软件架构、自动化重复的细节以及提供必要的基础设施来帮助构建现代web解决方案，帮助您专注于为利益相关者增加价值的代码。它提供了端到端、一致的开发体验，并提高了您的生产力。ABP帮助您和您的团队<br>加快所有预先应用的现代软件开发最佳实践。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2022/12/14/ABP/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/14/ABP/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">数据传输对象</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-14 13:52:12" itemprop="dateCreated datePublished" datetime="2022-12-14T13:52:12+08:00">2022-12-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-11 17:56:10" itemprop="dateModified" datetime="2023-03-11T17:56:10+08:00">2023-03-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>数据传输对象(DTO)用于在应用层和表示层或其他类型的客户端之间传输数据.</p>
<p>通常用DTO作为参数在表示层(可选)调用应用服务. 它使用领域对象执行某些特定的业务逻辑,并(可选)将DTO返回到表示层.因此表示层与领域层完全隔离.</p>
<h2 id="数据隐藏"><a href="#数据隐藏" class="headerlink" title="数据隐藏"></a>数据隐藏</h2><p>假设你有一个具有属性Id,名称,电子邮件地址和密码的 User 实体. 如果 UserAppService 的 GetAllUsers() 方法返回 List<User>,任何人都可以访问你所有用户的密码,即使你没有在屏幕上显示它. 这不仅关乎安全,还关乎数据隐藏. 应用程序服务应该只返回表示层(或客户端)所需要的内容,不多也不少.</User></p>
<h2 id="序列化和延迟加载问题"><a href="#序列化和延迟加载问题" class="headerlink" title="序列化和延迟加载问题"></a>序列化和延迟加载问题</h2><p>当你将数据(一个对象)返回到表示层时,它很可能是序列化的. 例如在返回JSON的REST API中,你的对象将被序列化为JSON并发送给客户端. 在这方面将实体返回到表示层可能会有问题,尤其是在使用关系数据库和像Entity Framework Core这样的ORM提供者时.</p>
<p>在真实的应用程序中你的实体可以相互引用. User 实体可以引用它的角色. 如果你想序列化用户,它的角色也必须是序列化的. Role 类可以有 List <Permission>,而 Permission 类可以有一个对 PermissionGroup 类的引用,依此类推…想象一下所有这些对象都被立即序列化了. 你可能会意外地序列化整个数据库! 同样,如果你的对象具有循环引用,则它们可能根本不会序列化成功.</Permission></p>
<p>几乎所有的O&#x2F;RM框架都支持延迟加载. 此功能可在需要时从数据库加载实体. 假设 User 类具有对 Role 类的引用. 当你从数据库中获取用户时,Role 属性(或集合)不会被立即填充. 首次读取 Role 属性时,它是从数据库加载的. 因此如果将这样的实体返回到表示层,它将通过执行额外的查询从数据库中检索额外的实体. 如果序列化工具读取实体,它会递归读取所有属性,并且可以再次检索整个数据库(如果实体之间存在关系).</p>
<p>如果在表示层中使用实体,可能会出现更多问题.最好不要在表示层中引用领域&#x2F;业务层程序集.</p>
<p>ABP并不强迫你使用DTO,但是强烈建议将DTO作为最佳实践.</p>
<h2 id="标准接口和基类"><a href="#标准接口和基类" class="headerlink" title="标准接口和基类"></a>标准接口和基类</h2><p>DTO是一个没有依赖性的简单类,你可以用任何方式进行设计. 但是ABP引入了一些接口来确定命名标准属性和基类的约定,以免在声明公共属性时重复工作.</p>
<h3 id="实体相关DTO"><a href="#实体相关DTO" class="headerlink" title="实体相关DTO"></a>实体相关DTO</h3><p>通常你需要创建与你的实体相对应的DTO,从而生成与实体类似的类. ABP框架在创建DTO时提供了一些基类来简化.</p>
<h3 id="EntityDto"><a href="#EntityDto" class="headerlink" title="EntityDto"></a>EntityDto</h3><p>IEntityDto<TKey> 是一个只定义 Id 属性的简单接口. 你可以实现它或从 EntityDto<TKey> 继承.</TKey></TKey></p>
<h3 id="审计DTO"><a href="#审计DTO" class="headerlink" title="审计DTO"></a>审计DTO</h3><p>如果你的实体继承自被审计的实体类(或实现审计接口)可以使用以下基类来创建DTO:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CreationAuditedEntityDto</span><br><span class="line">CreationAuditedEntityWithUserDto</span><br><span class="line">AuditedEntityDto</span><br><span class="line">AuditedEntityWithUserDto</span><br><span class="line">FullAuditedEntityDto</span><br><span class="line">FullAuditedEntityWithUserDto</span><br></pre></td></tr></table></figure>
<h3 id="可扩展的DTO"><a href="#可扩展的DTO" class="headerlink" title="可扩展的DTO"></a>可扩展的DTO</h3><p>如果你想为你的DTO使用对象扩展系统,你可以使用或继承以下DTO类:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ExtensibleObject 实现 IHasExtraProperties (其它类继承这个类).</span><br><span class="line">ExtensibleEntityDto</span><br><span class="line">ExtensibleCreationAuditedEntityDto</span><br><span class="line">ExtensibleCreationAuditedEntityWithUserDto</span><br><span class="line">ExtensibleAuditedEntityDto</span><br><span class="line">ExtensibleAuditedEntityWithUserDto</span><br><span class="line">ExtensibleFullAuditedEntityDto</span><br><span class="line">ExtensibleFullAuditedEntityWithUserDto</span><br></pre></td></tr></table></figure>
<h3 id="列表结果"><a href="#列表结果" class="headerlink" title="列表结果"></a>列表结果</h3><p>通常将DTO列表返回给客户端. IListResult<T> 接口和 ListResultDto<T> 类用于使其成为标准.</T></T></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">AbpDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProductAppService</span> : <span class="title">ApplicationService</span>, <span class="title">IProductAppService</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IRepository&lt;Product, Guid&gt; _productRepository;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ProductAppService</span>(<span class="params">IRepository&lt;Product, Guid&gt; productRepository</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _productRepository = productRepository;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ListResultDto&lt;ProductDto&gt;&gt; GetListAsync()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Get entities from the repository</span></span><br><span class="line">            List&lt;Product&gt; products = <span class="keyword">await</span> _productRepository.GetListAsync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Map entities to DTOs</span></span><br><span class="line">            List&lt;ProductDto&gt; productDtos =</span><br><span class="line">                ObjectMapper.Map&lt;List&lt;Product&gt;, List&lt;ProductDto&gt;&gt;(products);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Return the result</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ListResultDto&lt;ProductDto&gt;(productDtos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以简单地返回 productDtos 对象(并更改方法的返回类型), 这也没有错. 返回一个 ListResultDto 会使List<ProductDto> 做为 Item 属性包装到另一个对象中. 这具有一个优点:以后可以在不破坏远程客户端的情况下(当它们作为JSON结果获得值时)在返回值中添加更多属性. 在开发可重用的应用程序模块时特别建议使用这种方式.</ProductDto></p>
<h3 id="分页-amp-排序列表结果"><a href="#分页-amp-排序列表结果" class="headerlink" title="分页 &amp; 排序列表结果"></a>分页 &amp; 排序列表结果</h3><p>从服务器请求分页列表并将分页列表返回给客户端是更常见的情况. ABP定义了一些接口和类来对其进行标准化:</p>
<h4 id="输入-请求-类型"><a href="#输入-请求-类型" class="headerlink" title="输入 (请求) 类型"></a>输入 (请求) 类型</h4><p>建议你继承以下基类DTO类之一,而不是手动实现接口:</p>
<ul>
<li>LimitedResultRequestDto 实现了 ILimitedResultRequest.</li>
<li>PagedResultRequestDto 实现了 IPagedResultRequest (和继承自 LimitedResultRequestDto).</li>
<li>PagedAndSortedResultRequestDto 实现了 IPagedAndSortedResultRequest (和继承自 PagedResultRequestDto).</li>
</ul>
<h4 id="最大返回数量"><a href="#最大返回数量" class="headerlink" title="最大返回数量"></a>最大返回数量</h4><p>LimitedResultRequestDto(和其它固有的)通过以下规则限制和验证 MaxResultCount;</p>
<p>最大返回数量<br>LimitedResultRequestDto(和其它固有的)通过以下规则限制和验证 MaxResultCount;</p>
<ul>
<li>如果客户端未设置 MaxResultCount,则假定为10(默认页面大小). 可以通过设置 LimitedResultRequestDto.DefaultMaxResultCount 静态属性来更改此值.</li>
<li>如果客户端发送的 MaxResultCount 大于1,000,则会产生验证错误. 保护服务器免受滥用服务很重要. 如果需要可以通过设置 LimitedResultRequestDto.MaxMaxResultCount 静态属性来更改此值.</li>
</ul>
<p>建议在应用程序启动时设置静态属性,因为它们是静态的(全局).</p>
<h4 id="输出-响应-类型"><a href="#输出-响应-类型" class="headerlink" title="输出 (响应) 类型"></a>输出 (响应) 类型</h4><p>以下接口和类用于标准化发送给客户端的输出.</p>
<p>建议你继承以下基类DTO类之一,而不是手动实现接口:</p>
<ul>
<li>PagedResultDto<T> 继承自 ListResultDto<T> 和实现了 IPagedResult<T>.</T></T></T></li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>你可以自由设计DTO类,然而这里有一些你可能想要遵循的最佳实践和建议.</p>
<h3 id="共同原则"><a href="#共同原则" class="headerlink" title="共同原则"></a>共同原则</h3><ul>
<li><p>DTO应该是可序列化的,因为它们通常是序列化和反序列化的(JSON或其他格式). 如果你有另一个带参数的构造函数,建议使用空(无参数)的公共构造函数.</p>
</li>
<li><p>除某些验证代码外,DTO不应包含任何业务逻辑.</p>
</li>
<li><p>DTO不要继承实体,也不要引用实体. 应用程序启动模板已经通过分隔项目来阻止它.</p>
</li>
<li><p>如果你使用自动对象到对象映射库,如AutoMapper,请启用映射配置验证以防止潜在的错误.</p>
</li>
<li><h3 id="输入DTO原则"><a href="#输入DTO原则" class="headerlink" title="输入DTO原则"></a>输入DTO原则</h3></li>
<li><p>只定义用例所需的属性. 不要包含不用于用例的属性,这样做会使开发人员感到困惑.</p>
</li>
<li><p>不要在不同的应用程序服务方法之间重用输入DTO. 因为不同的用例将需要和使用DTO的不同属性.</p>
</li>
</ul>
<h3 id="输出DTO原则"><a href="#输出DTO原则" class="headerlink" title="输出DTO原则"></a>输出DTO原则</h3><p>如果在所有情况下填充所有属性,就可以重用输出DTO.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2022/12/14/ABP/%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/14/ABP/%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1/" class="post-title-link" itemprop="url">应用服务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-14 13:33:08" itemprop="dateCreated datePublished" datetime="2022-12-14T13:33:08+08:00">2022-12-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-11 17:56:10" itemprop="dateModified" datetime="2023-03-11T17:56:10+08:00">2023-03-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>应用服务实现应用程序的用例, 将领域层逻辑公开给表示层.</p>
<p>假设你有一个Book实体(聚合根), 如下所示:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Book</span> : <span class="title">AggregateRoot</span>&lt;<span class="title">Guid</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> MaxNameLength = <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> BookType Type &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">float</span>? Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Book</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span>(<span class="params">Guid id, [NotNull] <span class="built_in">string</span> name, BookType type, <span class="built_in">float</span>? price = <span class="number">0</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Id = id;</span><br><span class="line">        Name = CheckName(name);</span><br><span class="line">        Type = type;</span><br><span class="line">        Price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ChangeName</span>(<span class="params">[NotNull] <span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = CheckName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">CheckName</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrWhiteSpace(name))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">$&quot;name can not be empty or white space!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (name.Length &gt; MaxNameLength)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">$&quot;name can not be longer than <span class="subst">&#123;MaxNameLength&#125;</span> chars!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IBookAppService接口"><a href="#IBookAppService接口" class="headerlink" title="IBookAppService接口"></a>IBookAppService接口</h2><p>在ABP中应用程序服务应该实现IApplicationService接口. 推荐每个应用程序服务创建一个接口:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IBookAppService</span> : <span class="title">IApplicationService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Task <span class="title">CreateAsync</span>(<span class="params">CreateBookDto input</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将实现Create方法作为示例. CreateBookDto定义如下:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CreateBookDto</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Required</span>]</span><br><span class="line">    [<span class="meta">StringLength(Book.MaxNameLength)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BookType Type &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span>? Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BookAppService-实现"><a href="#BookAppService-实现" class="headerlink" title="BookAppService(实现)"></a>BookAppService(实现)</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BookAppService</span> : <span class="title">ApplicationService</span>, <span class="title">IBookAppService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IRepository&lt;Book, Guid&gt; _bookRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookAppService</span>(<span class="params">IRepository&lt;Book, Guid&gt; bookRepository</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _bookRepository = bookRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">CreateAsync</span>(<span class="params">CreateBookDto input</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> book = <span class="keyword">new</span> Book(</span><br><span class="line">            GuidGenerator.Create(),</span><br><span class="line">            input.Name,</span><br><span class="line">            input.Type,</span><br><span class="line">            input.Price</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> _bookRepository.InsertAsync(book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>BookAppService继承了基类ApplicationService· 这不是必需的, 但是ApplicationService提供了应用服务常见的需求(比如本示例服务中使用的GuidGenerator). 如果不继承它, 我们需要在服务中手动注入IGuidGenerator</li>
<li>BookAppService按照预期实现了IBookAppService</li>
<li>BookAppService 注入了 IRepository&lt;Book, Guid&gt;(请参见仓储)在CreateAsync方法内部使用仓储将新实体插入数据库.</li>
<li>CreateAsync使用Book实体的构造函数从给定的Input值创建新的Book对象</li>
</ul>
<h2 id="数据传输对象"><a href="#数据传输对象" class="headerlink" title="数据传输对象"></a>数据传输对象</h2><p>应用服务使用并返回DTO而不是实体. ABP不会强制执行此规则. 但是将实体暴露给表示层(或远程客户端)存在重大问题, 所以不建议返回实体.</p>
<h2 id="CRUD应用服务"><a href="#CRUD应用服务" class="headerlink" title="CRUD应用服务"></a>CRUD应用服务</h2><p>如果需要创建具有Create,Update,Delete和Get方法的简单CRUD应用服务,则可以使用ABP的基类轻松构建服务. 你可以继承CrudAppService.</p>
<p>创建继承ICrudAppService接口的IBookAppService接口.</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IBookAppService</span> : </span><br><span class="line">    <span class="title">ICrudAppService</span>&lt; //<span class="title">Defines</span> <span class="title">CRUD</span> <span class="title">methods</span></span><br><span class="line">        <span class="title">BookDto</span>, //<span class="title">Used</span> <span class="title">to</span> <span class="title">show</span> <span class="title">books</span></span><br><span class="line">        <span class="title">Guid</span>, //<span class="title">Primary</span> <span class="title">key</span> <span class="title">of</span> <span class="title">the</span> <span class="title">book</span> <span class="title">entity</span></span><br><span class="line">        <span class="title">PagedAndSortedResultRequestDto</span>, //<span class="title">Used</span> <span class="title">for</span> <span class="title">paging</span>/<span class="title">sorting</span> <span class="title">on</span> <span class="title">getting</span> <span class="title">a</span> <span class="title">list</span> <span class="title">of</span> <span class="title">books</span></span><br><span class="line">        <span class="title">CreateUpdateBookDto</span>, //<span class="title">Used</span> <span class="title">to</span> <span class="title">create</span> <span class="title">a</span> <span class="title">new</span> <span class="title">book</span></span><br><span class="line">        <span class="title">CreateUpdateBookDto</span>&gt; <span class="comment">//Used to update a book</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ICrudAppService 有泛型参数来获取实体的主键类型和CRUD操作的DTO类型(它不获取实体类型,因为实体类型未向客户端公开使用此接口).</p>
<p>最后BookAppService实现非常简单:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BookAppService</span> : </span><br><span class="line">    <span class="title">CrudAppService</span>&lt;<span class="title">Book</span>, <span class="title">BookDto</span>, <span class="title">Guid</span>, <span class="title">PagedAndSortedResultRequestDto</span>,</span><br><span class="line">                        <span class="title">CreateUpdateBookDto</span>, <span class="title">CreateUpdateBookDto</span>&gt;,</span><br><span class="line">    <span class="title">IBookAppService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookAppService</span>(<span class="params">IRepository&lt;Book, Guid&gt; repository</span>) </span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">repository</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CrudAppService实现了ICrudAppService接口中声明的所有方法. 然后,你可以添加自己的自定义方法或重写和自定义实现.</p>
<h2 id="AbstractKeyCrudAppService"><a href="#AbstractKeyCrudAppService" class="headerlink" title="AbstractKeyCrudAppService"></a>AbstractKeyCrudAppService</h2><p>CrudAppService 要求你的实体拥有一个Id属性做为主键. 如果你使用的是复合主键,那么你无法使用它.</p>
<p>AbstractKeyCrudAppService 实现了相同的 ICrudAppService 接口,但它没有要求实体有主键.</p>
<p>假设你有实体 District,它的CityId 和 Name 做为复合主键,使用 AbstractKeyCrudAppService 时需要你自己实现 DeleteByIdAsync 和 GetEntityByIdAsync 方法:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DistrictAppService</span></span><br><span class="line">    : <span class="title">AbstractKeyCrudAppService</span>&lt;<span class="title">District</span>, <span class="title">DistrictDto</span>, <span class="title">DistrictKey</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DistrictAppService</span>(<span class="params">IRepository&lt;District&gt; repository</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">repository</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">async</span> <span class="keyword">override</span> Task <span class="title">DeleteByIdAsync</span>(<span class="params">DistrictKey id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> Repository.DeleteAsync(d =&gt; d.CityId == id.CityId &amp;&amp; d.Name == id.Name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">async</span> <span class="keyword">override</span> Task&lt;District&gt; <span class="title">GetEntityByIdAsync</span>(<span class="params">DistrictKey id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> AsyncQueryableExecuter.FirstOrDefaultAsync(</span><br><span class="line">            Repository.Where(d =&gt; d.CityId == id.CityId &amp;&amp; d.Name == id.Name)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个实现需要你创建一个类做为复合键:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DistrictKey</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Guid CityId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>应用服务的生命周期是transient的,它们会自动注册到依赖注入系统.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>将实体对象作为方法参数，而不是其id值。如果接受其id值，则需要从领域服务内的数据库中检索实体。这种方法使应用程序代码在同一请求（用例）的不同位置多次加载同一实体，这是低效的，并导致错误。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2022/12/14/ABP/%E8%A7%84%E7%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/14/ABP/%E8%A7%84%E7%BA%A6/" class="post-title-link" itemprop="url">规约</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-14 11:11:18" itemprop="dateCreated datePublished" datetime="2022-12-14T11:11:18+08:00">2022-12-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-11 17:56:10" itemprop="dateModified" datetime="2023-03-11T17:56:10+08:00">2023-03-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>规约模式用于为实体和其他业务对象定义 命名、可复用、可组合和可测试的过滤器 .<br>规约是领域层的一部分.</p>
<h2 id="定义规约"><a href="#定义规约" class="headerlink" title="定义规约"></a>定义规约</h2><p>你可以创建一个由 Specification<Customer> 派生的新规约类.</Customer></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Age18PlusCustomerSpecification</span> : <span class="title">Specification</span>&lt;<span class="title">Customer</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> Expression&lt;Func&lt;Customer, <span class="built_in">bool</span>&gt;&gt; ToExpression()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> c =&gt; c.Age &gt;= <span class="number">18</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以直接实现ISpecification<T>接口,但是基类Specification<T>做了大量简化.</T></T></p>
<h2 id="使用规约"><a href="#使用规约" class="headerlink" title="使用规约"></a>使用规约</h2><p>这里有两种常见的规约用例.</p>
<h3 id="IsSatisfiedBy"><a href="#IsSatisfiedBy" class="headerlink" title="IsSatisfiedBy"></a>IsSatisfiedBy</h3><p>IsSatisfiedBy 方法可以用于检查单个对象是否满足规约.</p>
<p>例如:如果顾客不满足年龄规定,则抛出异常</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomerService</span> : <span class="title">ITransientDependency</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">BuyAlcohol</span>(<span class="params">Customer customer</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">new</span> Age18PlusCustomerSpecification().IsSatisfiedBy(customer))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(</span><br><span class="line">                    <span class="string">&quot;这位顾客不满足年龄规定!&quot;</span></span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//TODO...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ToExpression-amp-Repositories"><a href="#ToExpression-amp-Repositories" class="headerlink" title="ToExpression &amp; Repositories"></a>ToExpression &amp; Repositories</h3><p>ToExpression() 方法可用于将规约转化为表达式.通过这种方式,你可以使用规约在数据库查询时过滤实体.</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomerManager</span> : <span class="title">DomainService</span>, <span class="title">ITransientDependency</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IRepository&lt;Customer, Guid&gt; _customerRepository;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomerManager</span>(<span class="params">IRepository&lt;Customer, Guid&gt; customerRepository</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _customerRepository = customerRepository;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">async</span> Task&lt;List&lt;Customer&gt;&gt; GetCustomersCanBuyAlcohol()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> queryable = <span class="keyword">await</span> _customerRepository.GetQueryableAsync();</span><br><span class="line">            <span class="keyword">var</span> query = queryable.Where(</span><br><span class="line">                <span class="keyword">new</span> Age18PlusCustomerSpecification().ToExpression()</span><br><span class="line">            );</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> AsyncExecuter.ToListAsync(query);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>规约被正确地转换为SQL&#x2F;数据库查询语句,并且在DBMS端高效执行.虽然它与规约无关,但如果你想了解有关 AsyncExecuter 的更多信息,请参阅仓储文档.</p>
<p>实际上,没有必要使用 ToExpression() 方法,因为规约会自动转换为表达式.这也会起作用:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> queryable = <span class="keyword">await</span> _customerRepository.GetQueryableAsync();</span><br><span class="line"><span class="keyword">var</span> query = queryable.Where(</span><br><span class="line">    <span class="keyword">new</span> Age18PlusCustomerSpecification()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="编写规约"><a href="#编写规约" class="headerlink" title="编写规约"></a>编写规约</h2><p>规约有一个强大的功能是,它们可以与And、Or、Not以及AndNot扩展方法组合使用.</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PremiumCustomerSpecification</span> : <span class="title">Specification</span>&lt;<span class="title">Customer</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> Expression&lt;Func&lt;Customer, <span class="built_in">bool</span>&gt;&gt; ToExpression()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (customer) =&gt; (customer.Balance &gt;= <span class="number">100000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">你可以将 PremiumCustomerSpecification 和 Age18PlusCustomerSpecification 结合起来,查询优质成人顾客的数量,如下所示:</span><br><span class="line"></span><br><span class="line">~~~C<span class="meta">#</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomerManager</span> : <span class="title">DomainService</span>, <span class="title">ITransientDependency</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IRepository&lt;Customer, Guid&gt; _customerRepository;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomerManager</span>(<span class="params">IRepository&lt;Customer, Guid&gt; customerRepository</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _customerRepository = customerRepository;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">GetAdultPremiumCustomerCountAsync</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> _customerRepository.CountAsync(</span><br><span class="line">                <span class="keyword">new</span> Age18PlusCustomerSpecification()</span><br><span class="line">                .And(<span class="keyword">new</span> PremiumCustomerSpecification()).ToExpression()</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你想让这个组合成为一个可复用的规约,你可以创建这样一个组合的规约类,它派生自AndSpecification:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Volo.Abp.Specifications;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AdultPremiumCustomerSpecification</span> : <span class="title">AndSpecification</span>&lt;<span class="title">Customer</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AdultPremiumCustomerSpecification</span>() </span></span><br><span class="line"><span class="function">            : <span class="title">base</span>(<span class="params"><span class="keyword">new</span> Age18PlusCustomerSpecification(</span>),</span></span><br><span class="line"><span class="function">                   <span class="keyword">new</span> <span class="title">PremiumCustomerSpecification</span>())</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="何时使用规约"><a href="#何时使用规约" class="headerlink" title="何时使用规约"></a>何时使用规约</h2><p>使用规约的一些好处:</p>
<ul>
<li>可复用:假设你在代码库的许多地方都需要用到优质顾客过滤器.如果使用表达式而不创建规约,那么如果以后更改“优质顾客”的定义会发生什么?假设你想将最低余额从100000美元更改为250000美元,并添加另一个条件,成为顾客超过3年.如果使用了规约,只需修改一个类.如果在任何其他地方重复（复制&#x2F;粘贴）相同的表达式,则需要更改所有的表达式.</li>
<li>可组合:可以组合多个规约来创建新规约.这是另一种可复用性.</li>
<li>可命名:PremiumCustomerSpecification 更好地解释了为什么使用规约,而不是复杂的表达式.因此,如果在你的业务中使用了一个有意义的表达式,请考虑使用规约.</li>
<li>可测试:规约是一个单独（且易于）测试的对象.</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2022/12/14/ABP/%E9%A2%86%E5%9F%9F%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/14/ABP/%E9%A2%86%E5%9F%9F%E6%9C%8D%E5%8A%A1/" class="post-title-link" itemprop="url">领域服务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-14 09:33:25" itemprop="dateCreated datePublished" datetime="2022-12-14T09:33:25+08:00">2022-12-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-11 17:56:10" itemprop="dateModified" datetime="2023-03-11T17:56:10+08:00">2023-03-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在<code>领域驱动设计(DDD)</code> 解决方案中,核心业务逻辑通常在聚合 (实体) 和领域服务中实现. 在以下情况下特别需要创建领域服务</p>
<ul>
<li>你实现了依赖于某些服务（如存储库或其他外部服务）的核心域逻辑.</li>
<li>你需要实现的逻辑与多个聚合&#x2F;实体相关,因此它不适合任何聚合.<h2 id="ABP-领域服务基础设施"><a href="#ABP-领域服务基础设施" class="headerlink" title="ABP 领域服务基础设施"></a>ABP 领域服务基础设施</h2>领域服务是简单的无状态类. 虽然你不必从任何服务或接口派生,但 ABP 框架提供了一些有用的基类和约定.</li>
</ul>
<h3 id="DomainService-和-IDomainService"><a href="#DomainService-和-IDomainService" class="headerlink" title="DomainService 和 IDomainService"></a>DomainService 和 IDomainService</h3><p>从 DomainService 基类派生领域服务或直接实现 IDomainService 接口.</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Volo.Abp.Domain.Services;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject.Issues</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IssueManager</span> : <span class="title">DomainService</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你这样做时:</p>
<ul>
<li>ABP 框架自动将类注册为瞬态生命周期到依赖注入系统.</li>
<li>你可以直接使用一些常用服务作为基础属性,而无需手动注入 (例如 ILogger and IGuidGenerator).</li>
</ul>
<p>建议使用 Manager 或 Service 后缀命名领域服务. 我们通常使用如上面示例中的 Manager 后缀. 示例: 实现将问题分配给用户的领域逻辑</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IssueManager</span> : <span class="title">DomainService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IRepository&lt;Issue, Guid&gt; _issueRepository;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IssueManager</span>(<span class="params">IRepository&lt;Issue, Guid&gt; issueRepository</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _issueRepository = issueRepository;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">AssignAsync</span>(<span class="params">Issue issue, AppUser user</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> currentIssueCount = <span class="keyword">await</span> _issueRepository</span><br><span class="line">            .CountAsync(i =&gt; i.AssignedUserId == user.Id);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Implementing a core business validation</span></span><br><span class="line">        <span class="keyword">if</span> (currentIssueCount &gt;= <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IssueAssignmentException(user.UserName);</span><br><span class="line">        &#125;</span><br><span class="line">        issue.AssignedUserId = user.Id;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题是定义如下所示的 聚合根:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Issue</span> : <span class="title">AggregateRoot</span>&lt;<span class="title">Guid</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Guid? AssignedUserId &#123; <span class="keyword">get</span>; <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 internal 的 set 确保外层调用者不能直接在调用 set ,并强制始终使用 IssueManager 为 User 分配 Issue.</p>
<h3 id="应用程序服务与领域服务"><a href="#应用程序服务与领域服务" class="headerlink" title="应用程序服务与领域服务"></a>应用程序服务与领域服务</h3><p>虽然 应用服务 和领域服务都实现了业务规则,但他们存在根本的逻辑和形式差异:</p>
<ul>
<li>应用程序服务实现应用程序的 用例 (典型 Web 应用程序中的用户交互), 而领域服务实现 核心的、用例独立的领域逻辑.</li>
<li>应用程序服务获取&#x2F;返回 数据传输对象（Dto）, 领域服务方法通常获取和返回 领域对象 (实体, 值对象).</li>
<li>领域服务通常由应用程序服务或其他领域服务使用,而应用程序服务由表示层或客户端应用程序使用.</li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>领域服务的生命周期是 瞬态 的,它们会自动注册到依赖注入服务.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>不要在领域层，持久化实体数据到数据库中。应该在应用服务层持久化数据。</li>
<li>将实体对象作为方法参数，而不是其id值。如果接受其id值，则需要从领域服务内的数据库中检索实体。这种方法使应用程序代码在同一请求（用例）的不同位置多次加载同一实体，这是低效的，并导致错误。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2022/12/13/ABP/%E4%BB%93%E5%82%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/13/ABP/%E4%BB%93%E5%82%A8/" class="post-title-link" itemprop="url">仓储</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-13 22:50:27" itemprop="dateCreated datePublished" datetime="2022-12-13T22:50:27+08:00">2022-12-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-11 17:56:10" itemprop="dateModified" datetime="2023-03-11T17:56:10+08:00">2023-03-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="仓储"><a href="#仓储" class="headerlink" title="仓储"></a>仓储</h1><p>在领域层和数据映射层之间进行中介,使用类似集合的接口来操作领域对象。<br>实际上,仓储用于领域对象对数据库的操作, 通常每个 聚合根 或实体会创建各自对应的仓储.</p>
<h2 id="通用仓储"><a href="#通用仓储" class="headerlink" title="通用仓储"></a>通用仓储</h2><p>ABP为每个聚合根和实体提供了默认的仓储。 你可以在服务中注入<code>IRepository&lt;TEntity, TKey&gt;</code>执行标准的<code>CRUD</code>操作。<br>默认通用仓储用法示例:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PersonAppService</span> : <span class="title">ApplicationService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IRepository&lt;Person, Guid&gt; _personRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonAppService</span>(<span class="params">IRepository&lt;Person, Guid&gt; personRepository</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _personRepository = personRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">CreateAsync</span>(<span class="params">CreatePersonDto input</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> person = <span class="keyword">new</span> Person(input.Name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> _personRepository.InsertAsync(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">GetCountAsync</span>(<span class="params"><span class="built_in">string</span> filter</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> _personRepository.CountAsync(p =&gt; p.Name.Contains(filter));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中;</p>
<ul>
<li><code>PersonAppService</code> 在它的构造函数中注入了<code>IRepository&lt;Person, Guid&gt;</code> 。</li>
<li><code>CreateAsync</code> 方法使用了 InsertAsync 创建并保存新的实体。</li>
<li><code>GetCountAsync</code> 方法用来从数据库中获取符合指定条件的的人员的数量。</li>
</ul>
<h3 id="标准仓储方法"><a href="#标准仓储方法" class="headerlink" title="标准仓储方法"></a>标准仓储方法</h3><p>通用仓储提供了一些开箱即用的标准CRUD功能:</p>
<ul>
<li>GetAsync: 根据指定的Id或断言(lambda表达式)返回实体。<ul>
<li>将在指定的实体不存在时，抛出异常 EntityNotFoundException</li>
<li>如果指定的条件存在多个实体时，抛出异常 InvalidOperationException</li>
</ul>
</li>
<li>FindAsync: 根据指定的Id或断言(lambda表达式)返回实体。<ul>
<li>如果指定的实体不存在时，返回 null 。</li>
<li>如果指定的条件存在多个实体时，抛出异常 InvalidOperationException</li>
</ul>
</li>
<li>InsertAsync: 在数据库里插入一个新的实体。</li>
<li>UpdateAsync: 在数据库里更新一个已经存在的实体。</li>
<li>DeleteAsync: 从数据库里删除指定的实体。<ul>
<li>这个方法还有一个重载根据指定的断言(lambda表达式)来删除满足条件的多个实体。</li>
</ul>
</li>
<li>GetListAsync: 返回数据库里的所有实体。</li>
<li>GetPagedListAsync: 返回一个指定长度的实体列表。 他拥有 skipCount, maxResultCount and sorting 参数.</li>
<li>GetCountAsync: 获取数据库里所有实体的数量</li>
</ul>
<p>这些方法还有还一些重载。</p>
<ul>
<li>提供 UpdateAsync 和 DeleteAsync 方法根据实体对象或者id来更新或者删除实体。</li>
<li>提供 DeleteAsync 方法用来删除符合指定条件的多个实体。</li>
</ul>
<h3 id="在存储上使用LINQ"><a href="#在存储上使用LINQ" class="headerlink" title="在存储上使用LINQ"></a>在存储上使用<code>LINQ</code></h3><p>仓储提供了一个<code>GetQueryableAsync</code>方法来获取一个<code>IQueryable&lt;TEntity&gt;</code>对象。你可以通过这个对象来对实体执行<code>LINQ</code>查询以操作数据库。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;List&lt;PersonDto&gt;&gt; GetListAsync(<span class="built_in">string</span> filter)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取 IQueryable&lt;Person&gt;</span></span><br><span class="line">            IQueryable&lt;Person&gt; queryable = <span class="keyword">await</span> _personRepository.GetQueryableAsync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建一个查询</span></span><br><span class="line">            <span class="keyword">var</span> query = <span class="keyword">from</span> person <span class="keyword">in</span> queryable</span><br><span class="line">                <span class="keyword">where</span> person.Name == filter</span><br><span class="line">                <span class="keyword">orderby</span> person.Name</span><br><span class="line">                <span class="keyword">select</span> person;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行查询</span></span><br><span class="line">            <span class="keyword">var</span> people = query.ToList();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 转DTO并返回给客户端</span></span><br><span class="line">            <span class="keyword">return</span> people.Select(p =&gt; <span class="keyword">new</span> PersonDto &#123;Name = p.Name&#125;).ToList();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>你也可以使用LINQ扩展方法:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;List&lt;PersonDto&gt;&gt; GetListAsync(<span class="built_in">string</span> filter)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取 IQueryable&lt;Person&gt;</span></span><br><span class="line">    IQueryable&lt;Person&gt; queryable = <span class="keyword">await</span> _personRepository.GetQueryableAsync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个查询</span></span><br><span class="line">    <span class="keyword">var</span> people = queryable</span><br><span class="line">        .Where(p =&gt; p.Name.Contains(filter))</span><br><span class="line">        .OrderBy(p =&gt; p.Name)</span><br><span class="line">        .ToList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转DTO并返回给客户端</span></span><br><span class="line">    <span class="keyword">return</span> people.Select(p =&gt; <span class="keyword">new</span> PersonDto &#123;Name = p.Name&#125;).ToList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以使用仓储返回的IQueryable 配合标准LINQ方法自由查询。</p>
<h3 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h3><p>下面这些方法可以用来对数据库执行批量操作;</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InsertManyAsync</span><br><span class="line">UpdateManyAsync</span><br><span class="line">DeleteManyAsync</span><br></pre></td></tr></table></figure>
<p>这些方法可以操作多个实体，如果底层数据库提供程序支持，则可以进行批量操作。</p>
<h3 id="软-x2F-硬删除"><a href="#软-x2F-硬删除" class="headerlink" title="软&#x2F;硬删除"></a>软&#x2F;硬删除</h3><p>如果一个实体是软删除实体（即实现了ISoftDelete接口），则仓储的DeleteSync方法不会删除该实体，而是在数据库中标记为“已删除”。数据过滤器系统确保不会从数据库中正常检索软删除的实体。</p>
<p>如果您的实体是软删除实体，如果您需要物理删除这个实体，您可以使用HardDeleteAsync方法强制删除。</p>
<h3 id="确保实体存在"><a href="#确保实体存在" class="headerlink" title="确保实体存在"></a>确保实体存在</h3><p><code>EnsureExistsAsync</code>扩展方法通过实体id或实体查询表达式来确保实体存在，如果其不存在，它将抛出<code>EntityNotFoundException</code>异常。</p>
<h2 id="其他通用仓储类型"><a href="#其他通用仓储类型" class="headerlink" title="其他通用仓储类型"></a>其他通用仓储类型</h2><p><code>IRepository&lt;TEntity, TKey&gt;</code> 接口 导出 了标准 <code>IQueryable&lt;TEntity&gt;</code> 你可以使用标准<code>LINQ</code>方法自由查询。这对于大多数应用程序都很好。但是，某些ORM提供程序或数据库系统可能不支持<code>IQueryable</code>接口。如果您想使用这样的提供者，就不能依赖<code>IQueryable</code>。</p>
<h3 id="基础仓储"><a href="#基础仓储" class="headerlink" title="基础仓储"></a>基础仓储</h3><p>ABP提供了<code>IBasicRepository&lt;TEntity, TPrimaryKey&gt;</code> 和 <code>IBasicRepository&lt;TEntity&gt;</code> 接口来支持这样的场景. 你可以扩展这些接口（并可选择性地从<code>BasicRepositoryBase</code>派生）为你的实体创建自定义存储库.</p>
<p>依赖于 <code>IBasicRepository</code> 而不是依赖 <code>IRepository</code>有一个优点, 即使它们不支持 <code>IQueryable</code> 也可以使用所有的数据源。</p>
<p>但主要的供应商, 像 <code>Entity Framework, NHibernate 或 MongoDb</code> 已经支持了 <code>IQueryable</code>.</p>
<p>因此, 使用 <code>IRepository</code> 是典型应用程序的 建议方法. 但是可重用的模块开发人员可能会考虑使用 <code>IBasicRepository</code> 来支持广泛的数据源.</p>
<h3 id="只读仓储"><a href="#只读仓储" class="headerlink" title="只读仓储"></a>只读仓储</h3><p>对于想要使用只读仓储的开发者,我们提供了<code>IReadOnlyRepository&lt;TEntity, TKey&gt;</code> 与 <code>IReadOnlyBasicRepository&lt;Tentity, TKey&gt;</code>接口。</p>
<h3 id="无主键的通用-泛型-仓储"><a href="#无主键的通用-泛型-仓储" class="headerlink" title="无主键的通用(泛型)仓储"></a>无主键的通用(泛型)仓储</h3><p>如果你的实体没有id主键 (例如, 它可能具有复合主键) 那么你不能使用上面定义的 <code>IRepository&lt;TEntity, TKey&gt;</code>, 在这种情况下你可以仅使用实体(类型)注入 <code>IRepository&lt;TEntity&gt;</code>。</p>
<p><code>IRepository&lt;TEntity&gt;</code> 有一些缺失的方法, 通常与实体的 Id 属性一起使用. 由于实体在这种情况下没有 Id 属性, 因此这些方法不可用. 比如 Get 方法通过id获取具有指定id的实体. 不过, 你仍然可以使用<code>IQueryable&lt;TEntity&gt;</code>的功能通过标准LINQ方法查询实体。</p>
<h3 id="自定义仓储"><a href="#自定义仓储" class="headerlink" title="自定义仓储"></a>自定义仓储</h3><p>ABP不会强制你实现任何接口或从存储库的任何基类继承。它可以只是一个简单的POCO类。 但是建议继承现有的仓储接口和类，获得开箱即用的标准方法使你的工作更轻松。<br>首先在领域层定义一个仓储接口:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPersonRepository</span> : <span class="title">IRepository</span>&lt;<span class="title">Person</span>, <span class="title">Guid</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Task&lt;Person&gt; <span class="title">FindByNameAsync</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此接口扩展了 IRepository&lt;Person, Guid&gt; 以使用已有的通用仓储功能。<br>自定义存储库依赖于你使用的数据访问工具。 在此示例中, 我们将使用Entity Framework Core:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PersonRepository</span> : <span class="title">EfCoreRepository</span>&lt;<span class="title">MyDbContext</span>, <span class="title">Person</span>, <span class="title">Guid</span>&gt;, <span class="title">IPersonRepository</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonRepository</span>(<span class="params">IDbContextProvider&lt;TestAppDbContext&gt; dbContextProvider</span>) </span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">dbContextProvider</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;Person&gt; <span class="title">FindByNameAsync</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> dbContext = <span class="keyword">await</span> GetDbContextAsync();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> dbContext.Set&lt;Person&gt;()</span><br><span class="line">            .Where(p =&gt; p.Name == name)</span><br><span class="line">            .FirstOrDefaultAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IQueryable-amp-异步操作"><a href="#IQueryable-amp-异步操作" class="headerlink" title="IQueryable &amp; 异步操作"></a>IQueryable &amp; 异步操作</h2><p><code>IRepository</code>提供<code>GetQueryableAsync()</code>来获取<code>IQueryable</code>，这意味着您可以直接在其上使用<code>LINQ</code>扩展方法</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> queryable = <span class="keyword">await</span> _personRepository.GetQueryableAsync();</span><br><span class="line"><span class="keyword">var</span> people = queryable</span><br><span class="line">    .Where(p =&gt; p.Name.Contains(nameFilter))</span><br><span class="line">    .ToList();</span><br></pre></td></tr></table></figure>
<p>.ToList, Count()… 是在 System.Linq 命名空间下定义的扩展方法.<br>你通常想要使用 .ToListAsync(), .CountAsync()…. 来编写真正的异步代码.</p>
<p>但在你使用标准的应用程序启动模板时会发现无法在应用层或领域层使用这些异步扩展方法,因为:</p>
<ul>
<li><p>这里异步方法不是标准LINQ方法,它们定义在Microsoft.EntityFrameworkCoreNuget包中.</p>
</li>
<li><p>标准模板应用层与领域层不引用EF Core 包以实现数据库提供程序独立.<br>强烈建议使用异步方法! 在执行数据库查询时不要使用同步LINQ方法,以便能够开发可伸缩的应用程序.</p>
<h3 id="选项-1-引用EF-Core"><a href="#选项-1-引用EF-Core" class="headerlink" title="选项-1: 引用EF Core"></a>选项-1: 引用EF Core</h3><p>最简单的方法是在你想要使用异步方法的项目直接引用EF Core包.<br>添加Volo.Abp.EntityFrameworkCoreNuGet包到你的项目间接引用EF Core包. 这可以确保你的应用程序其余部分兼容正确版本的EF Core.</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> queryable = <span class="keyword">await</span> _personRepository.GetQueryableAsync();</span><br><span class="line"><span class="keyword">var</span> people = queryable</span><br><span class="line">    .Where(p =&gt; p.Name.Contains(nameFilter))</span><br><span class="line">    .ToListAsync();</span><br></pre></td></tr></table></figure>
<p>当以下情况时，这个方法是推荐的：</p>
</li>
<li><p>如果你正在开发一个应用程序并且不打算在将来 更新FE Core，或者如果以后真的需要更改，你也能容忍它。我们认为，如果您正在开发最终应用程序，这是合理的。</p>
<h3 id="选项-2-使用IRepository异步扩展方法"><a href="#选项-2-使用IRepository异步扩展方法" class="headerlink" title="选项-2: 使用IRepository异步扩展方法"></a>选项-2: 使用IRepository异步扩展方法</h3><p>ABP框架为仓储提供异步扩展方法，与异步LINQ扩展方法类似。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> countAll = <span class="keyword">await</span> _personRepository</span><br><span class="line">    .CountAsync();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="keyword">await</span> _personRepository</span><br><span class="line">    .CountAsync(x =&gt; x.Name.StartsWith(<span class="string">&quot;A&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> book1984 = <span class="keyword">await</span> _bookRepository</span><br><span class="line">    .FirstOrDefaultAsync(x =&gt; x.Name == <span class="string">&quot;John&quot;</span>);    </span><br></pre></td></tr></table></figure>
<p>这种方法仍有局限性。您需要直接在存储库对象上调用扩展方法。例如，以下用法不受支持：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> queryable = <span class="keyword">await</span> _bookRepository.GetQueryableAsync();</span><br><span class="line"><span class="keyword">var</span> count = <span class="keyword">await</span> queryable.Where(x =&gt; x.Name.Contains(<span class="string">&quot;A&quot;</span>)).CountAsync();</span><br></pre></td></tr></table></figure>
<p>这是因为本例中的CountAsync()方法是在IQueryable接口上调用的，而不是在存储库对象上调用的。请参见此类情况的其他选项。</p>
<h3 id="选项-3-IAsyncQueryableExecuter"><a href="#选项-3-IAsyncQueryableExecuter" class="headerlink" title="选项-3: IAsyncQueryableExecuter"></a>选项-3: IAsyncQueryableExecuter</h3><p>IAsyncQueryableExecuter 是一个用于异步执行 IQueryable<T> 对象的服务,不依赖于实际的数据库提供程序.</T></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">AbpDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProductAppService</span> : <span class="title">ApplicationService</span>, <span class="title">IProductAppService</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IRepository&lt;Product, Guid&gt; _productRepository;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IAsyncQueryableExecuter _asyncExecuter;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ProductAppService</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">            IRepository&lt;Product, Guid&gt; productRepository,</span></span></span><br><span class="line"><span class="params"><span class="function">            IAsyncQueryableExecuter asyncExecuter</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _productRepository = productRepository;</span><br><span class="line">            _asyncExecuter = asyncExecuter;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ListResultDto&lt;ProductDto&gt;&gt; GetListAsync(<span class="built_in">string</span> name)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Obtain the IQueryable&lt;T&gt;</span></span><br><span class="line">            <span class="keyword">var</span> queryable = <span class="keyword">await</span> _productRepository.GetQueryableAsync();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//Create the query</span></span><br><span class="line">            <span class="keyword">var</span> query = queryable</span><br><span class="line">                .Where(p =&gt; p.Name.Contains(name))</span><br><span class="line">                .OrderBy(p =&gt; p.Name);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Run the query asynchronously</span></span><br><span class="line">            List&lt;Product&gt; products = <span class="keyword">await</span> _asyncExecuter.ToListAsync(query);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ApplicationService 和 DomainService 基类已经预属性注入了 AsyncExecuter 属性,所以你可直接使用.</p>
</li>
</ul>
<p>ABP框架使用实际数据库提供程序的API异步执行查询。虽然这不是执行查询的常见方式，但它是使用异步API而不依赖于数据库提供者的最佳方式。</p>
<p>当以下情况时，这个方法是推荐的：</p>
<ul>
<li>如果您想开发应用程序代码而不依赖数据库提供程序。</li>
<li>如果你正在构建一个没有数据库提供程序集成包的可重用库,但是在某些情况下需要执行 IQueryable<T>对象.<br>例如,ABP框架在 CrudAppService 基类中(参阅应用程序文档)使用 IAsyncQueryableExecuter.</T></li>
</ul>
<h3 id="选项-4-自定义仓储方法"><a href="#选项-4-自定义仓储方法" class="headerlink" title="选项-4: 自定义仓储方法"></a>选项-4: 自定义仓储方法</h3><p>当以下情况时，这个方法是推荐的：</p>
<ul>
<li>如果你想完全隔离你的领域和应用层和数据库提供程序.</li>
<li>如果你开发可重用的应用模块,并且不想强制使用特定的数据库提供程序,这应该作为一种最佳实践.</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2022/12/13/ABP/%E5%AE%9E%E4%BD%93%E4%B8%8E%E8%81%9A%E5%90%88%E6%A0%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/13/ABP/%E5%AE%9E%E4%BD%93%E4%B8%8E%E8%81%9A%E5%90%88%E6%A0%B9/" class="post-title-link" itemprop="url">实体与聚合根</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-13 15:56:39" itemprop="dateCreated datePublished" datetime="2022-12-13T15:56:39+08:00">2022-12-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-11 17:56:10" itemprop="dateModified" datetime="2023-03-11T17:56:10+08:00">2023-03-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h1><p>实体通常映射成关系数据库中的表。</p>
<h2 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h2><p>实体派生于<code>Entity&lt;TKey&gt;</code>类，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Book</span> : <span class="title">Entity</span>&lt;<span class="title">Guid</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你不想从基类<code>Entity&lt;TKey&gt;</code>派生你自己的实体，你也可以直接实现<code>IEntity&lt;TKey&gt;</code>接口。</p>
<p><code>Entity&lt;TKey&gt;</code>类只定义了一个Id属性，用作主键。在上面的例子中是<code>Guid</code>。主键也可以是其他类型，比如<code>string, int, long</code>，或者任何你需要的类型。</p>
<h3 id="Guid主键的实体"><a href="#Guid主键的实体" class="headerlink" title="Guid主键的实体"></a>Guid主键的实体</h3><p>如果你的实体主键是Guid，这里有一些好的实践方法</p>
<ul>
<li>创建一个构造函数，将Id作为参数获取并传递给基类。<ul>
<li>如果你没有设置Guid主键值，ABP框架在保存时设置。但是在将实体保存到数据库之前，最好在实体上有一个有效的Id值。</li>
</ul>
</li>
<li>如果你的实体创建了带有参数的构造函数，也要创建私有或受保护的空构造函数。空构造函数在您的数据库提供者从数据库(反序列化)读取您的实体时使用。</li>
<li>不要使用Guid.NewGuid()来设置Id值!使用IGuidGenerator服务来为实体创建Id值。通过优化IGuidGenerator，他可以生成连续的Guid值，这对于关系数据库中的聚集索引至关重要。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Book</span> : <span class="title">Entity</span>&lt;<span class="title">Guid</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Book</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span>(<span class="params">Guid id</span>)</span></span><br><span class="line"><span class="function">     : <span class="title">base</span>(<span class="params">id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="具有复合键的实体"><a href="#具有复合键的实体" class="headerlink" title="具有复合键的实体"></a>具有复合键的实体</h3><p>有些实体可能需要 复合键 .在这种情况下,可以从非泛型Entity类派生实体.如:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserRole</span> : <span class="title">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Guid UserId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Guid RoleId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> DateTime CreationTime &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserRole</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span>[] <span class="title">GetKeys</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; UserId, RoleId &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中,复合键由UserId和RoleId组成.在关系数据库中,它是相关表的复合主键. 具有复合键的实体应当实现上面代码中所示的GetKeys()方法.</p>
<h2 id="聚合根"><a href="#聚合根" class="headerlink" title="聚合根"></a>聚合根</h2><p>“聚合是域驱动设计中的一种模式.DDD的聚合是一组可以作为一个单元处理的域对象.例如,订单及订单系列的商品,这些是独立的对象,但将订单(连同订单系列的商品)视为一个聚合通常是很有用的”</p>
<p><code>AggregateRoot&lt;TKey&gt;</code>类继承自<code>Entity&lt;TKey&gt;</code>类,所以默认有<code>Id</code>这个属性.</p>
<p><strong>注意ABP框架只为聚合根创建默认的存储，当然也可以手动为所有实体创建存储</strong></p>
<p>ABP不强制你使用聚合根,实际上你可以使用上面定义的Entity类,当然,如果你想实现领域驱动设计并且创建聚合根,这里有一些最佳实践仅供参考:</p>
<ul>
<li>聚合根需要维护自身的完整性,所有的实体也是这样.但是聚合根也要维护子实体的完整性.所以,聚合根必须一直有效。</li>
<li>使用Id引用聚合根,而不使用导航属性</li>
<li>聚合根被视为一个单元.它是作为一个单元检索和更新的.它通常被认为是一个交易边界.</li>
<li>不单独修改聚合根中的子实体<h3 id="聚合根例子"><a href="#聚合根例子" class="headerlink" title="聚合根例子"></a>聚合根例子</h3>这是一个具有子实体集合的聚合根例子:<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Order</span> : <span class="title">AggregateRoot</span>&lt;<span class="title">Guid</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> ReferenceNo &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">int</span> TotalItemCount &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> DateTime CreationTime &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> List&lt;OrderLine&gt; OrderLines &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Order</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span>(<span class="params">Guid id, <span class="built_in">string</span> referenceNo</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Check.NotNull(referenceNo, <span class="keyword">nameof</span>(referenceNo));</span><br><span class="line">        </span><br><span class="line">        Id = id;</span><br><span class="line">        ReferenceNo = referenceNo;</span><br><span class="line">        </span><br><span class="line">        OrderLines = <span class="keyword">new</span> List&lt;OrderLine&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddProduct</span>(<span class="params">Guid productId, <span class="built_in">int</span> count</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(</span><br><span class="line">                <span class="string">&quot;You can not add zero or negative count of products!&quot;</span>,</span><br><span class="line">                <span class="keyword">nameof</span>(count)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> existingLine = OrderLines.FirstOrDefault(ol =&gt; ol.ProductId == productId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (existingLine == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            OrderLines.Add(<span class="keyword">new</span> OrderLine(<span class="keyword">this</span>.Id, productId, count));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            existingLine.ChangeCount(existingLine.Count + count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TotalItemCount += count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderLine</span> : <span class="title">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> Guid OrderId &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> Guid ProductId &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">int</span> Count &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">OrderLine</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="title">OrderLine</span>(<span class="params">Guid orderId, Guid productId, <span class="built_in">int</span> count</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        OrderId = orderId;</span><br><span class="line">        ProductId = productId;</span><br><span class="line">        Count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">ChangeCount</span>(<span class="params"><span class="built_in">int</span> newCount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Count = newCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span>[] <span class="title">GetKeys</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Object[] &#123;OrderId, ProductId&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果你不想你的聚合根继承AggregateRoot<TKey>类,你可以直接实现IAggregateRoot<TKey>接口</TKey></TKey></li>
</ul>
<p>Order是一个具有Guid类型Id属性的 聚合根.它有一个OrderLine实体集合.OrderLine是一个具有组合键(OrderId和 ProductId)的实体.</p>
<p>虽然这个示例可能无法实现聚合根的所有最佳实践,但它仍然遵循良好的实践:</p>
<ul>
<li>Order有一个公共的构造函数,它需要 minimal requirements 来构造一个”订单”实例.因此,在没有Id和referenceNo的时候是无法创建订单的.protected&#x2F;private的构造函数只有从数据库读取对象时 反序列化 才需要.</li>
<li>OrderLine的构造函数是internal的,所以它只能由领域层来创建.在Order.AddProduct这个方法的内部被使用.</li>
<li>Order.AddProduct实现了业务规则将商品添加到订单中</li>
<li>所有属性都有protected的set.这是为了防止实体在实体外部任意改变.因此,在没有向订单中添加新产品的情况下设置 TotalItemCount将是危险的.它的值由AddProduct方法维护.</li>
</ul>
<h3 id="带有组合键的聚合根"><a href="#带有组合键的聚合根" class="headerlink" title="带有组合键的聚合根"></a>带有组合键的聚合根</h3><p>虽然这种聚合根并不常见(也不建议使用),但实际上可以按照与上面提到的跟实体相同的方式定义复合键.在这种情况下,要使用非泛型的AggregateRoot基类.</p>
<h3 id="BasicAggregateRoot类"><a href="#BasicAggregateRoot类" class="headerlink" title="BasicAggregateRoot类"></a>BasicAggregateRoot类</h3><p>AggregateRoot 类实现了 IHasExtraProperties 和 IHasConcurrencyStamp 接口,这为派生类带来了两个属性. IHasExtraProperties 使实体可扩展(请参见下面的 额外的属性部分) 和 IHasConcurrencyStamp 添加了由ABP框架管理的 ConcurrencyStamp 属性实现乐观并发. 在大多数情况下,这些是聚合根需要的功能.</p>
<p>但是,如果你不需要这些功能,你的聚合根可以继承 BasicAggregateRoot<TKey>(或BasicAggregateRoot).</TKey></p>
<h2 id="额外的属性"><a href="#额外的属性" class="headerlink" title="额外的属性"></a>额外的属性</h2><p>ABP定义了 IHasExtraProperties 接口,可以由实体实现,以便能够动态地设置和获取的实体属性. AggregateRoot 基类已经实现了 IHasExtraProperties 接口. 如果你从这个类(或者上面定义的一个相关审计类)派生,那么你可以直接使用API​.</p>
<h3 id="GetProperty-和-SetProperty-扩展方法"><a href="#GetProperty-和-SetProperty-扩展方法" class="headerlink" title="GetProperty 和 SetProperty 扩展方法"></a>GetProperty 和 SetProperty 扩展方法</h3><p>这些扩展方法是获取和设置实体数据的推荐方法. 例:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExtraPropertiesDemoService</span> : <span class="title">ITransientDependency</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IIdentityUserRepository _identityUserRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExtraPropertiesDemoService</span>(<span class="params">IIdentityUserRepository identityUserRepository</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _identityUserRepository = identityUserRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">SetTitle</span>(<span class="params">Guid userId, <span class="built_in">string</span> title</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> user = <span class="keyword">await</span> _identityUserRepository.GetAsync(userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//SET A PROPERTY</span></span><br><span class="line">        user.SetProperty(<span class="string">&quot;Title&quot;</span>, title);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> _identityUserRepository.UpdateAsync(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">GetTitle</span>(<span class="params">Guid userId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> user = <span class="keyword">await</span> _identityUserRepository.GetAsync(userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//GET A PROPERTY</span></span><br><span class="line">        <span class="keyword">return</span> user.GetProperty&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Title&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="值对象"><a href="#值对象" class="headerlink" title="值对象"></a>值对象</h1><p>一个对象,表示领域的描述方面,没有概念上的身份被称为 值对象.</p>
<p>两个具有相同属性但id不同的实体被认为是不同的实体。但是，值对象没有id，如果它们具有相同的属性值，则它们被视为相等的。</p>
<h2 id="值对象的类"><a href="#值对象的类" class="headerlink" title="值对象的类"></a>值对象的类</h2><p>值对象是一个抽象类,可以继承它来创建值对象类</p>
<p>示例: An Address class</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Address</span> : <span class="title">ValueObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Guid CityId &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Street &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Number &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Address</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Address</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        Guid cityId,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> street,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">int</span> number</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        CityId = cityId;</span><br><span class="line">        Street = street;</span><br><span class="line">        Number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> IEnumerable&lt;<span class="built_in">object</span>&gt; <span class="title">GetAtomicValues</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> Street;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> CityId;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> Number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>值对象类必须实现 GetAtomicValues()方法来返回原始值</li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul>
<li>如果没有充分的理由将值对象设计为可变的,则将其设计为不可变（如上面的地址）.</li>
<li>构成一个值对象的属性应该形成一个概念整体.例如：CityId,Street和Number不应是个人实体的单独属性.这也使Person实体更简</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>当实体属性，没有业务规则或其他限制条件时，属性应该设置为 public；</li>
<li>当实体属性，只有简单的限制条件时(不需要根据数据库或其他实体判断)，属性应该设置为 private；在实体上创建修改方法，不要在领域层中创建；</li>
<li>当实体属性，有复杂业务规则限制时，属性应该设置为 interal；在领域层，创建修改方法；</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2022/12/12/ABP/%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E7%AB%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/12/ABP/%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E7%AB%AF/" class="post-title-link" itemprop="url">创建服务端</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-12 16:00:09" itemprop="dateCreated datePublished" datetime="2022-12-12T16:00:09+08:00">2022-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-11 17:56:10" itemprop="dateModified" datetime="2023-03-11T17:56:10+08:00">2023-03-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="创建服务端"><a href="#创建服务端" class="headerlink" title="创建服务端"></a>创建服务端</h1><h2 id="创建领域层"><a href="#创建领域层" class="headerlink" title="创建领域层"></a>创建领域层</h2><p>启动模板中的领域层分为两个项目:</p>
<ul>
<li><code>XXX.Domain</code>包含你的实体, 领域服务和其他核心域对象.</li>
<li><code>XXX.Domain.Shared</code>包含可与客户共享的常量,枚举或其他域相关对象.</li>
</ul>
<p>在解决方案的<code>领域层</code>(<code>XXX.Domain</code>项目)中定义你的实体.</p>
<p>该应用程序的主要实体是<code>Book</code>. 在<code>XXX.Domain</code>项目中创建一个<code>Books</code>文件夹(命名空间),并在其中添加名为<code>Book</code>的类,如下所示:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Volo.Abp.Domain.Entities.Auditing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Acme.BookStore.Books</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Book</span> : <span class="title">AuditedAggregateRoot</span>&lt;<span class="title">Guid</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> BookType Type &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> DateTime PublishDate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">float</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ABP</code>为实体提供了两个基本的基类:<code>AggregateRoot</code>和<code>Entity</code>.<code>Aggregate Root</code>是领域驱动设计概念之一. 可以视为直接查询和处理的根实体(请参阅实体文档).</li>
<li><code>Book</code>实体继承了<code>AuditedAggregateRoot</code>,<code>AuditedAggregateRoot</code>类在<code>AggregateRoot</code>类的基础上添加了一些基础审计属性(例如<code>CreationTime, CreatorId, LastModificationTime</code>等).<code>ABP</code>框架自动为你管理这些属性.</li>
<li><code>Guid</code>是<code>Book</code>实体的主键类型.</li>
</ul>
<h3 id="BookType枚举"><a href="#BookType枚举" class="headerlink" title="BookType枚举"></a>BookType枚举</h3><p><code>Book</code>实体使用了<code>BookType</code>枚举. 在<code>XXX.Domain.Shared</code>项目中创建<code>Books</code>文件夹(命名空间),并在其中添加<code>BookType</code>:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Acme.BookStore.Books</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">enum</span> BookType</span><br><span class="line">    &#123;</span><br><span class="line">        Undefined,</span><br><span class="line">        Adventure,</span><br><span class="line">        Biography,</span><br><span class="line">        Dystopia,</span><br><span class="line">        Fantastic,</span><br><span class="line">        Horror,</span><br><span class="line">        Science,</span><br><span class="line">        ScienceFiction,</span><br><span class="line">        Poetry</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="将Book实体添加到DbContext中"><a href="#将Book实体添加到DbContext中" class="headerlink" title="将Book实体添加到DbContext中"></a>将Book实体添加到DbContext中</h3><p><code>EF Core</code>需要你将实体和<code>DbContext</code>建立关联.最简单的做法是在<code>XXX.EntityFrameworkCore</code>项目的<code>BookStoreDbContext</code>类中添加<code>DbSet</code>属性.如下所示:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BookStoreDbContext</span> : <span class="title">AbpDbContext</span>&lt;<span class="title">BookStoreDbContext</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Book&gt; Books &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建应用程序"><a href="#创建应用程序" class="headerlink" title="创建应用程序"></a>创建应用程序</h2><p>应用程序层由两个分离的项目组成:<br><code>XXX.Application.Contracts</code>包含你的<code>DTO</code>和应用服务接口.<br><code>XXX.Application</code>包含你的应用服务实现.<br>在本部分中,你将创建一个应用程序服务,使用<code>ABP Framework</code>的<code>CrudAppService</code>基类来获取,创建,更新和删除书籍.</p>
<h3 id="BookDto"><a href="#BookDto" class="headerlink" title="BookDto"></a>BookDto</h3><p><code>CrudAppService</code> 基类需要定义实体的基本<code>DTO</code>. 在 <code>XXX.Application.Contracts</code>项目中创建<code>Books</code>文件夹(命名空间), 并在其中添加名为<code>BookDto</code>的DTO类:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Volo.Abp.Application.Dtos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Acme.BookStore.Books</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BookDto</span> : <span class="title">AuditedEntityDto</span>&lt;<span class="title">Guid</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> BookType Type &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> DateTime PublishDate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">float</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>DTO</code>类被用来在<code>表示层</code>和<code>应用层</code>传递数据.参阅DTO文档.</li>
<li>为了在用户界面上展示书籍信息,<code>BookDto</code>被用来将书籍数据传递到表示层.</li>
<li><code>BookDto</code>继承自<code>AuditedEntityDto&lt;Guid&gt;</code>.与上面定义的<code>Book</code>实体一样具有一些审计属性.</li>
</ul>
<h3 id="IBookAppService"><a href="#IBookAppService" class="headerlink" title="IBookAppService"></a>IBookAppService</h3><p>下一步是为应用程序定义接口,在<code>XXX.Application.Contracts</code>项目创建<code>Books</code>文件夹(命名空间),并在其中添加名为<code>IBookAppService</code>的接口:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Acme.BookStore.Books</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IBookAppService</span> :</span><br><span class="line">        <span class="title">ICrudAppService</span>&lt; //<span class="title">Defines</span> <span class="title">CRUD</span> <span class="title">methods</span></span><br><span class="line">            <span class="title">BookDto</span>, //<span class="title">Used</span> <span class="title">to</span> <span class="title">show</span> <span class="title">books</span></span><br><span class="line">            <span class="title">Guid</span>, //<span class="title">Primary</span> <span class="title">key</span> <span class="title">of</span> <span class="title">the</span> <span class="title">book</span> <span class="title">entity</span></span><br><span class="line">            <span class="title">PagedAndSortedResultRequestDto</span>, //<span class="title">Used</span> <span class="title">for</span> <span class="title">paging</span>/<span class="title">sorting</span></span><br><span class="line">            <span class="title">CreateUpdateBookDto</span>&gt; <span class="comment">//Used to create/update a book</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>框架定义应用程序服务的接口不是必需的. 但是,它被建议作为最佳实践.</li>
<li><code>ICrudAppService</code>定义了常见的<code>CRUD</code>方法:<code>GetAsync,GetListAsync,CreateAsync,UpdateAsync和DeleteAsync</code>. 从这个接口扩展不是必需的,你可以从空的<code>IApplicationService</code>接口继承并手动定义自己的方法(将在下一部分中完成).</li>
<li><code>ICrudAppService</code>有一些变体, 你可以在每个方法中使用单独的<code>DTO</code>(例如使用不同的<code>DTO</code>进行创建和更新).</li>
</ul>
<h3 id="BookAppService"><a href="#BookAppService" class="headerlink" title="BookAppService"></a>BookAppService</h3><p>是时候实现<code>IBookAppService</code>接口了在<code>XXX.Application</code>项目中创建<code>Books</code>文件夹(命名空间),并在其中添加名为 <code>BookAppService</code>的类:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BookAppService</span> :</span><br><span class="line">        <span class="title">CrudAppService</span>&lt;</span><br><span class="line">            <span class="title">Book</span>, //<span class="title">The</span> <span class="title">Book</span> <span class="title">entity</span></span><br><span class="line">            <span class="title">BookDto</span>, //<span class="title">Used</span> <span class="title">to</span> <span class="title">show</span> <span class="title">books</span></span><br><span class="line">            <span class="title">Guid</span>, //<span class="title">Primary</span> <span class="title">key</span> <span class="title">of</span> <span class="title">the</span> <span class="title">book</span> <span class="title">entity</span></span><br><span class="line">            <span class="title">PagedAndSortedResultRequestDto</span>, //<span class="title">Used</span> <span class="title">for</span> <span class="title">paging</span>/<span class="title">sorting</span></span><br><span class="line">            <span class="title">CreateUpdateBookDto</span>&gt;, <span class="comment">//Used to create/update a book</span></span><br><span class="line">        <span class="title">IBookAppService</span> <span class="comment">//implement the IBookAppService</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BookAppService</span>(<span class="params">IRepository&lt;Book, Guid&gt; repository</span>)</span></span><br><span class="line"><span class="function">            : <span class="title">base</span>(<span class="params">repository</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>BookAppService</code>继承了<code>CrudAppService&lt;...&gt;</code>.它实现了<code>ICrudAppService</code>定义的<code>CRUD</code>方法.</li>
<li><code>BookAppService</code>注入<code>IRepository &lt;Book,Guid&gt;</code>,这是<code>Book</code>实体的默认仓储.<code>ABP</code>自动为每个聚合根(或实体)创建默认仓储. 请参阅仓储文档</li>
<li><code>BookAppService</code>使用<code>IObjectMapper</code>将<code>Book</code>对象转换为<code>BookDto</code>对象, 将<code>CreateUpdateBookDto</code>对象转换为<code>Book</code>对象. 启动模板使用<code>AutoMapper</code>库作为对象映射提供程序. 我们之前定义了映射, 因此它将按预期工作.</li>
</ul>
<h3 id="自动生成API-Controllers"><a href="#自动生成API-Controllers" class="headerlink" title="自动生成API Controllers"></a>自动生成API Controllers</h3><p>在典型的<code>ASP.NET Core</code>应用程序中,你创建<code>API Controller</code>以将应用程序服务公开为<code>HTTP API</code>端点. 这将允许浏览器或第三方客户端通过<code>HTTP</code>调用它们.</p>
<p><code>ABP</code>可以自动按照约定将你的应用程序服务配置为<code>MVC API</code>控制器.</p>
<h1 id="图书列表页面"><a href="#图书列表页面" class="headerlink" title="图书列表页面"></a>图书列表页面</h1><h2 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h2><p>本地化文本位于<code>XXX.Domain.Shared</code>项目的<code>Localization/BookStore</code>文件夹下:</p>
<p><strong>简体中文翻译请打开zh-Hans.json文件 ,并将”Texts”对象中对应的值替换为中文.</strong></p>
<ul>
<li>本地化关键字名称是任意的. 你可以设置任何名称. 对于特定的文本类型,我们更喜欢遵循一些约定:</li>
<li>为按钮项添加 Menu: 前缀.</li>
<li>使用 Enum:<enum-type>:<enum-name> 或 <enum-type>.<enum-name> 或 <enum-name> 命名约定来本地化枚举成员. 当您这样做时ABP可以在某些适当的情况下自动将枚举本地化.</enum-name></enum-name></enum-type></enum-name></enum-type></li>
<li>如果未在本地化文件中定义文本,则文本将回退到本地化键(ASP.NET Core的标准行为).</li>
</ul>
<h2 id="生成服务代理"><a href="#生成服务代理" class="headerlink" title="生成服务代理"></a>生成服务代理</h2><p><code>ABP CLI</code> 提供 <code>generate-proxy</code> 命令为<code>HTTP APIs</code>生成客户端代理.有了这些代理,在客户端使用<code>HTTP APIs</code>变得更加方便. 运行<code>generate-proxy</code>命令前, 你的<code>host</code>必须正在运行.<br>启动host应用程序后,在 angular 文件夹下运行以下命令:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abp generate-proxy -t ng</span><br></pre></td></tr></table></figure>

<h2 id="创建新书籍"><a href="#创建新书籍" class="headerlink" title="创建新书籍"></a>创建新书籍</h2><h1 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h1><h1 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
