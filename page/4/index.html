<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"leetao50.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
<meta property="og:type" content="website">
<meta property="og:title" content="InfoPool">
<meta property="og:url" content="https://leetao50.github.io/page/4/index.html">
<meta property="og:site_name" content="InfoPool">
<meta property="og:description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
<meta property="og:locale" content="zh_CN">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://leetao50.github.io/page/4/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>InfoPool</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">InfoPool</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">私人信息记录</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">记录信息来源网络，内容只为方便查找，非公开信息，非请勿入</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2022/11/19/EFCore/%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9E%8B(%E4%BA%8C)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/19/EFCore/%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9E%8B(%E4%BA%8C)/" class="post-title-link" itemprop="url">创建模型(二)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-11-19 17:19:56" itemprop="dateCreated datePublished" datetime="2022-11-19T17:19:56+08:00">2022-11-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-20 12:16:29" itemprop="dateModified" datetime="2023-03-20T12:16:29+08:00">2023-03-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="值转换"><a href="#值转换" class="headerlink" title="值转换"></a>值转换</h1><p>值转换器可在从数据库读取或向其中写入属性值时转换属性值。 此转换可以是从同一类型的一个值转换为另一个值（例如加密字符串），也可以是从一种类型的值转换为另一种类型的值（例如数据库中枚举值和字符串的相互转换）。</p>
<p>值转换器的指定涉及 ModelClrType 和 ProviderClrType。 ModelClrType是实体类型中的属性的 .NET 类型。 ProviderClrType是数据库提供程序理解的 .NET 类型。 例如，若要在数据库中将枚举保存为字符串，模型类型(ModelClrType)是枚举的类型，而提供程序类型(ProviderClrType)是 String。 </p>
<p>使用两个 Func 表达式树定义转换：一个从 ModelClrType 转换为 ProviderClrType，另一个从 ProviderClrType 转换为 ModelClrType。 使用表达式树的目的是使它们可被编译到数据库访问委托中，以便进行高效转换。 表达式树可能包含对复杂转换的转换方法的简单调用。</p>
<h2 id="配置值转换器"><a href="#配置值转换器" class="headerlink" title="配置值转换器"></a>配置值转换器</h2><p>值转换在 中 DbContext.OnModelCreating配置。 例如，假设将一个枚举和实体类型定义为：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Rider</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> EquineBeast Mount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> EquineBeast</span><br><span class="line">&#123;</span><br><span class="line">    Donkey,</span><br><span class="line">    Mule,</span><br><span class="line">    Horse,</span><br><span class="line">    Unicorn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在 中 OnModelCreating 配置转换，以将枚举值作为字符串（如“Donkey”、“Mule”等）存储在数据库中;只需提供一个从 ModelClrType 转换为 ProviderClrType的函数，为相反的转换提供另一个函数：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder</span><br><span class="line">        .Entity&lt;Rider&gt;()</span><br><span class="line">        .Property(e =&gt; e.Mount)</span><br><span class="line">        .HasConversion(</span><br><span class="line">            v =&gt; v.ToString(),</span><br><span class="line">            v =&gt; (EquineBeast)Enum.Parse(<span class="keyword">typeof</span>(EquineBeast), v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="批量配置值转换器"><a href="#批量配置值转换器" class="headerlink" title="批量配置值转换器"></a>批量配置值转换器</h2><p>为使用相关 CLR 类型的每个属性配置相同的值转换器很常见。 可以使用 预约定模型配置 为整个模型执行此操作一次，而不是为每个属性手动执行此操作。 因为它在允许运行模型生成约定之前配置模型的各个方面。 通过重写 ConfigureConventions 派生自 DbContext的类型来应用此类配置。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CurrencyConverter</span> : <span class="title">ValueConverter</span>&lt;<span class="title">Currency</span>, <span class="title">decimal</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CurrencyConverter</span>()</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">            v =&gt; v.Amount,</span></span></span><br><span class="line"><span class="params"><span class="function">            v =&gt; <span class="keyword">new</span> Currency(v</span>))</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在上下文类型中重写 ConfigureConventions 并配置转换器，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">ConfigureConventions</span>(<span class="params">ModelConfigurationBuilder configurationBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    configurationBuilder</span><br><span class="line">        .Properties&lt;Currency&gt;()</span><br><span class="line">        .HaveConversion&lt;CurrencyConverter&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此示例演示如何在 类型 string的所有属性上配置一些方面：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">configurationBuilder</span><br><span class="line">    .Properties&lt;<span class="built_in">string</span>&gt;()</span><br><span class="line">    .AreUnicode(<span class="literal">false</span>)</span><br><span class="line">    .HaveMaxLength(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>

<h2 id="预定义的转换"><a href="#预定义的转换" class="headerlink" title="预定义的转换"></a>预定义的转换</h2><p>EF Core 含有许多预定义转换，不需要手动编写转换函数。 而是根据模型中的属性类型和请求的数据库提供程序类型选取要使用的转换。</p>
<p>例如，枚举到字符串的转换用作上面的示例，但当提供程序类型配置为 string 使用 的泛型类型 HasConversion时，EF Core 实际上会自动执行此操作：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder</span><br><span class="line">        .Entity&lt;Rider&gt;()</span><br><span class="line">        .Property(e =&gt; e.Mount)</span><br><span class="line">        .HasConversion&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可通过显式地指定数据库列类型实现相同的操作。 例如，如果实体类型的定义如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Rider2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Column(TypeName = <span class="string">&quot;nvarchar(24)&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> EquineBeast Mount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后枚举值将保存为数据库中的字符串，而无需在 中 OnModelCreating进行任何进一步配置。</p>
<h2 id="ValueConverter-类"><a href="#ValueConverter-类" class="headerlink" title="ValueConverter 类"></a>ValueConverter 类</h2><p>如上所示调用 HasConversion 将创建一个 ValueConverter&lt;TModel,TProvider&gt; 实例并在 属性上设置它。 可改为显式地创建 ValueConverter。 例如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> converter = <span class="keyword">new</span> ValueConverter&lt;EquineBeast, <span class="built_in">string</span>&gt;(</span><br><span class="line">        v =&gt; v.ToString(),</span><br><span class="line">        v =&gt; (EquineBeast)Enum.Parse(<span class="keyword">typeof</span>(EquineBeast), v));</span><br><span class="line"></span><br><span class="line">    modelBuilder</span><br><span class="line">        .Entity&lt;Rider&gt;()</span><br><span class="line">        .Property(e =&gt; e.Mount)</span><br><span class="line">        .HasConversion(converter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个属性使用同一个转换时，这非常有用。</p>
<h2 id="内置转换器"><a href="#内置转换器" class="headerlink" title="内置转换器"></a>内置转换器</h2><p>如上所述，EF Core 附带了一组预定义 ValueConverter&lt;TModel,TProvider&gt; 的类，这些类位于 命名空间中 Microsoft.EntityFrameworkCore.Storage.ValueConversion 。 在许多情况下，EF 将根据模型中属性的类型和在数据库中请求的类型，选择适当的内置转换器，正如上面的枚举转换示例所示。 例如，对 bool 属性使用 .HasConversion<int>() 会使 EF Core 将布尔值转换为数值零和一：</int></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder</span><br><span class="line">        .Entity&lt;User&gt;()</span><br><span class="line">        .Property(e =&gt; e.IsActive)</span><br><span class="line">        .HasConversion&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这在功能上与创建内置 BoolToZeroOneConverter<TProvider> 实例并显式设置它相同：</TProvider></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> converter = <span class="keyword">new</span> BoolToZeroOneConverter&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    modelBuilder</span><br><span class="line">        .Entity&lt;User&gt;()</span><br><span class="line">        .Property(e =&gt; e.IsActive)</span><br><span class="line">        .HasConversion(converter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果默认情况下所有 EquineBeast 列都应为 varchar(20)，则可以将此信息作为 提供给值转换器 ConverterMappingHints。 例如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> converter = <span class="keyword">new</span> ValueConverter&lt;EquineBeast, <span class="built_in">string</span>&gt;(</span><br><span class="line">        v =&gt; v.ToString(),</span><br><span class="line">        v =&gt; (EquineBeast)Enum.Parse(<span class="keyword">typeof</span>(EquineBeast), v),</span><br><span class="line">        <span class="keyword">new</span> ConverterMappingHints(size: <span class="number">20</span>, unicode: <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    modelBuilder</span><br><span class="line">        .Entity&lt;Rider&gt;()</span><br><span class="line">        .Property(e =&gt; e.Mount)</span><br><span class="line">        .HasConversion(converter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在只要使用此转换器，数据库列就不能采用 unicode，且最长为 20 个字符。 但是，这些只是提示，因为它们被映射属性上显式设置的任何方面覆盖。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="简单值对象"><a href="#简单值对象" class="headerlink" title="简单值对象"></a>简单值对象</h3><p>此示例使用简单类型来包装基元类型。 希望模型中的类型比基元类型更具体（因而更具类型安全性）时，这很有用。 在此示例中，该类型为 Dollars，它包装小数基元：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">struct</span> Dollars</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dollars</span>(<span class="params"><span class="built_in">decimal</span> amount</span>)</span> </span><br><span class="line">        =&gt; Amount = amount;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Amount &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span> </span><br><span class="line">        =&gt; <span class="string">$&quot;$<span class="subst">&#123;Amount&#125;</span>&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这可用于实体类型中：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Order</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Dollars Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可在存储到数据库中时被转换为基本 decimal：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Order&gt;()</span><br><span class="line">    .Property(e =&gt; e.Price)</span><br><span class="line">    .HasConversion(</span><br><span class="line">        v =&gt; v.Amount,</span><br><span class="line">        v =&gt; <span class="keyword">new</span> Dollars(v));</span><br></pre></td></tr></table></figure>

<h3 id="值对象的集合"><a href="#值对象的集合" class="headerlink" title="值对象的集合"></a>值对象的集合</h3><p>我们可以创建一个值对象集合。 例如，假设有一个 AnnualFinance 类型，它为博客一年的财务状况建模：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">struct</span> AnnualFinance</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">JsonConstructor</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnnualFinance</span>(<span class="params"><span class="built_in">int</span> year, Money income, Money expenses</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Year = year;</span><br><span class="line">        Income = income;</span><br><span class="line">        Expenses = expenses;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Year &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Money Income &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Money Expenses &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Money Revenue =&gt; <span class="keyword">new</span> Money(Income.Amount - Expenses.Amount, Income.Currency);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此类型构成几个我们先前创建的 Money 类型：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">struct</span> Money</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">JsonConstructor</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Money</span>(<span class="params"><span class="built_in">decimal</span> amount, Currency currency</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Amount = amount;</span><br><span class="line">        Currency = currency;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">        =&gt; (Currency == Currency.UsDollars ? <span class="string">&quot;$&quot;</span> : <span class="string">&quot;£&quot;</span>) + Amount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Amount &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Currency Currency &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Currency</span><br><span class="line">&#123;</span><br><span class="line">    UsDollars,</span><br><span class="line">    PoundsSterling</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们可以向实体类型添加一个 AnnualFinance 集合：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IList&lt;AnnualFinance&gt; Finances &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来再次使用序列化来进行存储：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">    .Property(e =&gt; e.Finances)</span><br><span class="line">    .HasConversion(</span><br><span class="line">        v =&gt; JsonSerializer.Serialize(v, (JsonSerializerOptions)<span class="literal">null</span>),</span><br><span class="line">        v =&gt; JsonSerializer.Deserialize&lt;List&lt;AnnualFinance&gt;&gt;(v, (JsonSerializerOptions)<span class="literal">null</span>),</span><br><span class="line">        <span class="keyword">new</span> ValueComparer&lt;IList&lt;AnnualFinance&gt;&gt;(</span><br><span class="line">            (c1, c2) =&gt; c1.SequenceEqual(c2),</span><br><span class="line">            c =&gt; c.Aggregate(<span class="number">0</span>, (a, v) =&gt; HashCode.Combine(a, v.GetHashCode())),</span><br><span class="line">            c =&gt; (IList&lt;AnnualFinance&gt;)c.ToList()));</span><br></pre></td></tr></table></figure>
<h3 id="使用不区分大小写的字符串键"><a href="#使用不区分大小写的字符串键" class="headerlink" title="使用不区分大小写的字符串键"></a>使用不区分大小写的字符串键</h3><p>一些数据库（包括 SQL Server）默认执行不区分大小写的字符串比较。 另一方面，.NET 默认执行区分大小写的字符串比较。 这意味着，“DotNet”之类的外键值将与 SQL Server 上的主键值“dotnet”匹配，但与 EF Core 中的该值不匹配。 键的值比较器可用于强制 EF Core 执行不区分大小写的字符串比较，就像在数据库中那样。 例如，请考虑使用拥有字符串键的博客&#x2F;文章模型：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ICollection&lt;Post&gt; Posts &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Blog Blog &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果某些 Post.BlogId 值具有不同的大小写，此模型不会按预期工作。 此问题造成的错误取决于应用程序正在执行的操作，通常都涉及未正确修复的对象图和&#x2F;或由于 FK 值错误而失败的更新。 值比较器可用于更正这种情况：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> comparer = <span class="keyword">new</span> ValueComparer&lt;<span class="built_in">string</span>&gt;(</span><br><span class="line">        (l, r) =&gt; <span class="built_in">string</span>.Equals(l, r, StringComparison.OrdinalIgnoreCase),</span><br><span class="line">        v =&gt; v.ToUpper().GetHashCode(),</span><br><span class="line">        v =&gt; v);</span><br><span class="line"></span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(e =&gt; e.Id)</span><br><span class="line">        .Metadata.SetValueComparer(comparer);</span><br><span class="line"></span><br><span class="line">    modelBuilder.Entity&lt;Post&gt;(</span><br><span class="line">        b =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            b.Property(e =&gt; e.Id).Metadata.SetValueComparer(comparer);</span><br><span class="line">            b.Property(e =&gt; e.BlogId).Metadata.SetValueComparer(comparer);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>.NET 字符串比较和数据库字符串比较的区别不仅限于大小写敏感性。 此模式适用于简单的 ASCII 键，但对于具有任意一种区域性特定字符的键，可能会失败。</p>
</blockquote>
<h3 id="处理定长的数据库字符串"><a href="#处理定长的数据库字符串" class="headerlink" title="处理定长的数据库字符串"></a>处理定长的数据库字符串</h3><p>前一个示例不需要值转换器。 但是，对于定长数据库字符串类型（如 char(20) 或 nchar(20)），转换器很有用。 每当向数据库插入值时，都会将定长字符串填充到完整长度。 这意味着键值“dotnet”在从数据库中读回时将为“dotnet…………..”，其中 . 表示空格字符。 这样将不能与未填充的键值正确地进行比较。</p>
<p>值转换器可用于在读取键值时剪裁填充。 可将此与上一个示例中的值比较器结合，以正确比较定长的不区分大小写的 ASCII 键。 例如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> converter = <span class="keyword">new</span> ValueConverter&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;(</span><br><span class="line">        v =&gt; v,</span><br><span class="line">        v =&gt; v.Trim());</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">var</span> comparer = <span class="keyword">new</span> ValueComparer&lt;<span class="built_in">string</span>&gt;(</span><br><span class="line">        (l, r) =&gt; <span class="built_in">string</span>.Equals(l, r, StringComparison.OrdinalIgnoreCase),</span><br><span class="line">        v =&gt; v.ToUpper().GetHashCode(),</span><br><span class="line">        v =&gt; v);</span><br><span class="line"></span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(e =&gt; e.Id)</span><br><span class="line">        .HasColumnType(<span class="string">&quot;char(20)&quot;</span>)</span><br><span class="line">        .HasConversion(converter, comparer);</span><br><span class="line"></span><br><span class="line">    modelBuilder.Entity&lt;Post&gt;(</span><br><span class="line">        b =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            b.Property(e =&gt; e.Id).HasColumnType(<span class="string">&quot;char(20)&quot;</span>).HasConversion(converter, comparer);</span><br><span class="line">            b.Property(e =&gt; e.BlogId).HasColumnType(<span class="string">&quot;char(20)&quot;</span>).HasConversion(converter, comparer);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加密属性值"><a href="#加密属性值" class="headerlink" title="加密属性值"></a>加密属性值</h3><p>值转换器可用于在将属性值发送到数据库之前对其加密，再在发送回来时解密。例如，使用字符串反转替代实际加密算法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;User&gt;().Property(e =&gt; e.Password).HasConversion(</span><br><span class="line">    v =&gt; <span class="keyword">new</span> <span class="built_in">string</span>(v.Reverse().ToArray()),</span><br><span class="line">    v =&gt; <span class="keyword">new</span> <span class="built_in">string</span>(v.Reverse().ToArray()));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>目前没有任何方法可以从值转换器内获取对当前 DbContext 或其他会话状态的引用。 这限制了可以使用的加密类型。</p>
</blockquote>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>目前，值转换系统存在一些已知的限制：</p>
<ul>
<li>如上所述，不能转换 null。</li>
<li>目前没有办法将一个属性的转换扩展到多个列，反之亦然。</li>
<li>对于通过值转换器映射的大多数键，不支持值生成。</li>
<li>值转换无法引用当前的 DbContext 实例。</li>
<li>使用值转换类型的参数当前不能在原始 SQL API 中使用。</li>
</ul>
<h1 id="值比较器"><a href="#值比较器" class="headerlink" title="值比较器"></a>值比较器</h1><p>EF Core 内置有用于快照截取和比较数据库中使用的大多数标准类型的逻辑，所以用户通常不需要担心这个问题。 但是，当通过值转换器映射属性时，EF Core 需要对任意用户类型执行比较，这可能很复杂。 默认情况下，EF Core 使用类型定义的默认相等比较， (例如 Equals 方法) ;对于快照， 将复制值类型 以生成快照，而对于 引用类型 ，不进行复制，并将同一实例用作快照。</p>
<p>如果内置比较行为不合适，用户可以提供值比较器，其中包含用于快照截取、比较和计算哈希代码的逻辑。 例如，下面将 List<int> 属性的值转换设置为将值转换为数据库中的 JSON 字符串，并定义适当的值比较器：</int></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder</span><br><span class="line">    .Entity&lt;EntityType&gt;()</span><br><span class="line">    .Property(e =&gt; e.MyListProperty)</span><br><span class="line">    .HasConversion(</span><br><span class="line">        v =&gt; JsonSerializer.Serialize(v, (JsonSerializerOptions)<span class="literal">null</span>),</span><br><span class="line">        v =&gt; JsonSerializer.Deserialize&lt;List&lt;<span class="built_in">int</span>&gt;&gt;(v, (JsonSerializerOptions)<span class="literal">null</span>),</span><br><span class="line">        <span class="keyword">new</span> ValueComparer&lt;List&lt;<span class="built_in">int</span>&gt;&gt;(</span><br><span class="line">            (c1, c2) =&gt; c1.SequenceEqual(c2),</span><br><span class="line">            c =&gt; c.Aggregate(<span class="number">0</span>, (a, v) =&gt; HashCode.Combine(a, v.GetHashCode())),</span><br><span class="line">            c =&gt; c.ToList()));</span><br></pre></td></tr></table></figure>

<h3 id="简单的不可变类"><a href="#简单的不可变类" class="headerlink" title="简单的不可变类"></a>简单的不可变类</h3><p>考虑一个使用值转换器映射简单的不可变类的属性。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ImmutableClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImmutableClass</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Value = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Value &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params">ImmutableClass other</span>)</span></span><br><span class="line">        =&gt; Value == other.Value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params"><span class="built_in">object</span> obj</span>)</span></span><br><span class="line">        =&gt; ReferenceEquals(<span class="keyword">this</span>, obj) || obj <span class="keyword">is</span> ImmutableClass other &amp;&amp; Equals(other);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">GetHashCode</span>()</span></span><br><span class="line">        =&gt; Value.GetHashCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">modelBuilder</span><br><span class="line">    .Entity&lt;MyEntityType&gt;()</span><br><span class="line">    .Property(e =&gt; e.MyProperty)</span><br><span class="line">    .HasConversion(</span><br><span class="line">        v =&gt; v.Value,</span><br><span class="line">        v =&gt; <span class="keyword">new</span> ImmutableClass(v));</span><br></pre></td></tr></table></figure>
<p>此类型的属性不需要特殊比较或快照，原因如下：</p>
<ul>
<li>相等性被覆盖，以便不同的实例可以正确比较</li>
<li>类型是不可变的，所以不可能改变快照值<br>因此，在这种情况下，EF Core 的默认行为本身就是正常的。</li>
</ul>
<h3 id="可变类"><a href="#可变类" class="headerlink" title="可变类"></a>可变类</h3><p>建议尽可能将不可变类型（类或结构）与值转换器一起使用。 这通常比使用可变类型更有效，语义更清晰。 但是，话虽如此，使用应用程序无法更改的类型的属性是很常见的。 例如，映射包含数字列表的属性：<br><code>public List&lt;int&gt; MyListProperty &#123; get; set; &#125;</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder</span><br><span class="line">    .Entity&lt;EntityType&gt;()</span><br><span class="line">    .Property(e =&gt; e.MyListProperty)</span><br><span class="line">    .HasConversion(</span><br><span class="line">        v =&gt; JsonSerializer.Serialize(v, (JsonSerializerOptions)<span class="literal">null</span>),</span><br><span class="line">        v =&gt; JsonSerializer.Deserialize&lt;List&lt;<span class="built_in">int</span>&gt;&gt;(v, (JsonSerializerOptions)<span class="literal">null</span>),</span><br><span class="line">        <span class="keyword">new</span> ValueComparer&lt;List&lt;<span class="built_in">int</span>&gt;&gt;(</span><br><span class="line">            (c1, c2) =&gt; c1.SequenceEqual(c2),</span><br><span class="line">            c =&gt; c.Aggregate(<span class="number">0</span>, (a, v) =&gt; HashCode.Combine(a, v.GetHashCode())),</span><br><span class="line">            c =&gt; c.ToList()));</span><br></pre></td></tr></table></figure>
<p>构造 ValueComparer<T> 函数接受三个表达式：</T></p>
<ul>
<li>用于检查相等性的表达式</li>
<li>用于生成哈希代码的表达式</li>
<li>用于截取值的快照的表达式<br>在这种情况下，比较是通过检查数字序列是否相同来完成的。</li>
</ul>
<p>同样，哈希代码也是基于相同的序列构建的。 (请注意，这是可变值的哈希代码，因此 可能会导致问题。如果可以，则不可变。)</p>
<p>快照是通过使用 ToList 克隆列表来创建的。 同样，仅当要转变列表时，才需要这样做。 如果可以，请改为不可变。</p>
<h1 id="高级表映射"><a href="#高级表映射" class="headerlink" title="高级表映射"></a>高级表映射</h1><h2 id="表拆分"><a href="#表拆分" class="headerlink" title="表拆分"></a>表拆分</h2><p>EF Core 允许将两个或多个实体映射到一个表。 这称为“表拆分”或“表共享”。</p>
<p>若要使用表拆分，需将实体类型映射到同一个表，将主键映射到相同的列，并且在同一个表中的一种实体类型的主键和另一种实体类型的主键之间至少配置一种关系。</p>
<p>表拆分的一个常见场景是仅使用表中的部分列，以提高性能或实现封装。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Order</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> OrderStatus? Status &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DetailedOrder DetailedOrder &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DetailedOrder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> OrderStatus? Status &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> BillingAddress &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> ShippingAddress &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">byte</span>[] Version &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">modelBuilder.Entity&lt;DetailedOrder&gt;(</span><br><span class="line">    dob =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        dob.ToTable(<span class="string">&quot;Orders&quot;</span>);</span><br><span class="line">        dob.Property(o =&gt; o.Status).HasColumnName(<span class="string">&quot;Status&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">modelBuilder.Entity&lt;Order&gt;(</span><br><span class="line">    ob =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        ob.ToTable(<span class="string">&quot;Orders&quot;</span>);</span><br><span class="line">        ob.Property(o =&gt; o.Status).HasColumnName(<span class="string">&quot;Status&quot;</span>);</span><br><span class="line">        ob.HasOne(o =&gt; o.DetailedOrder).WithOne()</span><br><span class="line">            .HasForeignKey&lt;DetailedOrder&gt;(o =&gt; o.Id);</span><br><span class="line">        ob.Navigation(o =&gt; o.DetailedOrder).IsRequired();</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="实体拆分"><a href="#实体拆分" class="headerlink" title="实体拆分"></a>实体拆分</h2><p>EF Core 允许将实体映射到两个或多个表中的行。 这称为 实体拆分。</p>
<p>例如，假设有一个数据库，其中包含三个保存客户数据的表：</p>
<ul>
<li>Customers客户信息的表</li>
<li>PhoneNumbers客户的电话号码表</li>
<li>Addresses客户地址表<br>下面是SQL Server中这些表的定义：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [Customers] (</span><br><span class="line">    [Id] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">IDENTITY</span>,</span><br><span class="line">    [Name] nvarchar(max) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_Customers] <span class="keyword">PRIMARY</span> KEY ([Id])</span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [PhoneNumbers] (</span><br><span class="line">    [CustomerId] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    [PhoneNumber] nvarchar(max) <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_PhoneNumbers] <span class="keyword">PRIMARY</span> KEY ([CustomerId]),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [FK_PhoneNumbers_Customers_CustomerId] <span class="keyword">FOREIGN</span> KEY ([CustomerId]) <span class="keyword">REFERENCES</span> [Customers] ([Id]) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [Addresses] (</span><br><span class="line">    [CustomerId] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    [Street] nvarchar(max) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    [City] nvarchar(max) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    [PostCode] nvarchar(max) <span class="keyword">NULL</span>,</span><br><span class="line">    [Country] nvarchar(max) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_Addresses] <span class="keyword">PRIMARY</span> KEY ([CustomerId]),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [FK_Addresses_Customers_CustomerId] <span class="keyword">FOREIGN</span> KEY ([CustomerId]) <span class="keyword">REFERENCES</span> [Customers] ([Id]) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
这些表中的每个表通常映射到自己的实体类型，并具有类型之间的关系。 但是，如果所有三个表始终一起使用，则将它们全部映射到单个实体类型会更方便。 例如：<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Customer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> street, <span class="built_in">string</span> city, <span class="built_in">string</span>? postCode, <span class="built_in">string</span> country</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">        Street = street;</span><br><span class="line">        City = city;</span><br><span class="line">        PostCode = postCode;</span><br><span class="line">        Country = country;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>? PhoneNumber &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Street &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> City &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>? PostCode &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Country &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这是在 EF7 中通过为实体类型中的每个拆分调用 SplitToTable 来实现的。 例如，以下代码将 Customer 实体类型拆分为上面所示的 Customers、 PhoneNumbers和 Addresses 表：<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Customer&gt;(</span><br><span class="line">    entityBuilder =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        entityBuilder</span><br><span class="line">            .ToTable(<span class="string">&quot;Customers&quot;</span>)</span><br><span class="line">            .SplitToTable(</span><br><span class="line">                <span class="string">&quot;PhoneNumbers&quot;</span>,</span><br><span class="line">                tableBuilder =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    tableBuilder.Property(customer =&gt; customer.Id).HasColumnName(<span class="string">&quot;CustomerId&quot;</span>);</span><br><span class="line">                    tableBuilder.Property(customer =&gt; customer.PhoneNumber);</span><br><span class="line">                &#125;)</span><br><span class="line">            .SplitToTable(</span><br><span class="line">                <span class="string">&quot;Addresses&quot;</span>,</span><br><span class="line">                tableBuilder =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    tableBuilder.Property(customer =&gt; customer.Id).HasColumnName(<span class="string">&quot;CustomerId&quot;</span>);</span><br><span class="line">                    tableBuilder.Property(customer =&gt; customer.Street);</span><br><span class="line">                    tableBuilder.Property(customer =&gt; customer.City);</span><br><span class="line">                    tableBuilder.Property(customer =&gt; customer.PostCode);</span><br><span class="line">                    tableBuilder.Property(customer =&gt; customer.Country);</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h3></li>
<li>实体拆分不能用于继承结构中的实体类型。</li>
<li>对于主表中的任何行，每个拆分表中都必须有一行。</li>
</ul>
<h3 id="TPT继承映射"><a href="#TPT继承映射" class="headerlink" title="TPT继承映射"></a>TPT继承映射</h3><p>例如，假设有一个简单的继承层次结构：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Breed &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="literal">null</span>!;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>? EducationalLevel &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>? FavoriteToy &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 TPT 继承映射策略，这些类型将映射到三个表。 但是，每个表中的主键列可能具有不同的名称。 例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [Animals] (</span><br><span class="line">    [Id] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">IDENTITY</span>,</span><br><span class="line">    [Breed] nvarchar(max) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_Animals] <span class="keyword">PRIMARY</span> KEY ([Id])</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [Cats] (</span><br><span class="line">    [CatId] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    [EducationalLevel] nvarchar(max) <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_Cats] <span class="keyword">PRIMARY</span> KEY ([CatId]),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [FK_Cats_Animals_CatId] <span class="keyword">FOREIGN</span> KEY ([CatId]) <span class="keyword">REFERENCES</span> [Animals] ([Id]) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [Dogs] (</span><br><span class="line">    [DogId] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    [FavoriteToy] nvarchar(max) <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_Dogs] <span class="keyword">PRIMARY</span> KEY ([DogId]),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [FK_Dogs_Animals_DogId] <span class="keyword">FOREIGN</span> KEY ([DogId]) <span class="keyword">REFERENCES</span> [Animals] ([Id]) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>EF7 允许使用嵌套表生成器配置此映射：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Animal&gt;().ToTable(<span class="string">&quot;Animals&quot;</span>);</span><br><span class="line"></span><br><span class="line">modelBuilder.Entity&lt;Cat&gt;()</span><br><span class="line">    .ToTable(</span><br><span class="line">        <span class="string">&quot;Cats&quot;</span>,</span><br><span class="line">        tableBuilder =&gt; tableBuilder.Property(cat =&gt; cat.Id).HasColumnName(<span class="string">&quot;CatId&quot;</span>));</span><br><span class="line"></span><br><span class="line">modelBuilder.Entity&lt;Dog&gt;()</span><br><span class="line">    .ToTable(</span><br><span class="line">        <span class="string">&quot;Dogs&quot;</span>,</span><br><span class="line">        tableBuilder =&gt; tableBuilder.Property(dog =&gt; dog.Id).HasColumnName(<span class="string">&quot;DogId&quot;</span>));</span><br></pre></td></tr></table></figure>

<h1 id="从属实体类型"><a href="#从属实体类型" class="headerlink" title="从属实体类型"></a>从属实体类型</h1><p>EF Core 使你能够对只能出现在其他实体类型的导航属性上的实体类型进行建模。 它们称为“从属实体类型”。 包含从属实体类型的实体是其所有者。</p>
<p>从属实体本质上是所有者的一部分，没有它就不能存在，它们在概念上类似于聚合。 这意味着，根据定义，从属实体位于与所有者关系的从属关系中。</p>
<h2 id="将类型配置为Owned"><a href="#将类型配置为Owned" class="headerlink" title="将类型配置为Owned"></a>将类型配置为Owned</h2><p>在大多数提供程序中，实体类型永远不会按约定配置为已拥有，必须显式使用 OnModelCreating 中的 OwnsOne 方法或使用 OwnedAttribute 为类型做注释以将类型配置为已拥有。</p>
<p>在此示例中，StreetAddress 是一个无标识类型。 它用作 Order 类型的属性来指定特定订单的发货地址。我们可以使用 OwnedAttribute 将其标记为从属实体：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Owned</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StreetAddress</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Street &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> City &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Order</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> StreetAddress ShippingAddress &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以使用 OnModelCreating 中的 OwnsOne 方法来指定 ShippingAddress 属性是 Order 实体类型的从属实体，并根据需要配置其他方面。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Order&gt;().OwnsOne(p =&gt; p.ShippingAddress);</span><br></pre></td></tr></table></figure>
<p>如果 ShippingAddress 属性在 Order 类型中是专用的，则可以使用 OwnsOne 方法的字符串版本：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Order&gt;().OwnsOne(<span class="keyword">typeof</span>(StreetAddress), <span class="string">&quot;ShippingAddress&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="隐式键"><a href="#隐式键" class="headerlink" title="隐式键"></a>隐式键</h2><p>使用 OwnsOne 配置的从属类型或通过引用导航发现的从属类型始终与所有者具有一对一的关系，因此它们不需要自己的键值，因为外键值是唯一的。 在上面的示例中，StreetAddress 类型不需要定义键属性。</p>
<p>为了了解 EF Core 如何跟踪这些对象，了解主键是作为从属类型的属性创建的很有用。 从属类型的实例的键值将与所有者实例的键值相同。</p>
<h1 id="无键实体类型"><a href="#无键实体类型" class="headerlink" title="无键实体类型"></a>无键实体类型</h1><p>除了常规实体类型外，EF Core 模型还可以包含无键实体类型，可用于对不包含键值的数据执行数据库查询。</p>
<h2 id="定义无键实体类型"><a href="#定义无键实体类型" class="headerlink" title="定义无键实体类型"></a>定义无键实体类型</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Keyless</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BlogPostsCount</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> BlogName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostCount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="无键实体类型特征"><a href="#无键实体类型特征" class="headerlink" title="无键实体类型特征"></a>无键实体类型特征</h2><p>无键实体类型支持与常规实体类型相同的多个映射功能，例如继承映射和导航属性。 在关系存储上，它们可以通过 Fluent API 方法或数据注释来配置目标数据库对象和列。</p>
<p>但是，它们不同于常规实体类型，因为它们：</p>
<ul>
<li>不能定义键。</li>
<li>永远不会对 DbContext 中的更改进行跟踪，因此不会对数据库进行插入、更新或删除这些操作。</li>
<li>绝不会被约定发现。</li>
<li>仅支持导航映射功能的子集，具体如下：<ul>
<li>它们永远不能充当关系的主体端。</li>
<li>它们可能没有指向从属实体的导航</li>
<li>它们只能包含指向常规实体的引用导航属性。</li>
<li>实体不能包含无键实体类型的导航属性。</li>
</ul>
</li>
<li>需要配置 [Keyless] 数据注释或 .HasNoKey() 方法调用。</li>
<li>可以映射到定义查询。 定义查询是在模型中声明的查询，它充当无键实体类型的数据源。</li>
<li>可以有层次结构，但必须映射为 TPH。</li>
<li>不能使用表拆分或实体拆分。</li>
</ul>
<h2 id="使用方案"><a href="#使用方案" class="headerlink" title="使用方案"></a>使用方案</h2><p>无键实体类型的一些主要使用场景包括：</p>
<ul>
<li>用作 SQL 查询的返回类型。</li>
<li>映射到不包含主键的数据库视图。</li>
<li>映射到未定义主键的表。</li>
<li>映射到模型中定义的查询。</li>
</ul>
<h1 id="模型批量配置"><a href="#模型批量配置" class="headerlink" title="模型批量配置"></a>模型批量配置</h1><h2 id="OnModelCreating-中的批量配置"><a href="#OnModelCreating-中的批量配置" class="headerlink" title="OnModelCreating 中的批量配置"></a>OnModelCreating 中的批量配置</h2><p>从 ModelBuilder 返回的每个生成器对象都会公开ModelMetadata 属性，该属性提供对构成模型对象的低级别访问。 具体而言，有一些方法允许循环访问模型中的特定对象，并对其应用通用配置。</p>
<p>在以下示例中， 模型包含自定义值类型 Currency：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">struct</span> Currency</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Currency</span>(<span class="params"><span class="built_in">decimal</span> amount</span>)</span></span><br><span class="line">        =&gt; Amount = amount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Amount &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">        =&gt; <span class="string">$&quot;$<span class="subst">&#123;Amount&#125;</span>&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下不会发现此类型的属性，因为当前 EF 提供程序不知道如何将它映射到数据库类型。 此代码片段 OnModelCreating 添加 类型 Currency 的所有属性，并将值转换器配置为受支持的类型 - decimal：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> entityType <span class="keyword">in</span> modelBuilder.Model.GetEntityTypes())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> propertyInfo <span class="keyword">in</span> entityType.ClrType.GetProperties())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (propertyInfo.PropertyType == <span class="keyword">typeof</span>(Currency))</span><br><span class="line">        &#123;</span><br><span class="line">            entityType.AddProperty(propertyInfo)</span><br><span class="line">                .SetValueConverter(<span class="keyword">typeof</span>(CurrencyConverter));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CurrencyConverter</span> : <span class="title">ValueConverter</span>&lt;<span class="title">Currency</span>, <span class="title">decimal</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CurrencyConverter</span>()</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">            v =&gt; v.Amount,</span></span></span><br><span class="line"><span class="params"><span class="function">            v =&gt; <span class="keyword">new</span> Currency(v</span>))</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="元数据-API-的缺点"><a href="#元数据-API-的缺点" class="headerlink" title="元数据 API 的缺点"></a>元数据 API 的缺点</h2><p>与 Fluent API 不同，对模型的每个修改都需要显式完成。 例如，如果某些 Currency 属性按约定配置为导航，则需要先删除引用 CLR 属性的导航，然后再为其添加实体类型属性。 #9117 将对此进行改进。<br>约定在每次更改后运行。 如果删除由约定发现的导航，该约定将再次运行，并可以重新添加它。 若要防止这种情况发生，需要延迟约定，直到通过调用 DelayConventions() 并稍后释放返回的对象添加属性后，或使用 将 CLR 属性标记为已忽略。AddIgnored<br>此迭代发生后，可能会添加实体类型，并且配置不会应用于这些实体类型。 通常可以通过将此代码放在 末尾 OnModelCreating来防止这种情况，但如果具有两组相互依赖的配置，则可能不会有一个允许一致应用它们的顺序。</p>
<h2 id="预约定配置"><a href="#预约定配置" class="headerlink" title="预约定配置"></a>预约定配置</h2><p>EF Core 允许为给定 CLR 类型指定一次映射配置;然后，该配置在发现时应用于模型中该类型的所有属性。 这称为“预约定模型配置”，因为它在允许运行模型生成约定之前配置模型的各个方面。 通过重写 ConfigureConventions 派生自 DbContext的类型来应用此类配置。</p>
<p>此示例演示如何将 类型 Currency 的所有属性配置为具有值转换器：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">ConfigureConventions</span>(<span class="params">ModelConfigurationBuilder configurationBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    configurationBuilder</span><br><span class="line">        .Properties&lt;Currency&gt;()</span><br><span class="line">        .HaveConversion&lt;CurrencyConverter&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 它将覆盖所有约定和数据注释。 例如，使用上述配置时，所有字符串外键属性都将创建为具有 1024 的非 unicode MaxLength ，即使这与主体键不匹配也是如此。</p>
</blockquote>
<h2 id="忽略类型"><a href="#忽略类型" class="headerlink" title="忽略类型"></a>忽略类型</h2><p>约定前配置还允许忽略类型，并阻止约定将其作为实体类型或实体类型的属性发现：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">configurationBuilder</span><br><span class="line">    .IgnoreAny(<span class="keyword">typeof</span>(IList&lt;&gt;));</span><br></pre></td></tr></table></figure>

<h2 id="默认类型映射"><a href="#默认类型映射" class="headerlink" title="默认类型映射"></a>默认类型映射</h2><p>通常，只要为此类型的属性指定了值转换器，EF 就可以使用提供程序不支持的类型常量转换查询。 但是，在不涉及此类型的任何属性的查询中，EF 无法找到正确的值转换器。 在这种情况下，可以调用 DefaultTypeMapping 以添加或替代提供程序类型映射：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configurationBuilder</span><br><span class="line">    .DefaultTypeMapping&lt;Currency&gt;()</span><br><span class="line">    .HasConversion&lt;CurrencyConverter&gt;();</span><br></pre></td></tr></table></figure>
<h2 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h2><p>EF Core 模型生成约定是包含逻辑的类，这些逻辑基于生成模型时对模型所做的更改触发。 这会在进行显式配置、应用映射属性和其他约定时使模型保持最新状态。 为了参与此目的，每个约定实现一个或多个接口，用于确定何时触发相应的方法。 例如，每当向模型添加新实体类型时，将触发实现 IEntityTypeAddedConvention 的约定。 同样，每当向模型添加键或外键时，都会触发实现 和 IKeyAddedConvention 的IForeignKeyAddedConvention约定。</p>
<p>模型生成约定是控制模型配置的一种强大方法，但可能很复杂，很难正确。</p>
<h3 id="添加新约定"><a href="#添加新约定" class="headerlink" title="添加新约定"></a>添加新约定</h3><h4 id="约束鉴别器属性的长度"><a href="#约束鉴别器属性的长度" class="headerlink" title="约束鉴别器属性的长度"></a>约束鉴别器属性的长度</h4><p>让我们通过首次尝试实现鉴别器长度约定，使这更具体一点：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DiscriminatorLengthConvention1</span> : <span class="title">IEntityTypeBaseTypeChangedConvention</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ProcessEntityTypeBaseTypeChanged</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        IConventionEntityTypeBuilder entityTypeBuilder,</span></span></span><br><span class="line"><span class="params"><span class="function">        IConventionEntityType? newBaseType,</span></span></span><br><span class="line"><span class="params"><span class="function">        IConventionEntityType? oldBaseType,</span></span></span><br><span class="line"><span class="params"><span class="function">        IConventionContext&lt;IConventionEntityType&gt; context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> discriminatorProperty = entityTypeBuilder.Metadata.FindDiscriminatorProperty();</span><br><span class="line">        <span class="keyword">if</span> (discriminatorProperty != <span class="literal">null</span></span><br><span class="line">            &amp;&amp; discriminatorProperty.ClrType == <span class="keyword">typeof</span>(<span class="built_in">string</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            discriminatorProperty.Builder.HasMaxLength(<span class="number">24</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此约定实现 IEntityTypeBaseTypeChangedConvention，这意味着每当实体类型的映射继承层次结构发生更改时，都会触发它。 然后，该约定查找并配置层次结构的字符串鉴别器属性。</p>
<p>然后，通过在 中ConfigureConventions调用 Add 来使用此约定：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">ConfigureConventions</span>(<span class="params">ModelConfigurationBuilder configurationBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    configurationBuilder.Conventions.Add(_ =&gt;  <span class="keyword">new</span> DiscriminatorLengthConvention1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，如果我们现在显式配置不同的鉴别器属性，会发生什么情况呢？ 例如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Post&gt;()</span><br><span class="line">    .HasDiscriminator&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;PostTypeDiscriminator&quot;</span>)</span><br><span class="line">    .HasValue&lt;Post&gt;(<span class="string">&quot;Post&quot;</span>)</span><br><span class="line">    .HasValue&lt;FeaturedPost&gt;(<span class="string">&quot;Featured&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这是因为我们在约定中配置的鉴别器属性后来在添加自定义鉴别器时被删除。 我们可以尝试通过在约定上实现另一个接口来修复此问题，以响应鉴别器更改，但找出要实现的接口并不容易。</p>
<p>幸运的是，有一种更简单的方法。 很多时候，只要最终模型正确，模型在生成时的外观并不重要。 此外，要应用的配置通常不需要触发其他约定来做出反应。 因此，我们的约定可以实现 IModelFinalizingConvention。 模型最终确定约定 在所有其他模型生成完成后运行，因此可以访问模型的接近最终状态。 这与响应每个模型更改并确保模型在方法执行的任何时间点处于最新状态的OnModelCreating交互式约定相反。 模型最终确定约定通常会循环访问整个模型，以根据需要配置模型元素。 因此，在这种情况下，我们会在模型中找到每个鉴别器并对其进行配置：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DiscriminatorLengthConvention2</span> : <span class="title">IModelFinalizingConvention</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ProcessModelFinalizing</span>(<span class="params">IConventionModelBuilder modelBuilder, IConventionContext&lt;IConventionModelBuilder&gt; context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> entityType <span class="keyword">in</span> modelBuilder.Metadata.GetEntityTypes()</span><br><span class="line">                     .Where(entityType =&gt; entityType.BaseType == <span class="literal">null</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> discriminatorProperty = entityType.FindDiscriminatorProperty();</span><br><span class="line">            <span class="keyword">if</span> (discriminatorProperty != <span class="literal">null</span></span><br><span class="line">                &amp;&amp; discriminatorProperty.ClrType == <span class="keyword">typeof</span>(<span class="built_in">string</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                discriminatorProperty.Builder.HasMaxLength(<span class="number">24</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用此新约定生成模型后，我们发现现在已正确配置了鉴别器长度，即使已对其进行自定义：</p>
<p>我们可以更进一步，将最大长度配置为最长的鉴别器值的长度：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DiscriminatorLengthConvention3</span> : <span class="title">IModelFinalizingConvention</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ProcessModelFinalizing</span>(<span class="params">IConventionModelBuilder modelBuilder, IConventionContext&lt;IConventionModelBuilder&gt; context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> entityType <span class="keyword">in</span> modelBuilder.Metadata.GetEntityTypes()</span><br><span class="line">                     .Where(entityType =&gt; entityType.BaseType == <span class="literal">null</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> discriminatorProperty = entityType.FindDiscriminatorProperty();</span><br><span class="line">            <span class="keyword">if</span> (discriminatorProperty != <span class="literal">null</span></span><br><span class="line">                &amp;&amp; discriminatorProperty.ClrType == <span class="keyword">typeof</span>(<span class="built_in">string</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> maxDiscriminatorValueLength =</span><br><span class="line">                    entityType.GetDerivedTypesInclusive().Select(e =&gt; ((<span class="built_in">string</span>)e.GetDiscriminatorValue()!).Length).Max();</span><br><span class="line"></span><br><span class="line">                discriminatorProperty.Builder.HasMaxLength(maxDiscriminatorValueLength);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，鉴别器列的最大长度为 8，即“特别推荐”的长度，这是使用的最长的鉴别器值。</p>
<h2 id="替换现有约定"><a href="#替换现有约定" class="headerlink" title="替换现有约定"></a>替换现有约定</h2><p>有时，与其完全删除现有约定，不如将其替换为执行基本相同操作但行为已更改的约定。 这很有用，因为现有约定已实现需要适当触发的接口。</p>
<h2 id="何时将每种方法用于批量配置"><a href="#何时将每种方法用于批量配置" class="headerlink" title="何时将每种方法用于批量配置"></a>何时将每种方法用于批量配置</h2><p>在以下情况下使用 元数据 API ：</p>
<ul>
<li>需要在特定时间应用配置，而不是对模型中的后续更改做出反应。</li>
<li>模型生成速度非常重要。 元数据 API 的安全检查较少，因此可能比其他方法稍快一些，但使用 已编译的模型 将产生更好的启动时间。</li>
</ul>
<p>在以下情况下使用 约定前模型配置 ：</p>
<ul>
<li>适用性条件很简单，因为它仅取决于类型。</li>
<li>需要在模型中添加给定类型的属性并重写数据注释和约定时应用配置</li>
</ul>
<p>在以下情况下使用 Finalizing 约定 ：</p>
<ul>
<li>适用性条件很复杂。</li>
<li>配置不应替代数据批注指定的内容。</li>
</ul>
<p>在以下情况下使用 交互式约定 ：</p>
<ul>
<li>多个约定相互依赖。 完成约定按添加顺序运行，因此无法对以后完成约定所做的更改做出反应。</li>
<li>逻辑在多个上下文之间共享。 交互式约定比其他方法更安全。</li>
</ul>
<h1 id="IModelCacheKeyFactory"><a href="#IModelCacheKeyFactory" class="headerlink" title="IModelCacheKeyFactory"></a>IModelCacheKeyFactory</h1><p>EF 使用 IModelCacheKeyFactory 为模型生成缓存键；默认情况下，EF 假定对于任何给定的上下文类型，模型都相同，因此该服务的默认实现将返回仅包含上下文类型的键。 若要从同一上下文类型构建不同的模型，需要将服务替换为正确的实现；生成的键将使用 IModelCacheKeyFactoryEquals 方法与其他的模型键进行比较，同时考虑影响模型的所有变量。</p>
<p>以下实现在生成模型缓存键时考虑 UseIntProperty：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DynamicModelCacheKeyFactory</span> : <span class="title">IModelCacheKeyFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Create</span>(<span class="params">DbContext context, <span class="built_in">bool</span> designTime</span>)</span></span><br><span class="line">        =&gt; context <span class="keyword">is</span> DynamicContext dynamicContext</span><br><span class="line">            ? (context.GetType(), dynamicContext.UseIntProperty, designTime)</span><br><span class="line">            : (<span class="built_in">object</span>)context.GetType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还必须实现 Create 方法的重载，该方法也处理设计时模型缓存。 如以下示例所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DynamicModelCacheKeyFactoryDesignTimeSupport</span> : <span class="title">IModelCacheKeyFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Create</span>(<span class="params">DbContext context, <span class="built_in">bool</span> designTime</span>)</span></span><br><span class="line">        =&gt; context <span class="keyword">is</span> DynamicContext dynamicContext</span><br><span class="line">            ? (context.GetType(), dynamicContext.UseIntProperty, designTime)</span><br><span class="line">            : (<span class="built_in">object</span>)context.GetType();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Create</span>(<span class="params">DbContext context</span>)</span></span><br><span class="line">        =&gt; Create(context, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，在上下文的 OnConfiguring 中注册新的 IModelCacheKeyFactory：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span></span><br><span class="line">    =&gt; optionsBuilder</span><br><span class="line">        .UseInMemoryDatabase(<span class="string">&quot;DynamicContext&quot;</span>)</span><br><span class="line">        .ReplaceService&lt;IModelCacheKeyFactory, DynamicModelCacheKeyFactory&gt;();</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2022/11/18/EFCore/%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9E%8B(%E4%B8%80)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/18/EFCore/%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9E%8B(%E4%B8%80)/" class="post-title-link" itemprop="url">创建模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-11-18 17:19:56" itemprop="dateCreated datePublished" datetime="2022-11-18T17:19:56+08:00">2022-11-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-13 14:50:54" itemprop="dateModified" datetime="2023-03-13T14:50:54+08:00">2023-03-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="创建并配置模型"><a href="#创建并配置模型" class="headerlink" title="创建并配置模型"></a>创建并配置模型</h1><p>Entity Framework Core 使用一组约定来根据实体类的形状生成模型。 可指定其他配置以补充和&#x2F;或替代约定的内容。</p>
<h2 id="使用-fluent-API-配置模型"><a href="#使用-fluent-API-配置模型" class="headerlink" title="使用 fluent API 配置模型"></a>使用 fluent API 配置模型</h2><p>Fluent API 配置具有最高优先级，并将替代约定和数据注释。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Blog</span>&gt; Blogs</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> Required</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">            .Property(b =&gt; b.Url)</span><br><span class="line">            .IsRequired();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分组配置"><a href="#分组配置" class="headerlink" title="分组配置"></a>分组配置</h2><p>为了减小 <code>OnModelCreating</code> 方法的大小，可以将实体类型的所有配置提取到实现 <code>IEntityTypeConfiguration&lt;TEntity&gt;</code> 的单独类中。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BlogEntityTypeConfiguration</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Blog</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Blog&gt; builder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        builder</span><br><span class="line">            .Property(b =&gt; b.Url)</span><br><span class="line">            .IsRequired();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，只需从 OnModelCreating 调用 Configure 方法。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> BlogEntityTypeConfiguration().Configure(modelBuilder.Entity&lt;Blog&gt;());</span><br></pre></td></tr></table></figure>
<p>可以在给定程序集中应用实现 <code>IEntityTypeConfiguration</code>的类型中指定的所有配置。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.ApplyConfigurationsFromAssembly(<span class="keyword">typeof</span>(BlogEntityTypeConfiguration).Assembly);</span><br></pre></td></tr></table></figure>
<h2 id="使用数据注释来配置模型"><a href="#使用数据注释来配置模型" class="headerlink" title="使用数据注释来配置模型"></a>使用数据注释来配置模型</h2><p>也可将特性（称为数据注释）应用于类和属性。 数据注释会替代约定，但会被 Fluent API 配置替代。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Blog&gt; Blogs &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Table(<span class="string">&quot;Blogs&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Required</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="实体类型"><a href="#实体类型" class="headerlink" title="实体类型"></a>实体类型</h1><p>在上下文中包含一种类型的 DbSet 意味着它包含在 EF Core 的模型中；我们通常将此类类型称为实体。</p>
<h2 id="在模型中包含类型"><a href="#在模型中包含类型" class="headerlink" title="在模型中包含类型"></a>在模型中包含类型</h2><p>按照约定，上下文的<code>DbSet</code>属性中公开的类型作为实体包含在模型中。 还包括在 <code>OnModelCreating</code>方法中指定的实体类型，以及通过递归探索其他发现的实体类型的导航属性找到的任何类型。</p>
<p>*** 下面的代码示例中包含了所有类型：***</p>
<p>包含<code>Blog</code>，因为它在上下文的<code>DbSet</code>属性中公开。<br>包含<code>Post</code>，因为它是通过<code>Blog.Posts</code> 导航属性发现的。<br>包含<code>AuditEntry</code>因为它是 <code>OnModelCreating</code>中指定的。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Blog</span>&gt; Blogs</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;AuditEntry&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Post&gt; Posts &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Blog Blog &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AuditEntry</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> AuditEntryId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Username &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Action &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="从模型中排除类型"><a href="#从模型中排除类型" class="headerlink" title="从模型中排除类型"></a>从模型中排除类型</h2><p>如果不希望在模型中包含某一类型，则可以排除它：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Ignore&lt;BlogMetadata&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从迁移中排除"><a href="#从迁移中排除" class="headerlink" title="从迁移中排除"></a>从迁移中排除</h3><p>有时，将相同的实体类型映射到多个<code>DbContext</code>类型中非常有用。 在使用绑定上下文时尤其如此，对于每段绑定上下文，使用不同<code>DbContext</code>类型的情况很常见</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;IdentityUser&gt;()</span><br><span class="line">        .ToTable(<span class="string">&quot;AspNetUsers&quot;</span>, t =&gt; t.ExcludeFromMigrations());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此配置迁移不会创建<code>AspNetUsers</code>该表，但<code>IdentityUser</code> 仍包含在模型中，并且可正常使用。</p>
<p>如果需要再次使用迁移来管理表，则应创建不包括 <code>AspNetUsers</code>的新迁移。 下一次迁移将包含对表所做的任何更改。</p>
<h2 id="表名称"><a href="#表名称" class="headerlink" title="表名称"></a>表名称</h2><p>每个实体类型都将设置为映射到与公开实体的 DbSet 属性名称相同的数据库表。 如果给定实体不存在 DbSet，则使用类名称,可以手动配置表名</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .ToTable(<span class="string">&quot;blogs&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="表架构"><a href="#表架构" class="headerlink" title="表架构"></a>表架构</h2><p>使用关系数据库时，表按约定在数据库的默认架构中创建,你可以配置要在特定架构中创建的表，如下所示</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .ToTable(<span class="string">&quot;blogs&quot;</span>, schema: <span class="string">&quot;blogging&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以在模型级别使用 Fluent API 定义默认架构，而不是为每个表指定架构：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.HasDefaultSchema(<span class="string">&quot;blogging&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置默认架构也会影响其他数据库对象，例如序列。</p>
<h2 id="视图映射"><a href="#视图映射" class="headerlink" title="视图映射"></a>视图映射</h2><p>可以使用 Fluent API 将实体类型映射到数据库视图，EF 假定数据库中已存在引用的视图，它不会在迁移中自动创建它。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">    .ToView(<span class="string">&quot;blogsView&quot;</span>, schema: <span class="string">&quot;blogging&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>映射到视图将删除默认表映射，但从 EF 5.0 开始，实体类型也可以显式映射到表。 在这种情况下，查询映射将用于查询，表映射将用于更新。</p>
<h2 id="表值函数映射"><a href="#表值函数映射" class="headerlink" title="表值函数映射"></a>表值函数映射</h2><p>若要将实体映射到表值函数，函数必须是无参数的</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BlogWithMultiplePosts</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostCount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CREATE FUNCTION dbo.BlogsWithMultiplePosts()</span><br><span class="line"><span class="function">RETURNS TABLE</span></span><br><span class="line"><span class="function">AS</span></span><br><span class="line"><span class="function"><span class="title">RETURN</span></span></span><br><span class="line"><span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    SELECT b.Url, COUNT(p.BlogId</span>) AS PostCount</span></span><br><span class="line"><span class="function">    FROM Blogs AS b</span></span><br><span class="line"><span class="function">    JOIN Posts AS p ON b.BlogId</span> = p.BlogId</span><br><span class="line">    GROUP BY b.BlogId, b.<span class="function">Url</span></span><br><span class="line"><span class="function">    HAVING <span class="title">COUNT</span>(<span class="params">p.BlogId</span>) &gt; 1</span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">modelBuilder.<span class="title">Entity</span>&lt;<span class="title">BlogWithMultiplePosts</span>&gt;().<span class="title">HasNoKey</span>().<span class="title">ToFunction</span>(<span class="params"><span class="string">&quot;BlogsWithMultiplePosts&quot;</span></span>)</span>;</span><br></pre></td></tr></table></figure>
<p>通常情况下，实体属性将映射到 TVF 返回的匹配列。 如果 TVF 返回的列名称与实体属性的名称不同，则可以使用 HasColumnName 方法配置实体的列，就像映射到常规表一样。</p>
<h2 id="表注释"><a href="#表注释" class="headerlink" title="表注释"></a>表注释</h2><p>可以对数据库表设置任意文本注释，从而在数据库中记录架构</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;().ToTable(</span><br><span class="line">        tableBuilder =&gt; tableBuilder.HasComment(<span class="string">&quot;Blogs managed on the website&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="共享类型实体类型"><a href="#共享类型实体类型" class="headerlink" title="共享类型实体类型"></a>共享类型实体类型</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;&gt; Blogs =&gt; Set&lt;Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;&gt;(<span class="string">&quot;Blog&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.SharedTypeEntity&lt;Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;&gt;(</span><br><span class="line">            <span class="string">&quot;Blog&quot;</span>, bb =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                bb.Property&lt;<span class="built_in">int</span>&gt;(<span class="string">&quot;BlogId&quot;</span>);</span><br><span class="line">                bb.Property&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Url&quot;</span>);</span><br><span class="line">                bb.Property&lt;DateTime&gt;(<span class="string">&quot;LastUpdated&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实体属性"><a href="#实体属性" class="headerlink" title="实体属性"></a>实体属性</h1><p>模型中的每个实体类型都有一组属性，EF Core 将从数据库中读取和写入这些属性。 如果使用的是关系数据库，实体属性将映射到表列。</p>
<h2 id="已包含和已排除的属性"><a href="#已包含和已排除的属性" class="headerlink" title="已包含和已排除的属性"></a>已包含和已排除的属性</h2><p>按照约定，所有具有 Getter 和 Setter 的公共属性都将包含在模型中。</p>
<p>可以按如下所示排除特定属性：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Ignore(b =&gt; b.LoadedFromDatabase);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="列名"><a href="#列名" class="headerlink" title="列名"></a>列名</h2><p>按照约定，使用关系数据库时，实体属性将映射到与属性同名的表列。</p>
<p>如果希望配置具有不同名称的列，可以按以下代码片段进行操作：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(b =&gt; b.BlogId)</span><br><span class="line">        .HasColumnName(<span class="string">&quot;blog_id&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="列数据类型"><a href="#列数据类型" class="headerlink" title="列数据类型"></a>列数据类型</h2><p>还可以配置列以指定列的确切数据类型</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;(</span><br><span class="line">        eb =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            eb.Property(b =&gt; b.Url).HasColumnType(<span class="string">&quot;varchar(200)&quot;</span>);</span><br><span class="line">            eb.Property(b =&gt; b.Rating).HasColumnType(<span class="string">&quot;decimal(5, 2)&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最大长度"><a href="#最大长度" class="headerlink" title="最大长度"></a>最大长度</h2><p>在向提供程序传递数据之前，实体框架不会执行任何最大长度的验证。 而是由提供程序或数据存储根据情况进行验证。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(b =&gt; b.Url)</span><br><span class="line">        .HasMaxLength(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="精度和小数位数"><a href="#精度和小数位数" class="headerlink" title="精度和小数位数"></a>精度和小数位数</h2><p>哪些数据类型支持精度和小数位数取决于数据库，但在大多数数据库中，decimal 和 DateTime 类型支持这些 Facet</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(b =&gt; b.Score)</span><br><span class="line">        .HasPrecision(<span class="number">14</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(b =&gt; b.LastUpdated)</span><br><span class="line">        .HasPrecision(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不先定义精度，则永远不会定义小数位数，因此用于定义小数位数的 Fluent API 为 HasPrecision(precision, scale)。</p>
<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>在某些关系数据库中，存在不同的类型来表示 Unicode 和非 Unicode 文本数据。 例如，在 SQL Server 中，nvarchar(x)用于表示 UTF-16 中的 Unicode 数据，而varchar(x)用于表示非 Unicode 数据<br>默认情况下，文本属性配置为 Unicode。 可以将列配置为非 Unicode，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Book&gt;()</span><br><span class="line">        .Property(b =&gt; b.Isbn)</span><br><span class="line">        .IsUnicode(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="必需和可选属性"><a href="#必需和可选属性" class="headerlink" title="必需和可选属性"></a>必需和可选属性</h2><p>如果属性包含<code>null</code>是有效的，则该属性被视为可选属性。 如果<code>null</code>不是要分配给属性的有效值，则它被视为必需属性。 映射到关系数据库架构时，必需属性创建为不可为<code>null</code>的列，可选属性创建为可为<code>null</code>的列。</p>
<h3 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h3><p>按照约定，其<code>.NET</code>类型可包含<code>null</code>的属性将配置为可选属性，而<code>.NET</code>类型不能包含<code>null</code>的属性将配置为必需属性。 例如，所有具有<code>.NET</code>值类型<code>(intdecimal、bool等)</code>的属性都配置为必需，并且具有可为<code>null</code>的 <code>.NET</code>值类型的所有属性<code>(int?decimal?、bool?等)</code>配置为可选。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Customer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> FirstName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// Required by convention</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> LastName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// Required by convention</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>? MiddleName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// Optional by convention</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note the following use of constructor binding, which avoids compiled warnings</span></span><br><span class="line">    <span class="comment">// for uninitialized non-nullable properties.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span>(<span class="params"><span class="built_in">string</span> firstName, <span class="built_in">string</span> lastName, <span class="built_in">string</span>? middleName = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        FirstName = firstName;</span><br><span class="line">        LastName = lastName;</span><br><span class="line">        MiddleName = middleName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="显式配置"><a href="#显式配置" class="headerlink" title="显式配置"></a>显式配置</h3><p>按约定为可选属性的属性可以配置为必需属性，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(b =&gt; b.Url)</span><br><span class="line">        .IsRequired();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="列排序规则"><a href="#列排序规则" class="headerlink" title="列排序规则"></a>列排序规则</h2><p>可以定义文本列的排序规则，以确定如何比较和排序</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Customer&gt;().Property(c =&gt; c.Name)</span><br><span class="line">    .UseCollation(<span class="string">&quot;SQL_Latin1_General_CP1_CI_AS&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>如果数据库中的所有列都需要使用特定的排序规则，请改为在数据库级别定义排序规则。</p>
<h2 id="列注释"><a href="#列注释" class="headerlink" title="列注释"></a>列注释</h2><p>可以对数据库列设置任意文本注释，从而在数据库中记录架构：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(b =&gt; b.Url)</span><br><span class="line">        .HasComment(<span class="string">&quot;The URL of the blog&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="列顺序"><a href="#列顺序" class="headerlink" title="列顺序"></a>列顺序</h2><p>默认情况下，在使用迁移创建表时，EF Core 首先为主键列排序，然后为实体类型和从属类型的属性排序，最后为基类型中的属性排序。 但是，你可以指定不同的列顺序：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Employee&gt;(x =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        x.Property(b =&gt; b.Id)</span><br><span class="line">            .HasColumnOrder(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        x.Property(b =&gt; b.FirstName)</span><br><span class="line">            .HasColumnOrder(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        x.Property(b =&gt; b.LastName)</span><br><span class="line">            .HasColumnOrder(<span class="number">2</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，在一般情况下，大多数数据库仅支持在创建表时对列进行排序。 这意味着不能使用列顺序特性对现有表中的列进行重新排序</p>
<h1 id="键"><a href="#键" class="headerlink" title="键"></a>键</h1><p>键用作每个实体实例的唯一标识符</p>
<h2 id="配置主键"><a href="#配置主键" class="headerlink" title="配置主键"></a>配置主键</h2><p>根据约定，名为 Id 或 <type name>Id 的属性将被配置为实体的主键</type></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Make &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Model &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Truck</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> TruckId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Make &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Model &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可将单个属性配置为实体的主键，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Car&gt;()</span><br><span class="line">        .HasKey(c =&gt; c.LicensePlate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可将多个属性配置为实体的键 - 这称为组合键。 约定仅在特定情况下设置组合键 - 例如，对于拥有的类型集合。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Car&gt;()</span><br><span class="line">        .HasKey(c =&gt; <span class="keyword">new</span> &#123; c.State, c.LicensePlate &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创造价值"><a href="#创造价值" class="headerlink" title="创造价值"></a>创造价值</h3><p>对于非复合数字和<code>GUID</code>主键，<code>EF Core</code>根据约定设置值生成</p>
<h3 id="主键名称"><a href="#主键名称" class="headerlink" title="主键名称"></a>主键名称</h3><p>根据约定，在关系数据库上，主键使用名称<code>PK_&lt;type name&gt;</code> 进行创建。 可按如下方式配置主键约束的名称：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .HasKey(b =&gt; b.BlogId)</span><br><span class="line">        .HasName(<span class="string">&quot;PrimaryKey_BlogId&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="键类型和值"><a href="#键类型和值" class="headerlink" title="键类型和值"></a>键类型和值</h3><p>向上下文添加新实体时，键属性必须始终具有非默认值，但某些类型将由数据库生成。 在这种情况下，当添加实体以用于跟踪时，EF 将尝试生成一个临时值。 调用 SaveChanges 后，临时值将替换为数据库生成的值。</p>
<p>如果键属性的值由数据库生成，并且在添加实体时指定了非默认值，则 EF 将假定该实体已存在于数据库中，并尝试更新它，而不是插入新的实体。</p>
<h3 id="备用键"><a href="#备用键" class="headerlink" title="备用键"></a>备用键</h3><p>除主键外，备选键还充当每个实体实例的备用唯一标识符；它可以用作关系的目标<br>如果只想对列强制执行唯一性，请定义唯一索引而不是备选键</p>
<p>备选建通常根据需要引入，无需手动配置。 根据约定，当你将不是主键的属性标识为关系的目标时，会引入备选键。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Blog</span>&gt; Blogs</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Post</span>&gt; Posts</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;Post&gt;()</span><br><span class="line">            .HasOne(p =&gt; p.Blog)</span><br><span class="line">            .WithMany(b =&gt; b.Posts)</span><br><span class="line">            .HasForeignKey(p =&gt; p.BlogUrl)</span><br><span class="line">            .HasPrincipalKey(b =&gt; b.Url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Post&gt; Posts &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> BlogUrl &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Blog Blog &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可将单个属性配置为备选键：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Car&gt;()</span><br><span class="line">        .HasAlternateKey(c =&gt; c.LicensePlate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可将多个属性配置为备选键（即复合备选键）：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Car&gt;()</span><br><span class="line">        .HasAlternateKey(c =&gt; <span class="keyword">new</span> &#123; c.State, c.LicensePlate &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可配置备选键的索引和唯一约束的名称：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Car&gt;()</span><br><span class="line">        .HasAlternateKey(c =&gt; c.LicensePlate)</span><br><span class="line">        .HasName(<span class="string">&quot;AlternateKey_LicensePlate&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="生成的值"><a href="#生成的值" class="headerlink" title="生成的值"></a>生成的值</h1><p>数据库列的值可以通过多种方式生成：主键列通常是自动递增的整数，其他列具有默认值或计算值等。</p>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>在关系数据库中，可以为列配置默认值；如果插入的行没有该列的值，则将使用默认值。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(b =&gt; b.Rating)</span><br><span class="line">        .HasDefaultValue(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以指定用于计算默认值的 SQL 片段：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(b =&gt; b.Created)</span><br><span class="line">        .HasDefaultValueSql(<span class="string">&quot;getdate()&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计算列"><a href="#计算列" class="headerlink" title="计算列"></a>计算列</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Person&gt;()</span><br><span class="line">    .Property(p =&gt; p.DisplayName)</span><br><span class="line">    .HasComputedColumnSql(<span class="string">&quot;[LastName] + &#x27;, &#x27; + [FirstName]&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>以上命令将创建一个虚拟计算列，每次从数据库中提取时都会计算其值。 你也可以将计算列指定为存储（有时称为持久化）计算列，这意味着系统会在每次更新行时计算该列，并将其与常规列一起存储在磁盘上：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Person&gt;()</span><br><span class="line">    .Property(p =&gt; p.NameLength)</span><br><span class="line">    .HasComputedColumnSql(<span class="string">&quot;LEN([LastName]) + LEN([FirstName])&quot;</span>, stored: <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><h3 id="显式配置值生成"><a href="#显式配置值生成" class="headerlink" title="显式配置值生成"></a>显式配置值生成</h3><p>EF Core 会自动为主键设置值生成 - 但我们可能希望对非键属性执行相同的操作。 你可以将任何属性配置为针对插入的实体生成其值，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(b =&gt; b.Inserted)</span><br><span class="line">        .ValueGeneratedOnAdd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，可以将属性配置为在添加或更新时生成其值：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(b =&gt; b.LastUpdated)</span><br><span class="line">        .ValueGeneratedOnAddOrUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>与默认值或计算列不同，我们没有指定值的生成方式；这取决于所使用的数据库提供程序。 数据库提供程序可能会自动为某些属性类型设置值生成，但其他属性类型可能需要你手动设置值的生成方式。</strong></p>
<h2 id="日期-x2F-时间值生成"><a href="#日期-x2F-时间值生成" class="headerlink" title="日期&#x2F;时间值生成"></a>日期&#x2F;时间值生成</h2><p>EF Core 提供程序通常不会为日期&#x2F;时间列自动设置值生成 - 你必须自行配置。</p>
<h3 id="创建时间戳"><a href="#创建时间戳" class="headerlink" title="创建时间戳"></a>创建时间戳</h3><p>若要将日期&#x2F;时间列配置为包含行的创建时间戳，通常需要使用适当的 SQL 函数来配置默认值。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(b =&gt; b.Created)</span><br><span class="line">        .HasDefaultValueSql(<span class="string">&quot;getdate()&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更新时间戳"><a href="#更新时间戳" class="headerlink" title="更新时间戳"></a>更新时间戳</h3><p>尽管存储计算列看起来非常适合管理上次更新时间戳，但数据库通常不允许在计算列中指定诸如 GETDATE() 之类的函数。 作为替代方法，你可以设置一个数据库触发器来达到同样的效果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> [dbo].[Blogs_UPDATE] <span class="keyword">ON</span> [dbo].[Blogs]</span><br><span class="line">    AFTER <span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SET</span> NOCOUNT <span class="keyword">ON</span>;</span><br><span class="line"></span><br><span class="line">    IF ((<span class="keyword">SELECT</span> TRIGGER_NESTLEVEL()) <span class="operator">&gt;</span> <span class="number">1</span>) <span class="keyword">RETURN</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">DECLARE</span> <span class="variable">@Id</span> <span class="type">INT</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="variable">@Id</span> <span class="operator">=</span> INSERTED.BlogId</span><br><span class="line">    <span class="keyword">FROM</span> INSERTED</span><br><span class="line"></span><br><span class="line">    <span class="keyword">UPDATE</span> dbo.Blogs</span><br><span class="line">    <span class="keyword">SET</span> LastUpdated <span class="operator">=</span> GETDATE()</span><br><span class="line">    <span class="keyword">WHERE</span> BlogId <span class="operator">=</span> <span class="variable">@Id</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<h2 id="替代值生成"><a href="#替代值生成" class="headerlink" title="替代值生成"></a>替代值生成</h2><p>尽管为属性配置了值生成，但在许多情况下，你仍然可以为其显式指定一个值。 此操作能否真正起作用取决于已配置的特定值生成机制；虽然你可以指定显式值而不是使用列的默认值，但不能对计算列执行相同的操作。</p>
<p>若要使用显式值替代值生成，只需将属性设置为该属性类型的 CLR 默认值（string 为 null，int 为 0，Guid 为 Guid.Empty，等等）以外的任意值。</p>
<p>若要为已配置为在添加或更新时生成值的属性提供显式值，还必须按以下方式配置该属性：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;().Property(b =&gt; b.LastUpdated)</span><br><span class="line">        .ValueGeneratedOnAddOrUpdate()</span><br><span class="line">        .Metadata.SetAfterSaveBehavior(PropertySaveBehavior.Save);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="无值生成"><a href="#无值生成" class="headerlink" title="无值生成"></a>无值生成</h2><p>除了上述特定方案外，属性通常不会配置值生成；这意味着，始终由应用程序提供要保存到数据库的值。 必须先将此值分配给新实体，然后才能将新实体添加到上下文中。</p>
<p>但是，在某些情况下，你可能希望禁用按约定设置的值生成。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(b =&gt; b.BlogId)</span><br><span class="line">        .ValueGeneratedNever();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="阴影和索引器属性"><a href="#阴影和索引器属性" class="headerlink" title="阴影和索引器属性"></a>阴影和索引器属性</h1><p>阴影属性不是在 .NET 实体类中定义的，但在 EF Core 模型中是为该实体类型定义的。 这些属性的值和状态纯粹保留在更改跟踪器中。 当数据库中存在不应在映射的实体类型上公开的数据时，阴影属性非常有用。</p>
<p>索引器属性是实体类型属性，由 .NET 实体类中的 索引器器提供支持。 可以使用 .NET 类实例上的索引器访问它们。 它还允许向实体类型添加其他属性，而无需更改 CLR 类。</p>
<h2 id="外键阴影属性"><a href="#外键阴影属性" class="headerlink" title="外键阴影属性"></a>外键阴影属性</h2><p>阴影属性通常用于外键属性，其中两个实体之间的关系由数据库中的外键值表示，但这种关系是通过实体类型之间的导航属性来管理的。 根据约定，当发现关系，但在依赖实体类中找不到外键属性时，EF 将引入阴影属性。</p>
<p>例如，以下代码列表将导致 BlogId 阴影属性引入 Post 实体：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Blog&gt; Blogs &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Post&gt; Posts &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Post&gt; Posts &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Since there is no CLR property which holds the foreign</span></span><br><span class="line">    <span class="comment">// key for this relationship, a shadow property is created.</span></span><br><span class="line">    <span class="keyword">public</span> Blog Blog &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置阴影属性"><a href="#配置阴影属性" class="headerlink" title="配置阴影属性"></a>配置阴影属性</h2><p>可以使用 Fluent API 来配置阴影属性。 调用 Property 的字符串重载后，可以链接针对其他属性的任何配置调用。 在下面的示例中，由于 Blog 没有名为 LastUpdated 的 CLR 属性，因此将创建阴影属性：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Blog</span>&gt; Blogs</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">            .Property&lt;DateTime&gt;(<span class="string">&quot;LastUpdated&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="访问阴影属性"><a href="#访问阴影属性" class="headerlink" title="访问阴影属性"></a>访问阴影属性</h2><p>可以通过 ChangeTracker API 获取和更改阴影属性值：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.Entry(myBlog).Property(<span class="string">&quot;LastUpdated&quot;</span>).CurrentValue = DateTime.Now;</span><br></pre></td></tr></table></figure>
<p>可以通过 EF.Property 静态方法在 LINQ 查询中引用阴影属性：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blogs = context.Blogs</span><br><span class="line">    .OrderBy(b =&gt; EF.Property&lt;DateTime&gt;(b, <span class="string">&quot;LastUpdated&quot;</span>));</span><br></pre></td></tr></table></figure>
<h2 id="配置索引器属性"><a href="#配置索引器属性" class="headerlink" title="配置索引器属性"></a>配置索引器属性</h2><p>在下面的示例中，Blog 定义了一个索引器，该索引器将用于创建索引器属性。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Blog</span>&gt; Blogs</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;Blog&gt;().IndexerProperty&lt;DateTime&gt;(<span class="string">&quot;LastUpdated&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt; _data = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> <span class="keyword">this</span>[<span class="built_in">string</span> key]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; _data[key];</span><br><span class="line">        <span class="keyword">set</span> =&gt; _data[key] = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性包实体类型"><a href="#属性包实体类型" class="headerlink" title="属性包实体类型"></a>属性包实体类型</h2><p>仅包含索引器属性的实体类型称为属性包实体类型。 这些实体类型没有阴影属性，EF 会改为创建索引器属性。 目前仅支持将 Dictionary&lt;string, object&gt; 作为属性包实体类型。 必须配置为具有唯一名称的共享类型实体 类型，并且必须使用 Set 调用实现相应的 DbSet 属性。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;&gt; Blogs =&gt; Set&lt;Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;&gt;(<span class="string">&quot;Blog&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.SharedTypeEntity&lt;Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;&gt;(</span><br><span class="line">            <span class="string">&quot;Blog&quot;</span>, bb =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                bb.Property&lt;<span class="built_in">int</span>&gt;(<span class="string">&quot;BlogId&quot;</span>);</span><br><span class="line">                bb.Property&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Url&quot;</span>);</span><br><span class="line">                bb.Property&lt;DateTime&gt;(<span class="string">&quot;LastUpdated&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h1><p>关系定义两个实体之间的相关性。 在关系数据库中，关系由外键约束表示。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Post&gt; Posts &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Blog Blog &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Post</code> 是依赖实体</p>
<p><code>Blog</code> 是主体实体</p>
<p><code>Blog.BlogId</code> 是主体键（在此示例中，它是主键，而不是备选键）</p>
<p><code>Post.BlogId</code> 是外键</p>
<p><code>Post.Blog</code> 是引用导航属性</p>
<p><code>Blog.Posts</code> 是集合导航属性</p>
<p><code>Post.Blog</code> 是 <code>Blog.Posts</code> 的反向导航属性（反之亦然）</p>
<h2 id="约定-1"><a href="#约定-1" class="headerlink" title="约定"></a>约定</h2><p>按约定发现的关系将始终以主体实体的主键为目标。 若要以备选键为目标，必须使用 Fluent API 执行配置。</p>
<h3 id="完全定义的关系"><a href="#完全定义的关系" class="headerlink" title="完全定义的关系"></a>完全定义的关系</h3><h3 id="无外键属性"><a href="#无外键属性" class="headerlink" title="无外键属性"></a>无外键属性</h3><p>虽然建议在依赖实体类中定义外键属性，但这不是必需的。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Post&gt; Posts &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Blog Blog &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此示例中，影子外键为 BlogId，因为预先输入导航名称是多余的。</p>
<p><strong>如果已存在同名的属性，则影子属性名称将带有数字后缀(如果属性是主键或属性的类型与主体键不兼容，则不会将其配置为外键。)</strong></p>
<h3 id="单个导航属性"><a href="#单个导航属性" class="headerlink" title="单个导航属性"></a>单个导航属性</h3><p>仅包含一个导航属性（没有反向导航，也没有外键属性）就足以按约定定义关系。 还可包含一个导航属性和一个外键属性。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Post&gt; Posts &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>如果在两个类型之间定义了多个导航属性（即不止一对指向彼此的导航），则由导航属性表示的关系是不明确的。 需要对它们进行手动配置才能解决这种不明确的关系。</p>
<h3 id="级联删除"><a href="#级联删除" class="headerlink" title="级联删除"></a>级联删除</h3><p>根据约定，对于必需关系，级联删除将设置为<code>Cascade</code>，对于可选关系，它将设置为<code>ClientSetNull</code>。<code>Cascade</code>表示也会删除依赖实体。<code>ClientSetNull</code>表示未加载到内存中的依赖实体将保持不变，必须手动删除或更新以指向有效的主体实体。 对于加载到内存中的实体，EF Core 将尝试将外键属性设置为 <code>null</code>。</p>
<h2 id="手动配置"><a href="#手动配置" class="headerlink" title="手动配置"></a>手动配置</h2><p>若要在<code>Fluent API</code>中配置关系，首先应标识构成关系的导航属性。<code>HasOne</code>或<code>HasMany</code>标识要开始配置的实体类型的导航属性。然后，将调用链接到<code>WithOne</code>或<code>WithMany</code>以标识反向导航。<code>HasOne/WithOne</code>用于引用导航属性,<code>HasMany/WithMany</code>用于集合导航属性。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Blog</span>&gt; Blogs</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Post</span>&gt; Posts</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;Post&gt;()</span><br><span class="line">            .HasOne(p =&gt; p.Blog)</span><br><span class="line">            .WithMany(b =&gt; b.Posts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Post&gt; Posts &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Blog Blog &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单个导航属性-1"><a href="#单个导航属性-1" class="headerlink" title="单个导航属性"></a>单个导航属性</h3><p>如果只有一个导航属性，则<code>WithOne</code>和<code>WithMany</code>会发生无参数重载。 这表示在关系的另一端，存在概念上的引用或集合，但实体类中不包含导航属性。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Blog</span>&gt; Blogs</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Post</span>&gt; Posts</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">            .HasMany(b =&gt; b.Posts)</span><br><span class="line">            .WithOne();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Post&gt; Posts &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配置导航属性"><a href="#配置导航属性" class="headerlink" title="配置导航属性"></a>配置导航属性</h2><p>创建导航属性后，可能需要进一步对其进行配置。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .HasMany(b =&gt; b.Posts)</span><br><span class="line">        .WithOne();</span><br><span class="line"></span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Navigation(b =&gt; b.Posts)</span><br><span class="line">        .UsePropertyAccessMode(PropertyAccessMode.Property);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>可使用 Fluent API 来配置哪个属性应用作给定关系的外键属性：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Blog</span>&gt; Blogs</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Post</span>&gt; Posts</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;Post&gt;()</span><br><span class="line">            .HasOne(p =&gt; p.Blog)</span><br><span class="line">            .WithMany(b =&gt; b.Posts)</span><br><span class="line">            .HasForeignKey(p =&gt; p.BlogForeignKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">List</span>&lt;<span class="title">Post</span>&gt; Posts</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogForeignKey &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Blog Blog &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复合主键</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Car</span>&gt; Cars</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;Car&gt;()</span><br><span class="line">            .HasKey(c =&gt; <span class="keyword">new</span> &#123; c.State, c.LicensePlate &#125;);</span><br><span class="line"></span><br><span class="line">        modelBuilder.Entity&lt;RecordOfSale&gt;()</span><br><span class="line">            .HasOne(s =&gt; s.Car)</span><br><span class="line">            .WithMany(c =&gt; c.SaleHistory)</span><br><span class="line">            .HasForeignKey(s =&gt; <span class="keyword">new</span> &#123; s.CarState, s.CarLicensePlate &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> State &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> LicensePlate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Make &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Model &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;RecordOfSale&gt; SaleHistory &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RecordOfSale</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> RecordOfSaleId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime DateSold &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> CarState &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> CarLicensePlate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Car Car &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="影子外键"><a href="#影子外键" class="headerlink" title="影子外键"></a>影子外键</h3><p>可以使用 的字符串重载 HasForeignKey(…) 将阴影属性配置为外键,建议在将影子属性用作外键之前将其显式添加到模型中</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Blog</span>&gt; Blogs</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Post</span>&gt; Posts</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Add the shadow property to the model</span></span><br><span class="line">        modelBuilder.Entity&lt;Post&gt;()</span><br><span class="line">            .Property&lt;<span class="built_in">int</span>&gt;(<span class="string">&quot;BlogForeignKey&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use the shadow property as a foreign key</span></span><br><span class="line">        modelBuilder.Entity&lt;Post&gt;()</span><br><span class="line">            .HasOne(p =&gt; p.Blog)</span><br><span class="line">            .WithMany(b =&gt; b.Posts)</span><br><span class="line">            .HasForeignKey(<span class="string">&quot;BlogForeignKey&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Post&gt; Posts &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Blog Blog &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="外键约束名称"><a href="#外键约束名称" class="headerlink" title="外键约束名称"></a>外键约束名称</h3><p>根据约定，当以关系数据库作为目标时，外键约束将命名为 FK__&lt;依赖类型名称&gt;<em>&lt;主体类型名称&gt;</em>&lt;外键属性名称&gt;。 对于复合外键，&lt;外键属性名称&gt; 将成为外键属性名称的下划线分隔列表。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Post&gt;()</span><br><span class="line">        .HasOne(p =&gt; p.Blog)</span><br><span class="line">        .WithMany(b =&gt; b.Posts)</span><br><span class="line">        .HasForeignKey(p =&gt; p.BlogId)</span><br><span class="line">        .HasConstraintName(<span class="string">&quot;ForeignKey_Post_Blog&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="没有导航属性"><a href="#没有导航属性" class="headerlink" title="没有导航属性"></a>没有导航属性</h3><p>无需提供导航属性。 只需在关系的一侧提供外键。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Blog</span>&gt; Blogs</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Post</span>&gt; Posts</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;Post&gt;()</span><br><span class="line">            .HasOne&lt;Blog&gt;()</span><br><span class="line">            .WithMany()</span><br><span class="line">            .HasForeignKey(p =&gt; p.BlogId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="主体键"><a href="#主体键" class="headerlink" title="主体键"></a>主体键</h3><p>如果想要外键引用主键外的属性，可使用 Fluent API 为关系配置主体键属性。 配置为主体键的属性将自动设置为备选键</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Car</span>&gt; Cars</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;RecordOfSale&gt;()</span><br><span class="line">            .HasOne(s =&gt; s.Car)</span><br><span class="line">            .WithMany(c =&gt; c.SaleHistory)</span><br><span class="line">            .HasForeignKey(s =&gt; <span class="keyword">new</span> &#123; s.CarState, s.CarLicensePlate &#125;)</span><br><span class="line">            .HasPrincipalKey(c =&gt; <span class="keyword">new</span> &#123; c.State, c.LicensePlate &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> CarId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> State &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> LicensePlate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Make &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Model &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;RecordOfSale&gt; SaleHistory &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RecordOfSale</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> RecordOfSaleId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime DateSold &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> CarState &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> CarLicensePlate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Car Car &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="必需关系和可选关系"><a href="#必需关系和可选关系" class="headerlink" title="必需关系和可选关系"></a>必需关系和可选关系</h3><p>如果实体类中具有外键属性，则关系的必需性取决于外键属性是必需还是可选，外键属性位于依赖实体类型上，因此如果按要求配置它们，则意味着每个依赖实体都需要具有相应的主体实体。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Post&gt;()</span><br><span class="line">        .HasOne(p =&gt; p.Blog)</span><br><span class="line">        .WithMany(b =&gt; b.Posts)</span><br><span class="line">        .IsRequired();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="级联删除-1"><a href="#级联删除-1" class="headerlink" title="级联删除"></a>级联删除</h3><p>可使用 Fluent API 显式配置给定关系的级联删除行为。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Post&gt;()</span><br><span class="line">        .HasOne(p =&gt; p.Blog)</span><br><span class="line">        .WithMany(b =&gt; b.Posts)</span><br><span class="line">        .OnDelete(DeleteBehavior.Cascade);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他关系模式"><a href="#其他关系模式" class="headerlink" title="其他关系模式"></a>其他关系模式</h2><h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><p>一对一关系在两侧都有引用导航属性。 它们遵循与一对多关系相同的约定，但在外键属性上引入了一个唯一索引，以确保只有一个依赖项与每个主体相关。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BlogImage BlogImage &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BlogImage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogImageId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">byte</span>[] Image &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Caption &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Blog Blog &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在配置与 Fluent API 的关系时，可使用 HasOne 和 WithOne 方法。</p>
<p>显而易见，在一对多关系中，具有引用导航的实体是依赖项，而具有集合的实体是主体。 但在一对一的关系中并非如此，因此需要对其进行显式定义。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Blog</span>&gt; Blogs</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">BlogImage</span>&gt; BlogImages</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">            .HasOne(b =&gt; b.BlogImage)</span><br><span class="line">            .WithOne(i =&gt; i.Blog)</span><br><span class="line">            .HasForeignKey&lt;BlogImage&gt;(b =&gt; b.BlogForeignKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BlogImage BlogImage &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BlogImage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogImageId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">byte</span>[] Image &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Caption &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogForeignKey &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Blog Blog &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下依赖端为可选，但可视需要进行配置。 但是，EF 不会验证是否提供了依赖实体，因此此配置仅在数据库映射允许强制执行时才会产生影响。 此种情况的一个常见场景是默认使用表拆分的引用从属类型。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Order&gt;(</span><br><span class="line">    ob =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        ob.OwnsOne(</span><br><span class="line">            o =&gt; o.ShippingAddress,</span><br><span class="line">            sa =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                sa.Property(p =&gt; p.Street).IsRequired();</span><br><span class="line">                sa.Property(p =&gt; p.City).IsRequired();</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        ob.Navigation(o =&gt; o.ShippingAddress)</span><br><span class="line">            .IsRequired();</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>通过此配置，与 ShippingAddress 对应的列将在数据库中标记为不可为 null。</p>
<h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>多对多关系需要两端的集合导航属性。 与其他类型的关系一样，它们也可通过约定发现。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ICollection&lt;Tag&gt; Tags &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Tag</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> TagId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ICollection&lt;Post&gt; Posts &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在数据库中实现此关系的方式是使用联接表，其中包含 Post 和 Tag 的外键。 例如，以下就是 EF 将在关系数据库中为上述模型创建的内容。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [Posts] (</span><br><span class="line">    [PostId] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">IDENTITY</span>,</span><br><span class="line">    [Title] nvarchar(max) <span class="keyword">NULL</span>,</span><br><span class="line">    [Content] nvarchar(max) <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_Posts] <span class="keyword">PRIMARY</span> KEY ([PostId])</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [Tags] (</span><br><span class="line">    [TagId] nvarchar(<span class="number">450</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_Tags] <span class="keyword">PRIMARY</span> KEY ([TagId])</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [PostTag] (</span><br><span class="line">    [PostsId] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    [TagsId] nvarchar(<span class="number">450</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_PostTag] <span class="keyword">PRIMARY</span> KEY ([PostsId], [TagsId]),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [FK_PostTag_Posts_PostsId] <span class="keyword">FOREIGN</span> KEY ([PostsId]) <span class="keyword">REFERENCES</span> [Posts] ([PostId]) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [FK_PostTag_Tags_TagsId] <span class="keyword">FOREIGN</span> KEY ([TagsId]) <span class="keyword">REFERENCES</span> [Tags] ([TagId]) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在内部，EF 创建一个实体类型Dictionary&lt;string, object&gt; 来表示将称为联接实体类型的联接表。 Dictionary&lt;string, object&gt; 当前用于处理外键属性的任意组合，有关详细信息，请参阅属性包实体类型。 模型中可以存在多个多对多关系，因此必须为联接实体类型指定唯一的名称，在本例中为 PostTag。 允许此操作的功能称为共享类型实体类型。<br><strong>按照约定，用于联接实体类型的 CLR 类型可能会在未来版本中更改以提高性能。 除非已显式配置，否则不要依赖于联接类型 Dictionary&lt;string, object&gt;，如下一节所述。</strong></p>
<p>多对多导航称为跳过导航，因为它们有效地跳过联接实体类型。 如果使用的是批量配置，则可以从 GetSkipNavigations获取所有跳过导航。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> entityType <span class="keyword">in</span> modelBuilder.Model.GetEntityTypes())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> skipNavigation <span class="keyword">in</span> entityType.GetSkipNavigations())</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(entityType.DisplayName() + <span class="string">&quot;.&quot;</span> + skipNavigation.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="联接实体类型配置"><a href="#联接实体类型配置" class="headerlink" title="联接实体类型配置"></a>联接实体类型配置</h4><p>将配置应用于联接实体类型是很常见的。 此操作可通过 UsingEntity 完成。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder</span><br><span class="line">    .Entity&lt;Post&gt;()</span><br><span class="line">    .HasMany(p =&gt; p.Tags)</span><br><span class="line">    .WithMany(p =&gt; p.Posts)</span><br><span class="line">    .UsingEntity(j =&gt; j.ToTable(<span class="string">&quot;PostTags&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>其他数据可存储在联接实体类型中，但为此最好创建一个定制的 CLR 类型。 使用自定义联接实体类型配置关系时，需要显式指定这两个外键。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyContext</span>(<span class="params">DbContextOptions&lt;MyContext&gt; options</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">options</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Post</span>&gt; Posts</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Tag</span>&gt; Tags</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;Post&gt;()</span><br><span class="line">            .HasMany(p =&gt; p.Tags)</span><br><span class="line">            .WithMany(p =&gt; p.Posts)</span><br><span class="line">            .UsingEntity&lt;PostTag&gt;(</span><br><span class="line">                j =&gt; j</span><br><span class="line">                    .HasOne(pt =&gt; pt.Tag)</span><br><span class="line">                    .WithMany(t =&gt; t.PostTags)</span><br><span class="line">                    .HasForeignKey(pt =&gt; pt.TagId),</span><br><span class="line">                j =&gt; j</span><br><span class="line">                    .HasOne(pt =&gt; pt.Post)</span><br><span class="line">                    .WithMany(p =&gt; p.PostTags)</span><br><span class="line">                    .HasForeignKey(pt =&gt; pt.PostId),</span><br><span class="line">                j =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    j.Property(pt =&gt; pt.PublicationDate).HasDefaultValueSql(<span class="string">&quot;CURRENT_TIMESTAMP&quot;</span>);</span><br><span class="line">                    j.HasKey(t =&gt; <span class="keyword">new</span> &#123; t.PostId, t.TagId &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ICollection&lt;Tag&gt; Tags &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;PostTag&gt; PostTags &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Tag</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> TagId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ICollection&lt;Post&gt; Posts &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;PostTag&gt; PostTags &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PostTag</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DateTime PublicationDate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Post Post &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> TagId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Tag Tag &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="联接关系配置"><a href="#联接关系配置" class="headerlink" title="联接关系配置"></a>联接关系配置</h4><p>EF 对联接实体类型使用两个一对多关系来表示多对多关系。 可在 UsingEntity 参数中配置这些关系。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Post&gt;()</span><br><span class="line">    .HasMany(p =&gt; p.Tags)</span><br><span class="line">    .WithMany(p =&gt; p.Posts)</span><br><span class="line">    .UsingEntity&lt;Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;&gt;(</span><br><span class="line">        <span class="string">&quot;PostTag&quot;</span>,</span><br><span class="line">        j =&gt; j</span><br><span class="line">            .HasOne&lt;Tag&gt;()</span><br><span class="line">            .WithMany()</span><br><span class="line">            .HasForeignKey(<span class="string">&quot;TagsId&quot;</span>)</span><br><span class="line">            .HasConstraintName(<span class="string">&quot;FK_PostTag_Tags_TagId&quot;</span>)</span><br><span class="line">            .OnDelete(DeleteBehavior.Cascade),</span><br><span class="line">        j =&gt; j</span><br><span class="line">            .HasOne&lt;Post&gt;()</span><br><span class="line">            .WithMany()</span><br><span class="line">            .HasForeignKey(<span class="string">&quot;PostsId&quot;</span>)</span><br><span class="line">            .HasConstraintName(<span class="string">&quot;FK_PostTag_Posts_PostId&quot;</span>)</span><br><span class="line">            .OnDelete(DeleteBehavior.ClientCascade));</span><br></pre></td></tr></table></figure>

<h4 id="间接多对多关系"><a href="#间接多对多关系" class="headerlink" title="间接多对多关系"></a>间接多对多关系</h4><p>还可表示多对多关系，只需添加联接实体类型并映射两个单独的一对多关系。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyContext</span>(<span class="params">DbContextOptions&lt;MyContext&gt; options</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">options</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Post</span>&gt; Posts</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Tag</span>&gt; Tags</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;PostTag&gt;()</span><br><span class="line">            .HasKey(t =&gt; <span class="keyword">new</span> &#123; t.PostId, t.TagId &#125;);</span><br><span class="line"></span><br><span class="line">        modelBuilder.Entity&lt;PostTag&gt;()</span><br><span class="line">            .HasOne(pt =&gt; pt.Post)</span><br><span class="line">            .WithMany(p =&gt; p.PostTags)</span><br><span class="line">            .HasForeignKey(pt =&gt; pt.PostId);</span><br><span class="line"></span><br><span class="line">        modelBuilder.Entity&lt;PostTag&gt;()</span><br><span class="line">            .HasOne(pt =&gt; pt.Tag)</span><br><span class="line">            .WithMany(t =&gt; t.PostTags)</span><br><span class="line">            .HasForeignKey(pt =&gt; pt.TagId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;PostTag&gt; PostTags &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Tag</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> TagId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;PostTag&gt; PostTags &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PostTag</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DateTime PublicationDate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Post Post &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> TagId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Tag Tag &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是许多数据存储中的常见概念。 尽管它们在数据存储中的实现可能会有所不同，但它们可用于使基于列（或一组列）的查找更加高效。<br>可对列指定索引，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .HasIndex(b =&gt; b.Url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据约定，会在用作外键的每个属性（或属性集）中创建索引</p>
<h2 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h2><p>索引还可以跨多个列：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Person&gt;()</span><br><span class="line">        .HasIndex(p =&gt; <span class="keyword">new</span> &#123; p.FirstName, p.LastName &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="索引唯一性"><a href="#索引唯一性" class="headerlink" title="索引唯一性"></a>索引唯一性</h2><p>默认情况下，索引不唯一：对于索引的列集，允许多行具有相同的值。<br>可使索引唯一，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .HasIndex(b =&gt; b.Url)</span><br><span class="line">        .IsUnique();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尝试为索引的列集插入多个具有相同值的实体将导致引发异常。</p>
<h2 id="索引排序顺序"><a href="#索引排序顺序" class="headerlink" title="索引排序顺序"></a>索引排序顺序</h2><p>在大多数数据库中，索引涵盖的每个列可以是升序或降序。 对于仅包含一列的索引，这通常并不重要：数据库可以根据需要以相反的顺序遍历索引。 但是，对于复合索引，排序对于良好的性能至关重要，并且可以表示查询是否使用索引之间的差异。 通常，索引列的排序顺序应对应于查询的 ORDER BY 子句中指定的排序顺序。</p>
<p>索引排序顺序默认为升序。 可以按如下所示使所有列按降序排列：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .HasIndex(b =&gt; <span class="keyword">new</span> &#123; b.Url, b.Rating &#125;)</span><br><span class="line">        .IsDescending();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以按列指定排序顺序，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .HasIndex(b =&gt; <span class="keyword">new</span> &#123; b.Url, b.Rating &#125;)</span><br><span class="line">        .IsDescending(<span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="索引名称"><a href="#索引名称" class="headerlink" title="索引名称"></a>索引名称</h2><p>根据约定，在关系数据库中创建的索引被命名为<code>IX_&lt;type name&gt;_&lt;property name&gt;</code>。 对于复合索引，<code>&lt;property name&gt;</code> 将成为以下划线分隔的属性名称列表。</p>
<p>可设置在数据库中创建的索引的名称：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .HasIndex(b =&gt; b.Url)</span><br><span class="line">        .HasDatabaseName(<span class="string">&quot;Index_Url&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="索引筛选器"><a href="#索引筛选器" class="headerlink" title="索引筛选器"></a>索引筛选器</h2><p>通过某些关系数据库，可指定筛选索引或部分索引。 这使你可以仅索引列值的子集，从而减少索引的大小并改善性能和磁盘空间的使用情况。<br>可使用 Fluent API 在索引上指定筛选器（以 SQL 表达式的形式提供）：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .HasIndex(b =&gt; b.Url)</span><br><span class="line">        .HasFilter(<span class="string">&quot;[Url] IS NOT NULL&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EF 为作为唯一索引一部分的所有可为 null 列添加 ‘IS NOT NULL’ 筛选器。 若要替代此约定，可提供一个 null 值。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .HasIndex(b =&gt; b.Url)</span><br><span class="line">        .IsUnique()</span><br><span class="line">        .HasFilter(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="包含列"><a href="#包含列" class="headerlink" title="包含列"></a>包含列</h2><p>通过某些关系数据库，可配置一组列，这些列包含在索引中，但不是其“键”的一部分。 当查询中的所有列都作为键列或非键列包含在索引中时，这可以显著提高查询性能，因为无需访问表本身。                                                         在以下示例中，Url 列是索引键的一部分，因此对该列的任何查询筛选都可以使用索引。 但除此之外，仅访问 Title 和 PublishedOn 列的查询将不需要访问表，并且会更高效地运行：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Post&gt;()</span><br><span class="line">        .HasIndex(p =&gt; p.Url)</span><br><span class="line">        .IncludeProperties(</span><br><span class="line">            p =&gt; <span class="keyword">new</span> &#123; p.Title, p.PublishedOn &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="检查约束"><a href="#检查约束" class="headerlink" title="检查约束"></a>检查约束</h2><p>检查约束是一项标准关系功能，让你可以定义一个条件，该条件必须适用于表中的所有行；任何违反约束的插入或修改数据的尝试都将失败。 检查约束类似于非 null 约束（禁止列中的空值）或唯一约束（禁止重复），但允许定义任意 SQL 表达式。</p>
<p>可使用 Fluent API 指定表的检查约束（以 SQL 表达式的形式提供）：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder</span><br><span class="line">        .Entity&lt;Product&gt;()</span><br><span class="line">        .ToTable(b =&gt; b.HasCheckConstraint(<span class="string">&quot;CK_Prices&quot;</span>, <span class="string">&quot;[Price] &gt; [DiscountedPrice]&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>EF 可以将 .NET 类型层次结构映射到数据库。 这允许你像往常一样使用基类型和派生类型在代码中编写 .NET 实体，并让 EF 无缝创建适当的数据库架构、发出查询等。有关如何映射类型层次结构的实际细节取决于提供程序；本页介绍关系数据库上下文中的继</p>
<h2 id="实体类型层次结构映射-TPH"><a href="#实体类型层次结构映射-TPH" class="headerlink" title="实体类型层次结构映射(TPH)"></a>实体类型层次结构映射(TPH)</h2><p>如果要映射层次结构中的 CLR 类型，就必须在模型上显式指定该类型。 例如，仅指定层次结构的基类型不会导致 EF Core 隐式包含其所有子类型。</p>
<p>以下示例将为 Blog 及其子类 RssBlog 公开 DbSet。 如果 Blog 有任何其他子类，它不会包含在模型中。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Blog&gt; Blogs &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;RssBlog&gt; RssBlogs &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RssBlog</span> : <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> RssUrl &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 TPH 映射时，数据库列会根据需要自动设置为可为 null。 例如，RssUrl 列可为 null，因为常规 Blog 实例没有该属性。</p>
<p>如果不依赖约定，则可以使用 HasBaseType 显式指定基类型。 还可以使用 .HasBaseType((Type)null) 从层次结构中删除实体类型。</p>
<h2 id="每个层次结构一张表和鉴别器配置-TPT"><a href="#每个层次结构一张表和鉴别器配置-TPT" class="headerlink" title="每个层次结构一张表和鉴别器配置(TPT)"></a>每个层次结构一张表和鉴别器配置(TPT)</h2><p>TPH 使用单个表来存储层次结构中所有类型的数据，并使用鉴别器列来标识每行表示的类型。</p>
<p>上面的模型映射到以下数据库架构（注意隐式创建的 Discriminator 列，它标识了每行中存储的 Blog 类型）。</p>
<p>可以配置鉴别器列的名称和类型以及用于标识层次结构中每种类型的值：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .HasDiscriminator&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;blog_type&quot;</span>)</span><br><span class="line">        .HasValue&lt;Blog&gt;(<span class="string">&quot;blog_base&quot;</span>)</span><br><span class="line">        .HasValue&lt;RssBlog&gt;(<span class="string">&quot;blog_rss&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，EF 在层次结构的基本实体上隐式添加了鉴别器作为影子属性。 可以像配置任何其他属性一样配置此属性：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(<span class="string">&quot;Discriminator&quot;</span>)</span><br><span class="line">        .HasMaxLength(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，鉴别器也可以映射到实体中的常规 .NET 属性：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .HasDiscriminator(b =&gt; b.BlogType);</span><br><span class="line"></span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .Property(e =&gt; e.BlogType)</span><br><span class="line">        .HasMaxLength(<span class="number">200</span>)</span><br><span class="line">        .HasColumnName(<span class="string">&quot;blog_type&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询使用 TPH 模式的派生实体时，EF Core 会在查询中添加一个基于鉴别器列的谓词。<br>此筛选器确保对于结果中没有的基类型或同级类型，我们不会获得任何附加行。<br>对于基本实体类型，将跳过此筛选器谓词，因为查询基本实体将获得层次结构中所有实体的结果。<br>在具体化查询结果时，如果遇到未映射到模型中任何实体类型的鉴别器值，我们将引发异常，因为我们不知道如何具体化结果。<br>仅当数据库包含的行具有鉴别器值并且这些值未映射到 EF 模型时，才会发生此错误。<br>如果你有这样的数据，可以将 EF Core 模型中的鉴别器映射标记为不完整，以指示我们应始终添加筛选器谓词来查询层次结构中的任意类型。 IsComplete(false) 在鉴别器配置上调用会将映射标记为不完整。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">        .HasDiscriminator()</span><br><span class="line">        .IsComplete(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="共享列"><a href="#共享列" class="headerlink" title="共享列"></a>共享列</h2><p>默认情况下，当层次结构中的两个同级实体类型具有同名的属性时，它们将映射到两个单独的列。 但是，如果它们的类型相同，则可以映射到相同的数据库列：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">BlogBase</span>&gt; Blogs</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">            .Property(b =&gt; b.Url)</span><br><span class="line">            .HasColumnName(<span class="string">&quot;Url&quot;</span>);</span><br><span class="line"></span><br><span class="line">        modelBuilder.Entity&lt;RssBlog&gt;()</span><br><span class="line">            .Property(b =&gt; b.Url)</span><br><span class="line">            .HasColumnName(<span class="string">&quot;Url&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">BlogBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span> : <span class="title">BlogBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RssBlog</span> : <span class="title">BlogBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用强制转换查询共享列时，关系数据库提供程序（例如 SQL Server）不会自动使用鉴别器谓词。 查询 Url &#x3D; (blog as RssBlog).Url 还将返回同级 Blog 行的 Url 值。 若要将查询限制为 RssBlog 实体，你需要在鉴别器上手动添加筛选器，例如 Url &#x3D; blog is RssBlog ? (blog as RssBlog).Url : null。</p>
<h2 id="每个类型一张表配置"><a href="#每个类型一张表配置" class="headerlink" title="每个类型一张表配置"></a>每个类型一张表配置</h2><p>在 TPT 映射模式中，所有类型都分别映射到各自的表。 仅属于某个基类型或派生类型的属性存储在映射到该类型的一个表中。 映射到派生类型的表还存储将派生表与基表联接的外键。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Blog&gt;().ToTable(<span class="string">&quot;Blogs&quot;</span>);</span><br><span class="line">modelBuilder.Entity&lt;RssBlog&gt;().ToTable(<span class="string">&quot;RssBlogs&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>ToTable可以针对每个根实体类型调用 ，而不是对每个实体类型调用 modelBuilder.Entity<Blog>().UseTptMappingStrategy() ，并且表名称将由 EF 生成。</Blog></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [Blogs] (</span><br><span class="line">    [BlogId] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">IDENTITY</span>,</span><br><span class="line">    [Url] nvarchar(max) <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_Blogs] <span class="keyword">PRIMARY</span> KEY ([BlogId])</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [RssBlogs] (</span><br><span class="line">    [BlogId] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    [RssUrl] nvarchar(max) <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_RssBlogs] <span class="keyword">PRIMARY</span> KEY ([BlogId]),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [FK_RssBlogs_Blogs_BlogId] <span class="keyword">FOREIGN</span> KEY ([BlogId]) <span class="keyword">REFERENCES</span> [Blogs] ([BlogId]) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在许多情况下，与 TPH 相比，TPT 性能较差。 有关详细信息，请参阅性能文档。</p>
<h2 id="每个具体表类型-TPC"><a href="#每个具体表类型-TPC" class="headerlink" title="每个具体表类型(TPC)"></a>每个具体表类型(TPC)</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Blog&gt;().UseTpcMappingStrategy()</span><br><span class="line">    .ToTable(<span class="string">&quot;Blogs&quot;</span>);</span><br><span class="line">modelBuilder.Entity&lt;RssBlog&gt;()</span><br><span class="line">    .ToTable(<span class="string">&quot;RssBlogs&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>ToTable将按约定生成表名称，而不是在每个实体类型上调用 ，而只需在每个根实体类型上调用 modelBuilder.Entity<Blog>().UseTpcMappingStrategy() 。</Blog></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [Blogs] (</span><br><span class="line">    [BlogId] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> (NEXT <span class="keyword">VALUE</span> <span class="keyword">FOR</span> [BlogSequence]),</span><br><span class="line">    [Url] nvarchar(max) <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_Blogs] <span class="keyword">PRIMARY</span> KEY ([BlogId])</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [RssBlogs] (</span><br><span class="line">    [BlogId] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> (NEXT <span class="keyword">VALUE</span> <span class="keyword">FOR</span> [BlogSequence]),</span><br><span class="line">    [Url] nvarchar(max) <span class="keyword">NULL</span>,</span><br><span class="line">    [RssUrl] nvarchar(max) <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_RssBlogs] <span class="keyword">PRIMARY</span> KEY ([BlogId])</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="TPC-数据库架构"><a href="#TPC-数据库架构" class="headerlink" title="TPC 数据库架构"></a>TPC 数据库架构</h2><p>TPC 策略类似于 TPT 策略，只是为层次结构中的每个 具体 类型创建不同的表，但 不会 为 抽象 类型创建表，因此名称为“table-per-concrete-type”。 与 TPT 一样，表本身指示保存的对象的类型。 但是，与 TPT 映射不同，每个表都包含具体类型及其基类型中每个属性的列。 TPC 数据库架构非规范化。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Animal</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">string</span> Species &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Food? Food &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Pet</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Pet</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>? Vet &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ICollection&lt;Human&gt; Humans &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> List&lt;Human&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FarmAnimal</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FarmAnimal</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> species</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Species = species;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Species &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Precision(18, 2)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Value &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">        =&gt; <span class="string">$&quot;Farm animal &#x27;<span class="subst">&#123;Name&#125;</span>&#x27; (<span class="subst">&#123;Species&#125;</span>/<span class="subst">&#123;Id&#125;</span>) worth <span class="subst">&#123;Value:C&#125;</span> eats <span class="subst">&#123;Food?.ToString() ?? <span class="string">&quot;&lt;Unknown&gt;&quot;</span>&#125;</span>&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> educationLevel</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        EducationLevel = educationLevel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> EducationLevel &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Species =&gt; <span class="string">&quot;Felis catus&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">        =&gt; <span class="string">$&quot;Cat &#x27;<span class="subst">&#123;Name&#125;</span>&#x27; (<span class="subst">&#123;Species&#125;</span>/<span class="subst">&#123;Id&#125;</span>) with education &#x27;<span class="subst">&#123;EducationLevel&#125;</span>&#x27; eats <span class="subst">&#123;Food?.ToString() ?? <span class="string">&quot;&lt;Unknown&gt;&quot;</span>&#125;</span>&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> favoriteToy</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        FavoriteToy = favoriteToy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> FavoriteToy &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Species =&gt; <span class="string">&quot;Canis familiaris&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">        =&gt; <span class="string">$&quot;Dog &#x27;<span class="subst">&#123;Name&#125;</span>&#x27; (<span class="subst">&#123;Species&#125;</span>/<span class="subst">&#123;Id&#125;</span>) with favorite toy &#x27;<span class="subst">&#123;FavoriteToy&#125;</span>&#x27; eats <span class="subst">&#123;Food?.ToString() ?? <span class="string">&quot;&lt;Unknown&gt;&quot;</span>&#125;</span>&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Human</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Human</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Species =&gt; <span class="string">&quot;Homo sapiens&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Animal? FavoriteAnimal &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> ICollection&lt;Pet&gt; Pets &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> List&lt;Pet&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">        =&gt; <span class="string">$&quot;Human &#x27;<span class="subst">&#123;Name&#125;</span>&#x27; (<span class="subst">&#123;Species&#125;</span>/<span class="subst">&#123;Id&#125;</span>) with favorite animal &#x27;<span class="subst">&#123;FavoriteAnimal?.Name ?? <span class="string">&quot;&lt;Unknown&gt;&quot;</span>&#125;</span>&#x27;&quot;</span> +</span><br><span class="line">           <span class="string">$&quot; eats <span class="subst">&#123;Food?.ToString() ?? <span class="string">&quot;&lt;Unknown&gt;&quot;</span>&#125;</span>&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为此层次结构创建的表为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [Cats] (</span><br><span class="line">    [Id] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> (NEXT <span class="keyword">VALUE</span> <span class="keyword">FOR</span> [AnimalSequence]),</span><br><span class="line">    [Name] nvarchar(max) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    [FoodId] uniqueidentifier <span class="keyword">NULL</span>,</span><br><span class="line">    [Vet] nvarchar(max) <span class="keyword">NULL</span>,</span><br><span class="line">    [EducationLevel] nvarchar(max) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_Cats] <span class="keyword">PRIMARY</span> KEY ([Id]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [Dogs] (</span><br><span class="line">    [Id] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> (NEXT <span class="keyword">VALUE</span> <span class="keyword">FOR</span> [AnimalSequence]),</span><br><span class="line">    [Name] nvarchar(max) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    [FoodId] uniqueidentifier <span class="keyword">NULL</span>,</span><br><span class="line">    [Vet] nvarchar(max) <span class="keyword">NULL</span>,</span><br><span class="line">    [FavoriteToy] nvarchar(max) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_Dogs] <span class="keyword">PRIMARY</span> KEY ([Id]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [FarmAnimals] (</span><br><span class="line">    [Id] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> (NEXT <span class="keyword">VALUE</span> <span class="keyword">FOR</span> [AnimalSequence]),</span><br><span class="line">    [Name] nvarchar(max) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    [FoodId] uniqueidentifier <span class="keyword">NULL</span>,</span><br><span class="line">    [<span class="keyword">Value</span>] <span class="type">decimal</span>(<span class="number">18</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    [Species] nvarchar(max) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_FarmAnimals] <span class="keyword">PRIMARY</span> KEY ([Id]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [Humans] (</span><br><span class="line">    [Id] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> (NEXT <span class="keyword">VALUE</span> <span class="keyword">FOR</span> [AnimalSequence]),</span><br><span class="line">    [Name] nvarchar(max) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    [FoodId] uniqueidentifier <span class="keyword">NULL</span>,</span><br><span class="line">    [FavoriteAnimalId] <span class="type">int</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_Humans] <span class="keyword">PRIMARY</span> KEY ([Id]));</span><br></pre></td></tr></table></figure>
<p>请注意：</p>
<p>没有 用于 Animal 或 Pet 类型的表，因为这些表位于 abstract 对象模型中。 请记住，C# 不允许抽象类型的实例，因此不存在将抽象类型实例保存到数据库的情况。</p>
<p>对于每个具体类型，将重复基类型中的属性映射。 例如，每个表都有一列 Name ，Cats 和 Dogs 都有一列 Vet 。</p>
<h2 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h2><p>选择的继承映射策略会对生成和管理主键值的方式产生影响。 TPH 中的键很简单，因为每个实体实例都由单个表中的一行表示。 可以使用任何类型的键值生成，并且不需要其他约束。</p>
<p>对于 TPT 策略，表中始终有一行映射到层次结构的基类型。 可以在此行上使用任何类型的键生成，其他表的键使用外键约束链接到此表。</p>
<p>对于 TPC 来说，事情会稍微复杂一些。 首先，请务必了解 EF Core 要求层次结构中的所有实体都具有唯一的键值，即使实体具有不同的类型。 例如，使用我们的示例模型，狗不能具有与 Cat 相同的 Id 键值。 其次，与 TPT 不同，没有共同表可以充当键值所在的单个位置，并且可以生成键值。 这意味着无法使用简单 Identity 列。</p>
<p>对于支持序列的数据库，可以使用每个表的默认约束中引用的单个序列来生成键值。 这是上面所示的 TPC 表中使用的策略，其中每个表具有以下项：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Id] <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> (NEXT <span class="keyword">VALUE</span> <span class="keyword">FOR</span> [AnimalSequence])</span><br></pre></td></tr></table></figure>
<p>AnimalSequence 是 EF Core 创建的数据库序列。 将 EF Core 数据库提供程序用于SQL Server时，默认将此策略用于 TPC 层次结构。 支持序列的其他数据库的数据库提供程序应具有类似的默认值。 使用序列的其他密钥生成策略（如 Hi-Lo 模式）也可用于 TPC。</p>
<p>虽然标准标识列不适用于 TPC，但如果每个表都配置了适当的种子和增量，则可以使用标识列，以便为每个表生成的值永远不会发生冲突。 例如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Cat&gt;().ToTable(<span class="string">&quot;Cats&quot;</span>, tb =&gt; tb.Property(e =&gt; e.Id).UseIdentityColumn(<span class="number">1</span>, <span class="number">4</span>));</span><br><span class="line">modelBuilder.Entity&lt;Dog&gt;().ToTable(<span class="string">&quot;Dogs&quot;</span>, tb =&gt; tb.Property(e =&gt; e.Id).UseIdentityColumn(<span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line">modelBuilder.Entity&lt;FarmAnimal&gt;().ToTable(<span class="string">&quot;FarmAnimals&quot;</span>, tb =&gt; tb.Property(e =&gt; e.Id).UseIdentityColumn(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">modelBuilder.Entity&lt;Human&gt;().ToTable(<span class="string">&quot;Humans&quot;</span>, tb =&gt; tb.Property(e =&gt; e.Id).UseIdentityColumn(<span class="number">4</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><p>TPC 映射策略创建非规范化的 SQL 架构 - 这是一些数据库纯粹主义者反对它的原因之一。 例如，请考虑外键列 FavoriteAnimalId。 此列中的值必须与某些动物的主键值匹配。 使用 TPH 或 TPT 时，可以使用简单的 FK 约束在数据库中强制实施此操作。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONSTRAINT [FK_Animals_Animals_FavoriteAnimalId] <span class="function">FOREIGN <span class="title">KEY</span> (<span class="params">[FavoriteAnimalId]</span>) REFERENCES [Animals] (<span class="params">[Id]</span>)</span></span><br></pre></td></tr></table></figure>
<p>但是，使用 TPC 时，任何给定动物的主键都存储在对应于该动物的具体类型的表中。 例如，猫的主键存储在 Cats.Id 列中，而狗的主键存储在 Dogs.Id 列中，依此而行。 这意味着无法为此关系创建 FK 约束。</p>
<p>实际上，只要应用程序不尝试插入无效数据，就不是问题。 例如，如果所有数据都由 EF Core 插入并使用导航来关联实体，则保证 FK 列将始终保持有效的 PK 值。</p>
<h2 id="摘要和指南"><a href="#摘要和指南" class="headerlink" title="摘要和指南"></a>摘要和指南</h2><p>总之，TPH 通常适用于大多数应用程序，并且对于各种方案都是很好的默认值，因此，如果不需要 TPC，请不要增加 TPC 的复杂性。 具体而言，如果代码将主要查询许多类型的实体（例如针对基类型编写查询），则倾向于使用 TPH 和 TPC。</p>
<p>话亦然，当代码主要查询单叶类型的实体，并且基准显示与 TPH 相比，TPC 也是一个很好的映射策略。</p>
<p>仅当受外部因素限制时，才使用 TPT。</p>
<h1 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h1><p>序列在数据库中生成唯一的顺序数值。 序列不与特定表关联，可以设置多个表以从同一序列提取值。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>可以在模型中设置序列，然后使用它为属性生成值：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.HasSequence&lt;<span class="built_in">int</span>&gt;(<span class="string">&quot;OrderNumbers&quot;</span>);</span><br><span class="line"></span><br><span class="line">    modelBuilder.Entity&lt;Order&gt;()</span><br><span class="line">        .Property(o =&gt; o.OrderNo)</span><br><span class="line">        .HasDefaultValueSql(<span class="string">&quot;NEXT VALUE FOR OrderNumbers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，从序列生成值的特定SQL是特定于数据库的；上面的示例适用于 SQL Server 但在其他数据库上将失败。 有关详细信息，请查阅数据库的文档。</p>
<h2 id="配置序列设置"><a href="#配置序列设置" class="headerlink" title="配置序列设置"></a>配置序列设置</h2><p>还可以配置序列的其他方面，例如其架构、起始值、增量等：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.HasSequence&lt;<span class="built_in">int</span>&gt;(<span class="string">&quot;OrderNumbers&quot;</span>, schema: <span class="string">&quot;shared&quot;</span>)</span><br><span class="line">        .StartsAt(<span class="number">1000</span>)</span><br><span class="line">        .IncrementsBy(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2022/09/19/ABP/%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/19/ABP/%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">实现领域驱动设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-19 18:17:57" itemprop="dateCreated datePublished" datetime="2022-09-19T18:17:57+08:00">2022-09-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-11 17:56:10" itemprop="dateModified" datetime="2023-03-11T17:56:10+08:00">2023-03-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="实现领域驱动设计"><a href="#实现领域驱动设计" class="headerlink" title="实现领域驱动设计"></a>实现领域驱动设计</h1><blockquote>
<p>写代码非常简单,但是写简单的代码却非常难</p>
</blockquote>
<p>随着应用程序的变化,有时候,为了节省开发时间会违反一些本应遵守的规则,使得代码变得复杂且难以维护.短期来看确实节省了开发时间,但是后期可能需要花费更多的时间为之前的偷懒而买单.无法对原有的代码进行维护,导致大量的逻辑都需要进行重写.</p>
<h2 id="什么是领域驱动设计"><a href="#什么是领域驱动设计" class="headerlink" title="什么是领域驱动设计?"></a>什么是领域驱动设计?</h2><p>领域驱动设计(DDD)是一种将实现与持续进化的模型连接在一起来满足复杂需求的软件开发方法.</p>
<p>DDD适用于复杂领域或较大规模的系统,而不是简单的CRUD程序.它着重于核心领域逻辑,而不是基础架构.这样有助于构建一个灵活,模块化,可维护的代码库.</p>
<p><strong>核心构建组成</strong><br>DDD的关注点在领域层和应用层上,而展现层和基础设施层则视为细节(这个词原文太抽象,自己体会吧),业务层不应依赖它们.</p>
<p>这并不意味着展现层和基础设施层不重要.它们非常重要,但UI框架 和 数据库提供程序 需要你自己定义规则和总结最佳实践.这些不在DDD的讨论范围中.</p>
<p>本节将介绍领域层和应用层的基本构建组件.</p>
<p><strong>领域层构建组成</strong></p>
<ul>
<li>实体(Entity): 实体是种领域对象,它有自己的属性(状态,数据)和执行业务逻辑的方法.实体由唯一标识符(Id)表示,不同ID的两个实体被视为不同的实体.</li>
<li>值对象(Value Object): 值对象是另外一种类型的领域对象,使用值对象的属性来判断两个值对象是否相同,而非使用ID判断.如果两个值对象的属性值全部相同就被视为同一对象.值对象通常是不可变的,大多数情况下它比实体简单.</li>
<li>聚合(Aggregate) 和 聚合根(Aggregate Root): 聚合是由聚合根包裹在一起的一组对象(实体和值对象).聚合根是一种具有特定职责的实体.</li>
<li>仓储(Repository) (接口): 仓储是被领域层或应用层调用的数据库持久化接口.它隐藏了DBMS的复杂性,领域层中只定义仓储接口,而非实现.</li>
<li>领域服务(Domain Service): 领域服务是一种无状态的服务,它依赖多个聚合(实体)或外部服务来实现该领域的核心业务逻辑.<br>规约(Specification): 规约是一种强命名,可重用,可组合,可测试的实体过滤器.</li>
<li>领域事件(Domain Event): 领域事件是当领域某个事件发生时,通知其它领域服务的方式,为了解耦领域服务间的依赖.</li>
</ul>
<p><strong>应用层构建组成</strong></p>
<ul>
<li>应用服务(Application Service): 应用服务是为实现用例的无状态服务.展现层调用应用服务获取DTO.应用服务调用多个领域服务实现用例.用例通常被视为一个工作单元.</li>
<li>数据传输对象(DTO): DTO是一个不含业务逻辑的简单对象,用于应用服务层与展现层间的数据传输.</li>
<li>工作单元(UOW): 工作单元是事务的原子操作.UOW内所有操作,当成功时全部提交,失败时全部回滚.</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2022/09/15/ABP/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/15/ABP/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">领域驱动设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-15 18:16:09" itemprop="dateCreated datePublished" datetime="2022-09-15T18:16:09+08:00">2022-09-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-11 17:56:10" itemprop="dateModified" datetime="2023-03-11T17:56:10+08:00">2023-03-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="领域驱动设计"><a href="#领域驱动设计" class="headerlink" title="领域驱动设计"></a>领域驱动设计</h2><blockquote>
<p><strong>领域驱动设计(DDD)</strong> 是一种通过将实现连接到持续进化的模型来满足复杂需求的软件开发方法. 领域驱动设计的前提是:</p>
<ul>
<li>把项目的主要重点放在核心领域和领域逻辑上</li>
<li>把复杂的设计放在领域模型上</li>
<li>发起技术专家和领域专家之间的创造性协作,以迭代方式完善解决特定领域问题的概念模型</li>
</ul>
</blockquote>
<h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>ABP框架遵循DDD原则和模式去实现分层应用程序模型,该模型由四个基本层组成:</p>
<ul>
<li><strong>表示层:</strong> 为用户提供接口. 使用应用层实现与用户交互.</li>
<li><strong>应用层:</strong> 表示层与领域层的中介,编排业务对象执行特定的应用程序任务. 使用应用程序逻辑实现用例.</li>
<li><strong>领域层:</strong> 包含业务对象以及业务规则. 是应用程序的核心.</li>
<li><strong>基础设施层:</strong> 提供通用的技术功能,支持更高的层,主要使用第三方类库.</li>
</ul>
<h3 id="领域层"><a href="#领域层" class="headerlink" title="领域层"></a>领域层</h3><h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><p>实体通常映射到关系型数据库的表中.<br>实体都继承自Entity<TKey>类,如下所示:</TKey></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Book</span> : <span class="title">Entity</span>&lt;<span class="title">Guid</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Book</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span>(<span class="params">Guid id</span>)</span></span><br><span class="line"><span class="function">     : <span class="title">base</span>(<span class="params">id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果你不想继承基类<code>Entity&lt;TKey&gt;</code>,也可以直接实现<code>IEntity&lt;TKey&gt;</code>接口</p>
</blockquote>
<p><code>Entity&lt;TKey&gt;</code>类只是用给定的主 键类型定义了一个Id属性,在上面的示例中是Guid类型.可以是其他类型如<code>string, int, long</code>或其他你需要的类型.</p>
<p><strong>Guid主键的实体</strong></p>
<ul>
<li>创建一个构造函数,获取ID作为参数传递给基类.如果没有为<code>GUID Id</code>赋值,ABP框架会在保存时设置它,但是在将实体保存到数据库之前最好在实体上有一个有效的<code>Id</code>.</li>
<li>如果使用带参数的构造函数创建实体,那么还要创建一个 <code>private</code> 或 <code>protected</code> 构造函数. 当数据库提供程序从数据库读取你的实体时(反序列化时)将使用它.</li>
<li>不要使用 <code>Guid.NewGuid()</code> 来设置<code>Id</code>! 在创建实体的代码中使用<code>IGuidGenerator</code>服务 传递Id参数. <code>IGuidGenerator</code>经过优化可以产生连续的<code>GUID</code>.这对于关系数据库中的聚集索引非常重要.</li>
</ul>
<p><strong>具有复合键的实体</strong><br>有些实体可能需要 <strong>复合键</strong> .在这种情况下,可以从非泛型<code>Entity</code>类派生实体.如:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserRole</span> : <span class="title">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Guid UserId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Guid RoleId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> DateTime CreationTime &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserRole</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span>[] <span class="title">GetKeys</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; UserId, RoleId &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中,复合键由<code>UserId和RoleId</code>组成.在关系数据库中,它是相关表的复合主键. 具有复合键的实体应当实现上面代码中所示的<code>GetKeys()</code>方法.</p>
<blockquote>
<p>需要注意,复合主键实体不可以使用 <code>IRepository&lt;TEntity, TKey&gt; </code>接口,因为它需要一个唯一的<code>Id</code>属性. 但你可以使用<code>IRepository&lt;TEntity&gt;</code>.</p>
</blockquote>
<h4 id="聚合根"><a href="#聚合根" class="headerlink" title="聚合根"></a>聚合根</h4><p><code>AggregateRoot&lt;TKey&gt;</code>类继承自<code>Entity&lt;TKey&gt;</code>类,所以默认有<code>Id</code>这个属性</p>
<blockquote>
<p>值得注意的是 ABP 会默认为聚合根创建仓储,当然,ABP也可以为所有的实体创建仓储</p>
</blockquote>
<p><strong>聚合根例子</strong><br>这是一个具有子实体集合的聚合根例子:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Order</span> : <span class="title">AggregateRoot</span>&lt;<span class="title">Guid</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> ReferenceNo &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">int</span> TotalItemCount &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> DateTime CreationTime &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> List&lt;OrderLine&gt; OrderLines &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Order</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span>(<span class="params">Guid id, <span class="built_in">string</span> referenceNo</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Check.NotNull(referenceNo, <span class="keyword">nameof</span>(referenceNo));</span><br><span class="line">        </span><br><span class="line">        Id = id;</span><br><span class="line">        ReferenceNo = referenceNo;</span><br><span class="line">        </span><br><span class="line">        OrderLines = <span class="keyword">new</span> List&lt;OrderLine&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddProduct</span>(<span class="params">Guid productId, <span class="built_in">int</span> count</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(</span><br><span class="line">                <span class="string">&quot;You can not add zero or negative count of products!&quot;</span>,</span><br><span class="line">                <span class="keyword">nameof</span>(count)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> existingLine = OrderLines.FirstOrDefault(ol =&gt; ol.ProductId == productId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (existingLine == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            OrderLines.Add(<span class="keyword">new</span> OrderLine(<span class="keyword">this</span>.Id, productId, count));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            existingLine.ChangeCount(existingLine.Count + count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TotalItemCount += count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderLine</span> : <span class="title">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> Guid OrderId &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> Guid ProductId &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">int</span> Count &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">OrderLine</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="title">OrderLine</span>(<span class="params">Guid orderId, Guid productId, <span class="built_in">int</span> count</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        OrderId = orderId;</span><br><span class="line">        ProductId = productId;</span><br><span class="line">        Count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">ChangeCount</span>(<span class="params"><span class="built_in">int</span> newCount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Count = newCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span>[] <span class="title">GetKeys</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Object[] &#123;OrderId, ProductId&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你不想你的聚合根继承<code>AggregateRoot&lt;TKey&gt;</code>类,你可以直接实现<code>IAggregateRoot&lt;TKey&gt;</code>接口</p>
</blockquote>
<p><code>Order</code>是一个具有<code>Guid</code>类型<code>Id</code>属性的 <strong>聚合根</strong>.它有一个<code>OrderLine</code>实体集合.<code>OrderLine</code>是一个具有组合键(<code>OrderId和 ProductId</code>)的实体.</p>
<p>虽然这个示例可能无法实现聚合根的所有最佳实践,但它仍然遵循良好的实践:</p>
<ul>
<li><code>Order</code>有一个公共的构造函数,它需要 minimal requirements 来构造一个”订单”实例.因此,在没有<code>Id</code>和<code>referenceNo</code>的时候是无法创建订单的.<code>protected/private</code>的构造函数只有从数据库读取对象时 <strong>反序列化</strong> 才需要.</li>
<li><code>OrderLine</code>的构造函数是<code>internal</code>的,所以它只能由领域层来创建.在<code>Order.AddProduct</code>这个方法的内部被使用.</li>
<li><code>Order.AddProduct</code>实现了业务规则将商品添加到订单中<br>所有属性都有<code>protected的set</code>.这是为了防止实体在实体外部任意改变.因此,在没有向订单中添加新产品的情况下设置 <code>TotalItemCount</code>将是危险的.它的值由<code>AddProduct</code>方法维护.</li>
</ul>
<p><strong>带有组合键的聚合根</strong><br>虽然这种聚合根并不常见(也不建议使用),但实际上可以按照与上面提到的跟实体相同的方式定义复合键.在这种情况下,要使用非泛型的<code>AggregateRoot</code>基类.</p>
<p><strong>BasicAggregateRoot类</strong><br><code>AggregateRoot</code> 类实现了 <code>IHasExtraProperties 和 IHasConcurrencyStamp</code> 接口,这为派生类带来了两个属性. <code>IHasExtraProperties</code> 使实体可扩展(请参见下面的 额外的属性部分) 和 <code>IHasConcurrencyStamp</code> 添加了由ABP框架管理的 <code>ConcurrencyStamp</code> 属性实现乐观并发. 在大多数情况下,这些是聚合根需要的功能.</p>
<p>但是,如果你不需要这些功能,你的聚合根可以继承 <code>BasicAggregateRoot&lt;TKey&gt;(或BasicAggregateRoot)</code>.</p>
<h4 id="值对象"><a href="#值对象" class="headerlink" title="值对象"></a>值对象</h4><p>值对象类必须实现 <code>GetAtomicValues()</code>方法来返回原始值</p>
<h4 id="仓储"><a href="#仓储" class="headerlink" title="仓储"></a>仓储</h4><p>仓储用于领域对象在数据库中的操作, 通常每个 聚合根 或不同的实体创建对应的仓储.</p>
<p><strong>通用(泛型)仓储</strong><br>ABP为每个聚合根或实体提供了 默认的通用(泛型)仓储 . 你可以在服务中注入 <code>IRepository&lt;TEntity, TKey&gt;</code> 使用标准的CRUD操作.</p>
<p>默认通用仓储用法示例:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PersonAppService</span> : <span class="title">ApplicationService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IRepository&lt;Person, Guid&gt; _personRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonAppService</span>(<span class="params">IRepository&lt;Person, Guid&gt; personRepository</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _personRepository = personRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Create</span>(<span class="params">CreatePersonDto input</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> person = <span class="keyword">new</span> Person &#123; Name = input.Name, Age = input.Age &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> _personRepository.InsertAsync(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;PersonDto&gt; <span class="title">GetList</span>(<span class="params"><span class="built_in">string</span> nameFilter</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> people = _personRepository</span><br><span class="line">            .Where(p =&gt; p.Name.Contains(nameFilter))</span><br><span class="line">            .ToList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> people</span><br><span class="line">            .Select(p =&gt; <span class="keyword">new</span> PersonDto &#123;Id = p.Id, Name = p.Name, Age = p.Age&#125;)</span><br><span class="line">            .ToList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个例子中</p>
<ul>
<li><code>PersonAppService</code> 在它的构造函数中注入了 <code>IRepository&lt;Person, Guid&gt;</code> .</li>
<li><code>Create</code> 方法使用了 <code>InsertAsync</code> 创建并保存新的实体.</li>
<li><code>GetList</code> 方法使用标准<code>LINQ Where 和 ToList </code>方法在数据源中过滤并获取<code>People</code>集合.</li>
</ul>
<p>通用仓储提供了一些开箱即用的标准CRUD功能:</p>
<ul>
<li>提供 <code>Insert</code> 方法用于保存新实体.</li>
<li>提供 <code>Update 和 Delete</code> 方法通过实体或实体<code>id</code>更新或删除实体.</li>
<li>提供 <code>Delete</code> 方法使用条件表达式过滤删除多个实体.</li>
<li>实现了 <code>IQueryable&lt;TEntity&gt;</code>, 所以你可以使用<code>LINQ</code>和扩展方法 <code>FirstOrDefault, Where, OrderBy, ToList</code> 等…</li>
<li>所有方法都具有 <code>sync(同步) 和 async(异步)</code> 版本</li>
</ul>
<p><strong>只读仓储</strong></p>
<p>对于想要使用只读仓储的开发者,我们提供了<code>IReadOnlyRepository&lt;TEntity, TKey&gt; 与 IReadOnlyBasicRepository&lt;Tentity, TKey&gt;</code>接口.</p>
<p><strong>无主键的通用(泛型)仓储</strong></p>
<p>如果你的实体没有<code>id</code>主键 (例如, 它可能具有复合主键) 那么你不能使用上面定义的 <code>IRepository&lt;TEntity, TKey&gt;</code>, 在这种情况下你可以仅使用实体(类型)注入 <code>IRepository&lt;TEntity&gt;</code>.</p>
<blockquote>
<p><code>IRepository&lt;TEntity&gt;</code> 有一些缺失的方法, 通常与实体的 <code>Id</code> 属性一起使用. 由于实体在这种情况下没有 <code>Id</code> 属性, 因此这些方法不可用. 比如 <code>Get</code> 方法通过<code>id</code>获取具有指定<code>id</code>的实体. 不过, 你仍然可以使用<code>IQueryable&lt;TEntity&gt;</code>的功能通过标准<code>LINQ</code>方法查询实体.</p>
</blockquote>
<p><strong>自定义仓储</strong></p>
<p>对于大多数情况, 默认通用仓储就足够了. 但是, 你可能会需要为实体创建自定义仓储类.</p>
<p>自定义仓储接口,首先在领域层定义一个仓储接口:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPersonRepository</span> : <span class="title">IRepository</span>&lt;<span class="title">Person</span>, <span class="title">Guid</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Task&lt;Person&gt; <span class="title">FindByNameAsync</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此接口扩展了 <code>IRepository&lt;Person, Guid&gt; </code>以使用已有的通用仓储功能.</p>
<p>自定义存储库依赖于你使用的数据访问工具. 在此示例中, 我们将使用<code>Entity Framework Core</code>:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PersonRepository</span> : <span class="title">EfCoreRepository</span>&lt;<span class="title">MyDbContext</span>, <span class="title">Person</span>, <span class="title">Guid</span>&gt;, <span class="title">IPersonRepository</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonRepository</span>(<span class="params">IDbContextProvider&lt;TestAppDbContext&gt; dbContextProvider</span>) </span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">dbContextProvider</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;Person&gt; <span class="title">FindByNameAsync</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> dbContext = <span class="keyword">await</span> GetDbContextAsync();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> dbContext.Set&lt;Person&gt;()</span><br><span class="line">            .Where(p =&gt; p.Name == name)</span><br><span class="line">            .FirstOrDefaultAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以直接使用数据库访问提供程序 (本例中是 DbContext ) 来执行操作.</p>
<p><strong>IAsyncQueryableExecuter</strong><br><code>IAsyncQueryableExecuter</code> 是一个用于异步执行 <code>IQueryable&lt;T&gt;</code>对象的服务,不依赖于实际的数据库提供程序.</p>
<p><strong>示例:</strong><br>注入并使用<code>IAsyncQueryableExecuter.ToListAsync()</code>方法</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> Volo.Abp.Application.Dtos;</span><br><span class="line"><span class="keyword">using</span> Volo.Abp.Application.Services;</span><br><span class="line"><span class="keyword">using</span> Volo.Abp.Domain.Repositories;</span><br><span class="line"><span class="keyword">using</span> Volo.Abp.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">AbpDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProductAppService</span> : <span class="title">ApplicationService</span>, <span class="title">IProductAppService</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IRepository&lt;Product, Guid&gt; _productRepository;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IAsyncQueryableExecuter _asyncExecuter;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ProductAppService</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">            IRepository&lt;Product, Guid&gt; productRepository,</span></span></span><br><span class="line"><span class="params"><span class="function">            IAsyncQueryableExecuter asyncExecuter</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _productRepository = productRepository;</span><br><span class="line">            _asyncExecuter = asyncExecuter;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ListResultDto&lt;ProductDto&gt;&gt; GetListAsync(<span class="built_in">string</span> name)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Create the query</span></span><br><span class="line">            <span class="keyword">var</span> query = _productRepository</span><br><span class="line">                .Where(p =&gt; p.Name.Contains(name))</span><br><span class="line">                .OrderBy(p =&gt; p.Name);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Run the query asynchronously</span></span><br><span class="line">            List&lt;Product&gt; products = <span class="keyword">await</span> _asyncExecuter.ToListAsync(query);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ABP框架使用实际数据库提供程序的API异步执行查询.虽然这不是执行查询的常见方式,但它是使用异步API而不依赖于数据库提供者的最佳方式.</p>
<h4 id="领域服务"><a href="#领域服务" class="headerlink" title="领域服务"></a>领域服务</h4><p>在<strong>领域驱动设计(DDD)</strong> 解决方案中,核心业务逻辑通常在聚合(实体)和领域服务中实现. </p>
<p>在以下情况下特别需要创建领域服务</p>
<ul>
<li>你实现了依赖于某些服务（如存储库或其他外部服务）的核心域逻辑.</li>
<li>你需要实现的逻辑与多个聚合&#x2F;实体相关,因此它不适合任何聚合.</li>
</ul>
<p>领域服务是简单的无状态类. 虽然你不必从任何服务或接口派生,但<code>ABP</code>框架提供了一些有用的基类和约定.</p>
<p><code>DomainService</code> 和 <code>IDomainService</code><br>从<code>DomainService</code>基类派生领域服务或直接实现 <code>IDomainService</code>接口.</p>
<p><strong>示例:</strong><br>创建从<code>DomainService</code>基类派生的领域服务.</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Volo.Abp.Domain.Services;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject.Issues</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IssueManager</span> : <span class="title">DomainService</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你这样做时:<code>ABP</code>框架自动将类注册为瞬态生命周期到依赖注入系统.<br>你可以直接使用一些常用服务作为基础属性,而无需手动注入 (例如<code>ILogger and IGuidGenerator</code>).</p>
<blockquote>
<p>建议使用<code>Manager</code> 或 <code>Service</code> 后缀命名领域服务. 我们通常使用如上面示例中的 <code>Manager</code> 后缀. </p>
</blockquote>
<p><strong>示例:</strong><br>实现将问题分配给用户的领域逻辑</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IssueManager</span> : <span class="title">DomainService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IRepository&lt;Issue, Guid&gt; _issueRepository;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IssueManager</span>(<span class="params">IRepository&lt;Issue, Guid&gt; issueRepository</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _issueRepository = issueRepository;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">AssignAsync</span>(<span class="params">Issue issue, AppUser user</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> currentIssueCount = <span class="keyword">await</span> _issueRepository</span><br><span class="line">            .CountAsync(i =&gt; i.AssignedUserId == user.Id);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Implementing a core business validation</span></span><br><span class="line">        <span class="keyword">if</span> (currentIssueCount &gt;= <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IssueAssignmentException(user.UserName);</span><br><span class="line">        &#125;</span><br><span class="line">        issue.AssignedUserId = user.Id;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题是定义如下所示的 聚合根:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Issue</span> : <span class="title">AggregateRoot</span>&lt;<span class="title">Guid</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Guid? AssignedUserId &#123; <span class="keyword">get</span>; <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>internal</code>的<code>set</code>确保外层调用者不能直接在调用 <code>set</code>,并强制始终使用<code>IssueManager</code>为<code>User</code>分配 <code>Issue</code>.</p>
<p><strong>应用程序服务与领域服务</strong><br>虽然<code>应用服务</code>和<code>领域服务</code>都实现了业务规则,但存在根本的逻辑和形式差异:</p>
<ul>
<li>应用程序服务实现应用程序的用例(典型Web应用程序中的用户交互),而领域服务实现核心的、用例独立的领域逻辑.</li>
<li>应用程序服务获取&#x2F;返回 数据传输对象,领域服务方法通常获取和返回领域对象(实体,值对象).</li>
<li>领域服务通常由应用程序服务或其他领域服务使用,而应用程序服务由表示层或客户端应用程序使用.</li>
</ul>
<p><strong>生命周期</strong><br>领域服务的生命周期是<code>瞬态</code>的,它们会自动注册到依赖注入服务.</p>
<h4 id="规约"><a href="#规约" class="headerlink" title="规约"></a>规约</h4><p>规约模式用于为实体和其他业务对象定义 命名、可复用、可组合和可测试的过滤器 .<br>你可以创建一个由<code>Specification&lt;Customer&gt;</code>派生的新规约类.</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Linq.Expressions;</span><br><span class="line"><span class="keyword">using</span> Volo.Abp.Specifications;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Age18PlusCustomerSpecification</span> : <span class="title">Specification</span>&lt;<span class="title">Customer</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> Expression&lt;Func&lt;Customer, <span class="built_in">bool</span>&gt;&gt; ToExpression()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> c =&gt; c.Age &gt;= <span class="number">18</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你也可以直接实现<code>ISpecification&lt;T&gt;</code>接口,但是基类<code>Specification&lt;T&gt;</code>做了大量简化.</p>
</blockquote>
<p>虽然规约模式通常与<code>C#</code>的<code>lambda</code>表达式相比较,算是一种更老的方式.一些开发人员可能认为不再需要它,我们可以直接将表达式传入到仓储或领域服务中,如下所示:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="keyword">await</span> _customerRepository.CountAsync(c =&gt; c.Balance &gt; <span class="number">100000</span> &amp;&amp; c.Age =&gt; <span class="number">18</span>);</span><br></pre></td></tr></table></figure>
<p>自从<code>ABP</code>的仓储支持表达式,这是一个完全有效的用法.你不必在应用程序中定义或使用任何规约,可以直接使用表达式.</p>
<p>所以,规约的意义是什么?为什么或者应该在什么时候考虑去使用它?</p>
<p><strong>何时使用?</strong><br>使用规约的一些好处:</p>
<ul>
<li>可复用:假设你在代码库的许多地方都需要用到优质顾客过滤器.如果使用表达式而不创建规约,那么如果以后更改“优质顾客”的定义会发生什么?假设你想将最低余额从100000美元更改为250000美元,并添加另一个条件,成为顾客超过3年.如果使用了规约,只需修改一个类.如果在任何其他地方重复（复制&#x2F;粘贴）相同的表达式,则需要更改所有的表达式.</li>
<li>可组合:可以组合多个规约来创建新规约.这是另一种可复用性.<br>命名:<code>PremiumCustomerSpecification</code>更好地解释了为什么使用规约,而不是复杂的表达式.因此,如果在你的业务中使用了一个有意义的表达式,请考虑使用规约.</li>
<li>可测试:规约是一个单独（且易于）测试的对象.</li>
</ul>
<p><strong>什么时侯不要使用?</strong></p>
<ul>
<li>没有业务含义的表达式:不要对与业务无关的表达式和操作使用规约.</li>
<li>报表:如果只是创建报表,不要创建规约,而是直接使用<code>IQueryable 和LINQ</code>表达式.你甚至可以使用普通<code>SQL</code>、视图或其他工具生成报表.DDD不关心报表,因此从性能角度来看,查询底层数据存储的方式可能很重要.</li>
</ul>
<h3 id="应用服务层"><a href="#应用服务层" class="headerlink" title="应用服务层"></a>应用服务层</h3><h4 id="应用服务"><a href="#应用服务" class="headerlink" title="应用服务"></a>应用服务</h4><p>应用服务实现应用程序的用例, 将领域层逻辑公开给表示层.从表示层调用应用服务,DTO作为参数. 返回DTO给表示层.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2022/09/06/Mac/Mac-%E5%AE%89%E8%A3%85-nvm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/06/Mac/Mac-%E5%AE%89%E8%A3%85-nvm/" class="post-title-link" itemprop="url">Mac 安装 nvm</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-06 18:51:30" itemprop="dateCreated datePublished" datetime="2022-09-06T18:51:30+08:00">2022-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-01-17 16:11:49" itemprop="dateModified" datetime="2023-01-17T16:11:49+08:00">2023-01-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li>从github下载nvm仓库到 ~&#x2F;目录  地址：<a target="_blank" rel="noopener" href="https://github.com/nvm-sh/nvm.git">https://github.com/nvm-sh/nvm.git</a><br> git clone <a target="_blank" rel="noopener" href="https://github.com/nvm-sh/nvm.git">https://github.com/nvm-sh/nvm.git</a></li>
<li>进入 nvm目录中执行install.sh 等待执行完成<br> sh install.sh</li>
<li>配置nvm环境变量将下述代码复制到 ~&#x2F;.bash_profile<br>vim ~&#x2F;.bash_profile</li>
</ol>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="attribute">NVM_DIR</span>=<span class="string">&quot;<span class="variable">$HOME</span>/.nvm&quot;</span></span><br><span class="line"> </span><br><span class="line">[ -s <span class="string">&quot;<span class="variable">$NVM_DIR</span>/nvm.sh&quot;</span> ] &amp;&amp; \. <span class="string">&quot;<span class="variable">$NVM_DIR</span>/nvm.sh&quot;</span> </span><br><span class="line"> </span><br><span class="line"> # This loads nvm</span><br><span class="line"> </span><br><span class="line">[ -s <span class="string">&quot;<span class="variable">$NVM_DIR</span>/bash_completion&quot;</span> ] &amp;&amp; \. <span class="string">&quot;<span class="variable">$NVM_DIR</span>/bash_completion&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># This loads nvm bash_completion</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>执行source  ~&#x2F;.bash_profile</li>
<li>执行nvm –version是否可以正常输出，若不行则重启终端再次尝试</li>
<li>nvm操作<br>①：使用  nvm install  node版本号  也可直接输入nvm install node 最新版本<br>②：使用 nvm list  或  nvm ls  可查看当前安装的node版本<br>③：使用 nvm use node版本 可以切换当前使用的node<br>④：使用 nvm alias default node版本  可以指定默认打开终端时的node版本</li>
</ol>
<p><strong>问题</strong></p>
<p>每开一次终端，要 source ~&#x2F;.bash_profile 环境变量才生效。</p>
<p><strong>原因</strong></p>
<blockquote>
<p>MacOS Catalina(10.15)，macOS的默认终端从bash变成了zsh。<br>Mac10.15以下版本,默认shell环境是bash，系统环境变量的配置文件是 &#x2F;etc&#x2F;profile 文件。<br>Mac10.15以上版本,默认shell环境是zsh，系统环境变量的配置文件是 &#x2F;etc&#x2F;zshrc 文件。</p>
</blockquote>
<p><strong>解决方法</strong></p>
<p>编辑个人主目录下的.zshrc 这个文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure>
<p>在最后一行少添加一句：source ~&#x2F;.bash_profile</p>
<p>这样每次打开新窗口或标签页就自动执行了source ~&#x2F;.bash_profile，环境变量就有了</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2022/04/12/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/12/hello-world/" class="post-title-link" itemprop="url">声明</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-12 00:00:00" itemprop="dateCreated datePublished" datetime="2022-04-12T00:00:00+08:00">2022-04-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-06 15:19:06" itemprop="dateModified" datetime="2022-09-06T15:19:06+08:00">2022-09-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>您浏览到的信息，来源于网络，网站中的内容只为个人研究记录，对于信息真实性本站点概不负责，如有侵权，请留意联系，谢谢！</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
