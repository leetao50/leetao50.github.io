<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"leetao50.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
<meta property="og:type" content="website">
<meta property="og:title" content="InfoPool">
<meta property="og:url" content="https://leetao50.github.io/page/2/index.html">
<meta property="og:site_name" content="InfoPool">
<meta property="og:description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
<meta property="og:locale" content="zh_CN">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://leetao50.github.io/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>InfoPool</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">InfoPool</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">私人信息记录</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">记录信息来源网络，内容只为方便查找，非公开信息，非请勿入</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/06/30/cshap/I-O/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/30/cshap/I-O/" class="post-title-link" itemprop="url">I/O</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-30 16:44:23" itemprop="dateCreated datePublished" datetime="2023-06-30T16:44:23+08:00">2023-06-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-20 09:46:18" itemprop="dateModified" datetime="2023-07-20T09:46:18+08:00">2023-07-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="流体系结构"><a href="#流体系结构" class="headerlink" title="流体系结构"></a>流体系结构</h1><p>.NET流体系结构由三个概念组成：后端存储，装饰器以及适配器，如图1所示：</p>
<p> Stream类.NET中用于处理流的基类，Stream公开了一组用于读取、写入和定位的标准方法。与数组(数据同时存在于内存中)不同，流连续处理数据（一次一个字节或以可管理大小的块为单位）。因此，无论其后端存储的大小如何，流都可以使用少量的固定内存处理。</p>
<p><img src="441dba1fea629c0299c8442fe23232dce52948e3c2089cf0e372efdd1bda986c.png" alt="图 0">  </p>
<p><strong>流分为两类：</strong></p>
<ul>
<li>后端存储流：它们是与特定的后台存储类型连接的流，例如FileStream或者NetworkStream</li>
<li>装饰流：这些流会使用其他的流，并以某种方式转换数据。例如DeflateStream或者CryptoStream。</li>
</ul>
<p>后台存储是输入输出的终结点，例如文件或者网络连接。准确地说，它可以是以下的一种或者两种：</p>
<ul>
<li>支持顺序读取字节的源。</li>
<li>支持顺序写入字节的目标。</li>
</ul>
<p>装饰流具有下列的体系结构优点：</p>
<ul>
<li>将原来需要后端存储流自己实现例的功能(如压缩或是加密等)，剥离出来</li>
<li>当后端存储流被装饰后，后端存储流不再忍受接口变化的痛苦</li>
<li>我们在运行时连接到装饰器</li>
<li>我们可以将装饰器链接在一起</li>
</ul>
<p>后端存储与装饰器流以字节为单位进行处理。尽管这比较灵活与高效，但是程序通常在更高的层次上进行文本或XML的处理，因此需要适配器，将流封装到一个具有特定方法的类中，来实现文本或xml的处理。例如，一个文本读取器公开了一个ReadLine方法；一个XML写入器公开了WriteAttributes方法。</p>
<blockquote>
<p>总结起来就是，后端存储流提供了原始数据；装饰器流提供了透明的二进制转换，例如加密；适配器提供了类型方法来以更高级形式处理数据，例如字符串与XML。图1显示他们之间的关系。要形成一个链，我们只需要将一个对象传递给另一个对象的构造函数。</p>
</blockquote>
<h1 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h1><p>抽象的Stream类是所有流的基类。它的方法和属性定义了三种基本的操作：读、写、查找。除此之外，它还定义了一些管理性的任务，例如关闭、刷新（flush）和配置超时时间。</p>
<p><img src="cb397f8378359e0537bd842c3cb975ea276408e279bfae69dc29eea113272d42.png" alt="图 1">  </p>
<p>还有 Read 和 Write 方法的异步版本，它们都返回 Tasks 并可选择接受取消令牌。</p>
<h2 id="读取与写入"><a href="#读取与写入" class="headerlink" title="读取与写入"></a>读取与写入</h2><p>流可以支持读取，写入或者两者都支持。如果CanWrite为true，则流支持写入；如果CanRead为true，则流支持读取。</p>
<p>Read方法支持从流中读取数据块并存入数组。他返回所读取的字节数，返回值总是小于或是等于count参数。</p>
<p>如果返回值小于count，则意味着或者是到达了流的结尾，或者是流以更小的块向我们提供数据（在网络流中经常如此）。以上任何一种情况下，数组中的字节余额将保持未写入状态，保留之前的值。</p>
<p>使用 Read，您可以确定仅当该方法返回 0 时您已到达流的末尾。因此，如果您有一个1,000字节的流，以下代码可能无法将其全部读入内存：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assuming s is a stream:</span></span><br><span class="line"><span class="built_in">byte</span>[] data = <span class="keyword">new</span> <span class="built_in">byte</span> [<span class="number">1000</span>];</span><br><span class="line">s.Read (data, <span class="number">0</span>, data.Length);</span><br></pre></td></tr></table></figure>
<p>Read 方法可以读取 1 到 1,000 字节的任意位置，留下流的剩余部分未读。</p>
<p>下面是读取 1,000 字节流的正确方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">byte</span>[] data = <span class="keyword">new</span> <span class="built_in">byte</span> [<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// bytesRead will always end up at 1000, unless the stream is</span></span><br><span class="line"><span class="comment">// itself smaller in length:</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> bytesRead = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> chunkSize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (bytesRead &lt; data.Length &amp;&amp; chunkSize &gt; <span class="number">0</span>)</span><br><span class="line">    bytesRead +=</span><br><span class="line">		chunkSize = s.Read (data, bytesRead, data.Length - bytesRead);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>幸运的是，BinaryReader 类型提供了一种更简单的方法来实现相同的结果：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">byte</span>[] data = <span class="keyword">new</span> BinaryReader (s).ReadBytes (<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>如果流的长度小于 1,000 字节，则返回的字节数组反映实际的流大小。如果流是可搜索的，您可以通过将 1000 替换为 (int)s.Length 来读取其全部内容。</p>
<p>ReadByte 方法更简单：它只读取一个字节，返回 -1 以指示流的结尾。 ReadByte 实际上返回一个 int 而不是一个 byte，因为后者不能返回 −1。</p>
<p>Write 和 WriteByte 方法将数据发送到流。如果它们无法发送指定的字节，则会抛出异常。</p>
<blockquote>
<p>注意，在Read与Write方法中，offset参数指读取或写在buffer数组中开始的索引，而不是流中的位置。</p>
</blockquote>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>如果CanSeek方法返回true，则流是可定位的。对于可定位的流（例如文件流），我们可以查询或是修改其Length（通过调用SetLenght），并且在任何时刻修改我们正在读取或是写入的Position。</p>
<p>Position属性是相对于流的起始处的；然而，Seek方法可以使得我们相对于当前位置或是文件的结束处进行移动。</p>
<p>注意，在FileStream上改变Position通常会花费几毫秒的时间。如果我们在一个循环中执行几百万次，框架4.0中新的MemoryMappedFile类是比FileStream更好的选择。</p>
<p>对于不可定位的流（例如加密流），确定其长度的唯一方法就是完全读取。而且，如果我们需要重新读取前面的一部分，我们必须关闭流并重新读取。</p>
<h2 id="关闭与输出缓冲"><a href="#关闭与输出缓冲" class="headerlink" title="关闭与输出缓冲"></a>关闭与输出缓冲</h2><p>流在使用之后必须销毁来释放底层资源，例如文件或是套接字句柄。保证关闭流的最简单方法是在using块中实例化流。通常，流遵循标准的销毁语义：</p>
<ul>
<li>Dispose与Close在功能上是相同的</li>
<li>重复销毁或是关闭流不会引起错误</li>
</ul>
<p>关闭一个装饰器流会同时关闭装饰器以及其后端存储流。对于一个装饰器链，关闭最外层的装饰器（位于链的头部）会关闭整个装饰器链。</p>
<p>某些流在内部会缓冲要写入后端存储的数据或是由后端存储读取的数据来减少读取的来回次数从而改进性能（文件流就是一个好例子）。这意味着我们要写入流的数据也许并没有立即写入后端存储；写入会被延迟直到缓冲区被填满。Flush方法会强制在内部缓冲的数据被立即写入。Flush方法在流被关闭时自动调用的，所以我们不需要执行下面的语句：</p>
<p>s.Flush(); s.Close();</p>
<h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p>如果CanTimeout返回true，则流支持读写超时。网络支持超时；文件流与内存流则不支持。对于支持超时的流，ReadTimeout与WriteTimeout属性决定了所需要的超时时间，以毫秒计，0则为不超时。Read与Write方法通过抛出异常来表明发生了超时。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>作为一条规则，流不是线程安全的，意味着两个线程不能同时读取或是写入相同的流，以避免错误。Stream类通过静态的Synchronized方法提供了一个简单的解决办法。这个方法接受一个任意类型的流并返回一个线程安全的包装器。包装器通过获取读取，写入或是定位上的一个排他锁来进行工作，从而保证在任意时刻只有一个线程可以执行这样的操作。</p>
<h2 id="后端存储流"><a href="#后端存储流" class="headerlink" title="后端存储流"></a>后端存储流</h2><p>图2显示了.NET框架所提供的关键后端存储流。同时还有一个“空流”，是通过Stream的静态Null域来提供的。</p>
<p><img src="3dc184edab65c04d5ad20fc7a71555f6440068f641d92a4f76368fc075f7fd1c.png" alt="图 2">  </p>
<p>在以下部分中，我们将描述FileStream与MemoryStream；在本章的最后一部分，我们描述IsolatedStorageStream。</p>
<h2 id="FileStream"><a href="#FileStream" class="headerlink" title="FileStream"></a>FileStream</h2><h3 id="创建-FileStream"><a href="#创建-FileStream" class="headerlink" title="创建 FileStream"></a>创建 FileStream</h3><p>实例化FileStream的最简单的方法是使用File类型中的静态方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileStream fs1 = File.OpenRead  (<span class="string">&quot;readme.bin&quot;</span>);            <span class="comment">// Read-only</span></span><br><span class="line">FileStream fs2 = File.OpenWrite (<span class="string">@&quot;c:\temp\writeme.tmp&quot;</span>);  <span class="comment">// Write-only</span></span><br><span class="line">FileStream fs3 = File.Create    (<span class="string">@&quot;c:\temp\writeme.tmp&quot;</span>);  <span class="comment">// Read/write</span></span><br></pre></td></tr></table></figure>

<p>如果文件已经存在，那么OpenWrite和Create的行为是不同的。Create方法会删除其全部内容，而OpenWrite则会保留流中全部已有内容并将流的起始位置设置为0。如果我们写入的内容比原始文件内容长度还短，则OpenWrite执行之后其文件内容会同时包含新旧内容。</p>
<p>还可以直接实例化一个FileStream。它的构造器支持所有特性，例如允许指定文件名或者底层文件句柄、文件创建和访问模式、共享选项、缓冲选项以及安全性。例如，以下代码会直接打开一个已有文件进行读、写操作，而不会覆盖这个文件：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="keyword">new</span> FileStream(<span class="string">&quot;readwrite.tmp&quot;</span>, FileMode.Open);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下的静态方法能够将一个文件一次性读到内存中：</p>
<p>File.ReadAllText（返回字符串）<br>File.ReadAllLines（返回一个字符串数组）<br>File.ReadAllBytes（返回一个字节数组）</p>
<p>以下的静态方法能够一次性地写入一个完整的文件：<br>File.WriteAllText<br>File.WriteAllLines<br>File.WriteAllBytes<br>File.AppendAllText（适用于向日志文件中追加内容）</p>
</blockquote>
<h3 id="指定文件名"><a href="#指定文件名" class="headerlink" title="指定文件名"></a>指定文件名</h3><p>文件名可以是绝对路径（例如c:\temp\test.txt）也可以是相对当前目录的路径（例如，test.txt或者temp\test.txt）。可以访问Environment.CurrentDirectory属性来获得或者更改当前目录。</p>
<p>AppDomain.CurrentDomain.BaseDirectory属性会返回应用程序的基础目录（base directony），正常情况下它就是可执行文件所在的文件夹。结合使用Path.Combine方法就可以定位该目录下的文件名。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">string</span> baseFolder = AppDomain.CurrentDomain.BaseDirectory;</span><br><span class="line"><span class="built_in">string</span> tmp = Path.Combine(baseFolder, <span class="string">&quot;readwrite.tmp&quot;</span>);</span><br><span class="line">Console.WriteLine(File.Exists(tmp));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="指定FileMode"><a href="#指定FileMode" class="headerlink" title="指定FileMode"></a>指定FileMode</h3><p>FileStream类型每一个接受文件名的构造器都需要提供FileMode枚举参数。</p>
<p><img src="c229f7d8378c038fd944267998044bceff517a0017ac8118bf6e88d15cbdff1f.png" alt="图 3">  </p>
<p>如果用于隐藏文件，File.Create 和 FileMode.Create 将抛出异常。要覆盖隐藏文件，您必须删除并重新创建它：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File.Delete (<span class="string">&quot;hidden.txt&quot;</span>);</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> file = File.Create (<span class="string">&quot;hidden.txt&quot;</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在创建FileStream时若只提供文件名和FileMode将会得到一个可读可写的流（但有一种例外）。而如果传入了FileAccess参数，就可以对读写模式进行取舍了：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> FileAccess&#123;Read = <span class="number">1</span>, Write = <span class="number">2</span>, ReadWrite = <span class="number">3</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以下返回一个只读流，相当于调用 File.OpenRead：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> fs = <span class="keyword">new</span> FileStream (<span class="string">&quot;x.bin&quot;</span>, FileMode.Open, FileAccess.Read);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>FileMode.Append则是一个例外。这个模式只会得到只读的流。相反，如果既要追加内容，又希望支持读写的话，就需要使用FileMode.Open或者FileMode. OpenOrCreate，打开文件，并定位到流的结尾处：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> fs = <span class="keyword">new</span> FileStream(<span class="string">&quot;myFile.bin&quot;</span>, FileMode.Open))</span><br><span class="line">&#123;</span><br><span class="line">    fs.Seek(<span class="number">0</span>, SeekOrign.End);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FileStream的高级特性"><a href="#FileStream的高级特性" class="headerlink" title="FileStream的高级特性"></a>FileStream的高级特性</h3><p>创建FileSteam时可选的其他参数：</p>
<ul>
<li><p>FileShare枚举：描述了在完成文件处理之前，若其他进程希望访问该文件，则可以给其他进程授予的访问权限（None、Read、ReadWrite或者Write，其中Read为默认权限）。</p>
</li>
<li><p>内部缓冲区的大小（字节为单位，默认大小为4KB）。</p>
</li>
<li><p>是否由操作系统管理异步I&#x2F;O的标志。</p>
</li>
<li><p>FileSecurity对象，描述给新文件分配的用户角色和权限。</p>
</li>
<li><p>FileOptions标志枚举值，其中包括：请求操作系统加密（Encrypted），在文件关闭时自动删除临时文件（DeleteOnClose），以及优化提示（RandomAccess和SequentialScan）。此外还有一个WriteThrough标志可以要求操作系统禁用写后缓存，这适用于事物文件或日志文件的处理。</p>
</li>
</ul>
<p>使用FileShare.ReadWrite打开一个文件可以允许其他进程或用户读写同一个文件。为了避免混乱，我们可以使用以下方法在读或者写之前锁定文件的特定部分。</p>
<ul>
<li>public virtual void Lock (long postion, long length);</li>
<li>public virtual void Unlock (long postion, long length);</li>
</ul>
<p>如果所请求的文件部分已经被锁定了，Lock则抛出异常。这为系统用于基于文件的数据库，例如Access与FoxPro。</p>
<h2 id="MemoryStream"><a href="#MemoryStream" class="headerlink" title="MemoryStream"></a>MemoryStream</h2><p>MemoryStream使用数组作为后端存储。这在某种程度上破坏了拥有流的目的，因为整个的后端存储只在内存中存在一次。然而，MemoryStream依然有用；当我们需要随机访问一个不可定位的流时就是一个好例子。如果我们知道源流将是可管理尺寸的，那么我们就可以将其拷贝到MemoryStream中，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ms = <span class="keyword">new</span> MemoryStream();</span><br><span class="line">sourceStream.CopyTo (ms);</span><br></pre></td></tr></table></figure>
<p>我们可以通过调用ToArray将一个MemoryStream转换为一个字节数组。</p>
<p>GetBuffer方法通过直接引用底层存储数组可以高效的完成相同的工作；不幸的是，这个数组通常要长于流的实际长度。</p>
<h2 id="PipeStream"><a href="#PipeStream" class="headerlink" title="PipeStream"></a>PipeStream</h2><p>PipeStream 可以使用Windows管道协议与另一个进程进行通信。</p>
<p>管道类型有两种：</p>
<ul>
<li><p>匿名管道（速度快）：支持在同一个计算机中的父进程和子进程之间进行单向通信。</p>
</li>
<li><p>命名管道（更加灵活）：允许同一台计算机的任意两个进程之间，或者不同计算机（使用Windows网络）的两个进程间进行双向通信。</p>
</li>
</ul>
<p>管道很适合在同一台计算机进行进程间通信（IPC）：它不依赖于任何网络传输（因此没有网络协议开销），性能更好，也不会有防火墙问题。</p>
<blockquote>
<p>管道是基于流实现的，因此一个进程会等待接收字节，而另一个进程则负责发送字节。</p>
</blockquote>
<p>PipeStream是一个抽象类，它有4个子类。其中两个用于匿名管道而另外两个用于命名管道。</p>
<blockquote>
<p>匿名管道：AnonymousPipeServerStream和AnonymousPipeClientStream。</p>
</blockquote>
<blockquote>
<p>命名管道：NamedPipeServerStream和NamedPipeClientStream。</p>
</blockquote>
<h3 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h3><p>命管道可以让通信各方使用名称相同的管道进行通信。其协议定义了两种不同的角色：客户端与服务器。客户端和服务器之间的通信采用以下方式：</p>
<ul>
<li><p>服务器实例化一个NamedPipeServerStream，然后调用WaitForConnection方法。</p>
</li>
<li><p>客户端实例化一个NamedPipeClientStream，然后调用Connect（可提供可选的超时时间）。此后，双方就可以通过读写流进行通信了。</p>
</li>
</ul>
<p>服务端：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server pipe</span></span><br><span class="line">    <span class="keyword">using</span>(<span class="keyword">var</span> ns = <span class="keyword">new</span> NamedPipeServerStream(<span class="string">&quot;pipedream&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        ns.WaitForConnection();</span><br><span class="line">        ns.WriteByte(<span class="number">100</span>);</span><br><span class="line">        Console.WriteLine(ns.ReadByte());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client pipe</span></span><br><span class="line">   <span class="keyword">using</span> (<span class="keyword">var</span> ns = <span class="keyword">new</span> NamedPipeClientStream(<span class="string">&quot;pipedream&quot;</span>))</span><br><span class="line">   &#123;</span><br><span class="line">       ns.Connect();</span><br><span class="line">       Console.WriteLine(ns.ReadByte());</span><br><span class="line">       ns.WriteByte(<span class="number">200</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>命名管道流默认是双向通信的，因此任何一方都可以读或者写它们的流。这意味着客户端和服务器都必须统一使用一种协议来协调它们的操作，因此双方不能同时发送或者接收消息。</p>
<p>通信双方需要统一每一次传输的数据长度。上面的例子只传输了一个字节，如果要传输更长的数据，管道提供了一种消息传输模式。如果启用了这个模式，调用read的一方可以检查IsMessageComplete来确定消息是否传输完毕。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取pipstream中的完整消息</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">byte</span>[] <span class="title">ReadMessage</span>(<span class="params">PipeStream s</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MemoryStream ms = <span class="keyword">new</span> MemoryStream();</span><br><span class="line">    <span class="built_in">byte</span>[] buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        ms.Write(buffer, <span class="number">0</span>, s.Read(buffer, <span class="number">0</span>, buffer.Length));</span><br><span class="line">    &#125; <span class="keyword">while</span> (!s.IsMessageComplete);</span><br><span class="line">    <span class="keyword">return</span> ms.ToArray();</span><br><span class="line">&#125;         </span><br></pre></td></tr></table></figure>
<p>在服务器端，在创建流时指定PipeTransm-issionMode.Message就可以激活消息传输(这里还需要传入最大服务端数量)：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server pipe</span></span><br><span class="line"><span class="keyword">using</span>(<span class="keyword">var</span> ns = <span class="keyword">new</span> NamedPipeServerStream(<span class="string">&quot;pipedream&quot;</span>, PipeDirection.InOut, <span class="number">2</span>, PipeTransmissionMode.Message))</span><br><span class="line">&#123;</span><br><span class="line">    ns.WaitForConnection();</span><br><span class="line">    <span class="built_in">byte</span>[] msg = Encoding.UTF8.GetBytes(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    ns.Write(msg, <span class="number">0</span>, msg.Length);</span><br><span class="line">    Console.WriteLine(Encoding.UTF8.GetString(ReadMessage(ns)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在客户端，调用Connect之后设置ReadMode即可激活消息传输模式：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client pipe</span></span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> ns = <span class="keyword">new</span> NamedPipeClientStream(<span class="string">&quot;pipedream&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    ns.Connect();</span><br><span class="line">    ns.ReadMode = PipeTransmissionMode.Message;</span><br><span class="line">    Console.WriteLine(Encoding.UTF8.GetString(ReadMessage(ns)));</span><br><span class="line">    <span class="built_in">byte</span>[] msg = Encoding.UTF8.GetBytes(<span class="string">&quot;Hello right back!&quot;</span>);</span><br><span class="line">    ns.Write(msg, <span class="number">0</span>, msg.Length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="BufferedStream"><a href="#BufferedStream" class="headerlink" title="BufferedStream"></a>BufferedStream</h2><p>BufferedStream 装饰或包装另一个具有缓冲功能的流，它是 .NET 中的许多装饰器流类型之一，所有这些都在图 4 中进行了说明。</p>
<p><img src="8617d9de7bd400ac307cb25266a24acd8fedc3ee22928e8feb36e772371ccf3a.png" alt="图 4">  </p>
<p>缓冲通过减少到后备存储的往返行程来提高性能。以下是我们如何将 FileStream 包装在 20 KB BufferedStream 中：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write 100K to a file:</span></span><br><span class="line">File.WriteAllBytes (<span class="string">&quot;myFile.bin&quot;</span>, <span class="keyword">new</span> <span class="built_in">byte</span> [<span class="number">100000</span>]);</span><br><span class="line"><span class="keyword">using</span> (FileStream fs = File.OpenRead (<span class="string">&quot;myFile.bin&quot;</span>))</span><br><span class="line"><span class="keyword">using</span> (BufferedStream bs = <span class="keyword">new</span> BufferedStream (fs, <span class="number">20000</span>))  <span class="comment">//20K buffer</span></span><br><span class="line">&#123;</span><br><span class="line">  bs.ReadByte();</span><br><span class="line">  Console.WriteLine (fs.Position);         <span class="comment">// 20000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，由于读取缓冲(bs)，底层流(fs)在仅读取1个字节之后读取了20000个字节。我们可以在与FileStream再次交互之前调用ReadByte 19999次。</p>
<p>类似于这个示例，将BufferedStream与FileStream组合并没有太大我价值，因为FileStream已经具有内建的缓冲。他唯一的用处也许就是在已经构建的FileStream上增大缓冲。</p>
<p>关闭BufferedStream会自动关闭底层的后端存储流。</p>
<h1 id="流适配器"><a href="#流适配器" class="headerlink" title="流适配器"></a>流适配器</h1><p>Stream只能以字节方式进行处理；要读取或是写入例如字符串，整数或是XML元素这样的数据类型，我们必须借助于适配器。下面是框架所提供的适配：</p>
<ul>
<li>文本适配器（用于字符串与字符数据）：TextReader，TextWriter，StreamReader，StreamWriter，StringReader，StringWriter</li>
<li>二进制适配器（用于基础数据类型，例如int，bool，string与float）：BinaryReader，BinaryWriter</li>
<li>XML适配器：XmlReader，XmlWriter</li>
</ul>
<p><img src="a7d6931ec14582d1ec0e74381fc8e28a8f9933931e7d1ca4c3985e9a396a0349.png" alt="图 5">  </p>
<h2 id="TextReader与TextWriter"><a href="#TextReader与TextWriter" class="headerlink" title="TextReader与TextWriter"></a>TextReader与TextWriter</h2><p>TextReader与TextWriter是用于处理字符与字符串的适配器的抽象基类。在框架中，每一个都有两个通用目的的实现：</p>
<ul>
<li>StreamReader&#x2F;StreamWriter：使用Stream作为原始的数据源，将流字节转换为字符或是字符串</li>
<li>StringReader&#x2F;StringWriter：使用内存字符串实现了TextReader&#x2F;TextWriter</li>
</ul>
<p><img src="9bf9ea60c016c1bd0aae8a3defc296c332f856fb0bdffb3d6b5e1ed0422054e5.png" alt="图 6">  </p>
<p>表 15-2 按类别列出了 TextReader 的成员。 </p>
<ul>
<li>Peek 返回流中的下一个字符而不前进位置。如果在流的末尾，Peek 和 Read 的零参数版本都返回 -1；否则，它们返回一个可以直接转换为 char 的整数。</li>
<li>接受 char[] 缓冲区的 Read 重载在功能上与 ReadBlock 方法相同。 </li>
<li>ReadLine 读取直到到达 CR（字符 13）或 LF（字符 10），或顺序到达 CR+LF 对。然后它返回一个字符串，丢弃 CR&#x2F;LF 字符。</li>
</ul>
<p><img src="5226f8fac2ad929f6b2fe36fc9bb6b4225d3f15e4fbc8cf3ff20d4b8c2c54d48.png" alt="图 7">  </p>
<p>TextWriter 具有类似的写入方法，如表 15-3 所示。 </p>
<ul>
<li><p>Write 和 WriteLine 方法被额外重载以接受每个基本类型以及对象类型。这些方法只是对传入的任何内容调用 ToString 方法（可选地通过在调用方法或构造 TextWriter 时指定的 IFormatProvider）。</p>
</li>
<li><p>WriteLine 只是在给定文本后附加 Environment.NewLine。您可以通过 NewLine 属性更改它（这对于与 Unix 文件格式的互操作性很有用）。</p>
</li>
</ul>
<h2 id="StreamReader与StreamWriter"><a href="#StreamReader与StreamWriter" class="headerlink" title="StreamReader与StreamWriter"></a>StreamReader与StreamWriter</h2><p>在下面的示例中，StreamWriter向文件写入两行许可证，然后StreamReader读取这个文件：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (FileStream fs = File.Create (<span class="string">&quot;test.txt&quot;</span>))</span><br><span class="line"><span class="keyword">using</span> (TextWriter writer = <span class="keyword">new</span> StreamWriter (fs))</span><br><span class="line">&#123;</span><br><span class="line">  writer.WriteLine (<span class="string">&quot;Line1&quot;</span>);</span><br><span class="line">  writer.WriteLine (<span class="string">&quot;Line2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> (FileStream fs = File.OpenRead (<span class="string">&quot;test.txt&quot;</span>))</span><br><span class="line"><span class="keyword">using</span> (TextReader reader = <span class="keyword">new</span> StreamReader (fs))</span><br><span class="line">&#123;</span><br><span class="line">  Console.WriteLine (reader.ReadLine());       <span class="comment">// Line1</span></span><br><span class="line">  Console.WriteLine (reader.ReadLine());       <span class="comment">// Line2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为文本适配器经常与文件进行交互，File提供了静态的CreateText，AppendText以及OpenText来简化处理：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (TextWriter writer = File.CreateText (<span class="string">&quot;test.txt&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">  writer.WriteLine (<span class="string">&quot;Line1&quot;</span>);</span><br><span class="line">  writer.WriteLine (<span class="string">&quot;Line2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> (TextWriter writer = File.AppendText (<span class="string">&quot;test.txt&quot;</span>))</span><br><span class="line">  writer.WriteLine (<span class="string">&quot;Line3&quot;</span>);</span><br><span class="line"><span class="keyword">using</span> (TextReader reader = File.OpenText (<span class="string">&quot;test.txt&quot;</span>))</span><br><span class="line">  <span class="keyword">while</span> (reader.Peek() &gt; <span class="number">-1</span>)</span><br><span class="line">    Console.WriteLine (reader.ReadLine()); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Line1</span></span><br><span class="line">    <span class="comment">// Line2</span></span><br><span class="line">   <span class="comment">// Line3</span></span><br></pre></td></tr></table></figure>
<p>这同时演示了如何测试文件的结尾（通过reader.Peek()）。另一种方法就是一直读取直到reader.ReadLine返回null。</p>
<p>我们也可以读取或是写入其他的类型，例如整数，但是因为TextWriter在我们的类型上调用ToString方法，当我们重新读取时必须分析字符串：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (TextWriter w = File.CreateText (<span class="string">&quot;data.txt&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">  w.WriteLine (<span class="number">123</span>);          <span class="comment">// Writes &quot;123&quot;</span></span><br><span class="line">  w.WriteLine (<span class="literal">true</span>);         <span class="comment">// Writes the word &quot;true&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> (TextReader r = File.OpenText (<span class="string">&quot;data.txt&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span> myInt = <span class="built_in">int</span>.Parse (r.ReadLine());     <span class="comment">// myInt == 123</span></span><br><span class="line">  <span class="built_in">bool</span> yes = <span class="built_in">bool</span>.Parse (r.ReadLine());     <span class="comment">// yes == true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>TextReader与TextWriter仅是不具有到流或是后端存储连接的抽象类。然而，StreamReader与StreamWriter类型则连接到底层面向字节的流，所以他们必须在字符与字节之间进行转换。他们是通过System.Text名字空间听 Encoding类来完成的，我们可以在构建StreamReader或是StreamWriter时选择。如果我们没有选择，则使用默认的UTF-8编码。</p>
<p>最简单的编码是ASCII编码，因为每一个字符由一个字节表示。ASCII编码将Unicode集合中的前127个字符映射为单个字节，转换我们在US风格的键盘上所看到的字符。大多数其他的字符，包括特殊符号以及非英语字符不能被表示，并被转换为□字符。默认的UTF-8编码可以映射所有的Unicode字符，但是他更为复杂。为了与ASCII兼容，前127个字符被编码为单个字节；其余的字符被编码为变化的字节数（通常是两个或是三个）。例如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (TextWriter w = File.CreateText (<span class="string">&quot;but.txt&quot;</span>))    <span class="comment">// Use default UTF-8</span></span><br><span class="line">  w.WriteLine (<span class="string">&quot;but-&quot;</span>);                               <span class="comment">// encoding.</span></span><br><span class="line"><span class="keyword">using</span> (Stream s = File.OpenRead (<span class="string">&quot;but.txt&quot;</span>))</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> b; (b = s.ReadByte()) &gt; ?<span class="number">1</span>;)</span><br><span class="line">    Console.WriteLine (b);</span><br></pre></td></tr></table></figure>

<p>单词“but”之后并不是一个标准的连字符，而是一个更长的em dash字符(—)，U+2014。这不会使得我们的书本编辑器遇到麻烦。让我们看一下其输出：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">98</span>     <span class="comment">// b</span></span><br><span class="line"><span class="number">117</span>    <span class="comment">// u</span></span><br><span class="line"><span class="number">116</span>    <span class="comment">// t</span></span><br><span class="line"><span class="number">226</span>    <span class="comment">// em dash byte 1       Note that the byte values</span></span><br><span class="line"><span class="number">128</span>    <span class="comment">// em dash byte 2       are &gt;= 128 for each part</span></span><br><span class="line"><span class="number">148</span>    <span class="comment">// em dash byte 3       of the multibyte sequence.</span></span><br><span class="line"><span class="number">13</span>     <span class="comment">// &lt;CR&gt;</span></span><br><span class="line"><span class="number">10</span>     <span class="comment">// &lt;LF&gt;</span></span><br></pre></td></tr></table></figure>
<p>由于em dash位于Unicode集合中前127个字符之外，他要求更多个的字节来进行UTF-8编码（在这个示例中为三个）。</p>
<p>UTF-8足够表示西方字符，因为大多数字符仅需要一个字节。通过简单的忽略127以上的字符，他可以很容易的转换为ASCII字符。其缺点是在流中定位比较麻烦，因为一个字符的位置并不与流中其字节位置相对应。</p>
<p>另一种方法是UTF-16。下面是我们使用UTF-16编写相同的字符串：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (Stream s = File.Create (<span class="string">&quot;but.txt&quot;</span>))</span><br><span class="line"><span class="keyword">using</span> (TextWriter w = <span class="keyword">new</span> StreamWriter (s, Encoding.Unicode))</span><br><span class="line">    w.WriteLine (<span class="string">&quot;but-&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">byte</span> b <span class="keyword">in</span> File.ReadAllBytes (<span class="string">&quot;but.txt&quot;</span>))</span><br><span class="line">    Console.WriteLine (b);</span><br><span class="line"></span><br><span class="line">输出如下：</span><br><span class="line"></span><br><span class="line"><span class="number">255</span> <span class="comment">// Byte-order mark 1</span></span><br><span class="line"><span class="number">254</span> <span class="comment">// Byte-order mark 2</span></span><br><span class="line"><span class="number">98</span>  <span class="comment">// &#x27;b&#x27; byte 1</span></span><br><span class="line"><span class="number">0</span>   <span class="comment">// &#x27;b&#x27; byte 2</span></span><br><span class="line"><span class="number">117</span> <span class="comment">// &#x27;u&#x27; byte 1</span></span><br><span class="line"><span class="number">0</span>   <span class="comment">// &#x27;u&#x27; byte 2</span></span><br><span class="line"><span class="number">116</span> <span class="comment">// &#x27;t&#x27; byte 1</span></span><br><span class="line"><span class="number">0</span>   <span class="comment">// &#x27;t&#x27; byte 2</span></span><br><span class="line"><span class="number">20</span>  <span class="comment">// &#x27;--&#x27; byte 1</span></span><br><span class="line"><span class="number">32</span>  <span class="comment">// &#x27;--&#x27; byte 2</span></span><br><span class="line"><span class="number">13</span>  <span class="comment">// &lt;CR&gt; byte 1</span></span><br><span class="line"><span class="number">0</span>   <span class="comment">// &lt;CR&gt; byte 2</span></span><br><span class="line"><span class="number">10</span>  <span class="comment">// &lt;LF&gt; byte 1</span></span><br><span class="line"><span class="number">0</span>   <span class="comment">// &lt;LF&gt; byte 2</span></span><br></pre></td></tr></table></figure>

<p>从技术上讲，UTF-16 每个字符使用两个或四个字节（分配或保留了近一百万个 Unicode 字符，因此两个字节并不总是足够的）。但是，由于 C# char 类型本身只有 16 位宽，UTF-16 编码将始终为每个 .NET char 使用恰好两个字节。这使得跳转到流中的特定字符索引变得容易。</p>
<p>UTF-16 使用双字节前缀来标识字节对是以“小端”还是“大端”顺序写入的（最低有效字节在前或最高有效字节在前）。默认的小端顺序是基于 Windows 的系统的标准顺序。</p>
<h2 id="StringReader与StringWriter"><a href="#StringReader与StringWriter" class="headerlink" title="StringReader与StringWriter"></a>StringReader与StringWriter</h2><p>StringReader与StringWriter并没有封装流；相反，他们使用字符串或是StringBuilder作为底层数据存储。这就意味着并不需要字节转换－事实上，除了我们使用字符串或是StringBuilder结合索引变量很容易实现的事情以外，这个类并不能做其他事情。他们的优点是与StreamReader&#x2F;StringWriter共享相同的基类。例如，假设我们有一个包含XML的字符串，并且希望使用XmlReader进行分析。XmlReader.Create可以接受下列中的一个：</p>
<ul>
<li>URI</li>
<li>流</li>
<li>TextReader</li>
</ul>
<p>那么，我们如何对字符串进行 XML 解析？因为 StringReader 是 TextReader 的子类，所以我们很幸运。我们可以实例化并传入一个 StringReader，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XmlReader r = XmlReader.Create (<span class="keyword">new</span> StringReader (myString));</span><br></pre></td></tr></table></figure>

<h2 id="二进制适配器"><a href="#二进制适配器" class="headerlink" title="二进制适配器"></a>二进制适配器</h2><p>BinaryReader与BinaryWriter可以读取与写入本地数据类型：bool，byte，char，decimal，float，double，short，int，long，sbyte，ushort，unit与ulong，以及string和基础数据类型的数组。</p>
<p>与 StreamReader 和 StreamWriter 不同，二进制适配器有效地存储原始数据类型，因为它们在内存中表示。因此，一个 int 使用四个字节； double 使用八个字节。字符串是通过文本编码（与 StreamReader 和 StreamWriter 一样）写入的，但带有长度前缀，这样就可以在不需要特殊分隔符的情况下读回一系列字符串。</p>
<p>假定我们有一个简单的类型，定义如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以将以下方法添加到 Person 以使用二进制适配器将其数据保存到流中&#x2F;从流中加载数据：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveData</span> (<span class="params">Stream s</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> w = <span class="keyword">new</span> BinaryWriter (s);</span><br><span class="line">    w.Write (Name);</span><br><span class="line">    w.Write (Age);</span><br><span class="line">    w.Write (Height);</span><br><span class="line">    w.Flush(); <span class="comment">// Ensure the BinaryWriter buffer is cleared.</span></span><br><span class="line">               <span class="comment">// We won&#x27;t dispose/close it, so more data</span></span><br><span class="line">&#125; <span class="comment">// can be written to the stream.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadData</span> (<span class="params">Stream s</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> r = <span class="keyword">new</span> BinaryReader (s);</span><br><span class="line">    Name = r.ReadString();</span><br><span class="line">    Age = r.ReadInt32();</span><br><span class="line">    Height = r.ReadDouble();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BinaryReader 也可以读入字节数组。下面读取一个可搜索流的全部内容：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">byte</span>[] data = <span class="keyword">new</span> BinaryReader (s).ReadBytes ((<span class="built_in">int</span>) s.Length);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这比直接从流中读取更方便，因为它不需要循环来确保所有数据都已被读取。</p>
<h2 id="关闭与销毁流适配器"><a href="#关闭与销毁流适配器" class="headerlink" title="关闭与销毁流适配器"></a>关闭与销毁流适配器</h2><p>关闭流适配器时我们下列四个选择：</p>
<ul>
<li>仅关闭适配器</li>
<li>关闭适配器，然后关闭流</li>
<li>（对于写入）调用适配器的Flush（）方法（输出缓冲），然后关闭流</li>
<li>（对于读取）仅关闭流</li>
</ul>
<p>选项1与2在语义是上相同的，因为关闭适配器会自动关闭底层流。当我们嵌入using语句时，我们隐式的选择了选项2：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (FileStream fs = File.Create (<span class="string">&quot;test.txt&quot;</span>))</span><br><span class="line"><span class="keyword">using</span> (TextWriter writer = <span class="keyword">new</span> StreamWriter (fs))</span><br><span class="line">  writer.WriteLine (<span class="string">&quot;Line&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>由于嵌入语句是由里向外销毁，所以适配器被首先关闭，然后是流。而且，如果在适配器的构造器中抛出异常，流仍然关闭。嵌入的using语句很难遇到错误。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (FileStream fs = <span class="keyword">new</span> FileStream (<span class="string">&quot;test.txt&quot;</span>, FileMode.Create))</span><br><span class="line">&#123;</span><br><span class="line">  StreamWriter writer = <span class="keyword">new</span> StreamWriter (fs);</span><br><span class="line">  writer.WriteLine (<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  writer.Flush();</span><br><span class="line">  fs.Position = <span class="number">0</span>;</span><br><span class="line">  Console.WriteLine (fs.ReadByte());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们写入文件，重新定位流，并且在关闭流之前读取第一个字节。如果我们销毁StreamWriter，他也会关闭底层的FileStream，从而例程后续的读取操作失败。这样做的限制则是我们调用Flush来保证StreamWriter的缓冲被写入底层流中。</p>
<p>StreamReader&#x2F;StreamWriter 上还有一个构造函数，指示它在处理后保持流打开。因此，我们可以将前面的例子重写如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> fs = <span class="keyword">new</span> FileStream (<span class="string">&quot;test.txt&quot;</span>, FileMode.Create))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> writer = <span class="keyword">new</span> StreamWriter (fs, <span class="keyword">new</span> UTF8Encoding (<span class="literal">false</span>, <span class="literal">true</span>), <span class="number">0x400</span>, <span class="literal">true</span>))</span><br><span class="line">    writer.WriteLine (<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    fs.Position = <span class="number">0</span>;</span><br><span class="line">    Console.WriteLine (fs.ReadByte());</span><br><span class="line">    Console.WriteLine (fs.Length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>FileSteam：内部缓冲区的大小（字节为单位，默认大小为4KB）</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/06/27/cshap/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/27/cshap/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/" class="post-title-link" itemprop="url">文件和目录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-27 15:44:15" itemprop="dateCreated datePublished" datetime="2023-06-27T15:44:15+08:00">2023-06-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-14 17:43:25" itemprop="dateModified" datetime="2023-07-14T17:43:25+08:00">2023-07-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>文件是一个由字节组成的有序的命名集合，它具有永久存储。在处理文件时，你将处理目录路径、磁盘存储、文件和目录名称。 </p>
<h1 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h1><p>System.IO 命名空间提供了一组用于执行“实用”文件和目录操作的类型，例如复制和移动、创建目录以及设置文件属性和权限。对于大多数功能，您可以在两个类中选择一个，一个提供静态方法，另一个提供实例方法：</p>
<ul>
<li><p>静态类：File 和 Directory</p>
</li>
<li><p>实例方法类：FileInfo 和 DirectoryInfo</p>
</li>
</ul>
<p>另外，还有一个名为Path的静态类。这个类对于文件或是目录并没有什么；相反，他为文件名与目录路径提供了字符串处理的方法。Path同时辅助临时文件处理。</p>
<p>下面是一些常用的文件和目录类：</p>
<ul>
<li>File - 提供用于创建、复制、删除、移动和打开文件的静态方法，并可帮助创建 FileStream 对象。</li>
<li>FileInfo - 提供用于创建、复制、删除、移动和打开文件的实例方法，并可帮助创建 FileStream 对象。</li>
<li>Directory - 提供用于创建、移动和枚举目录和子目录的静态方法。</li>
<li>DirectoryInfo - 提供用于创建、移动和枚举目录和子目录的实例方法。</li>
<li>Path - 提供用于以跨平台的方式处理目录字符串的方法和属性。</li>
</ul>
<h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><p>File是一个静态类，其方法接受文件名。文件名可以相对于当前目录或是具有目录的绝对路径。该类所具有的方法如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">Exists</span> (<span class="params"><span class="built_in">string</span> path</span>)</span>;      <span class="comment">// Returns true if the file is present</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span>  (<span class="params"><span class="built_in">string</span> path</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Copy</span>    (<span class="params"><span class="built_in">string</span> sourceFileName, <span class="built_in">string</span> destFileName</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Move</span>    (<span class="params"><span class="built_in">string</span> sourceFileName, <span class="built_in">string</span> destFileName</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Replace</span> (<span class="params"><span class="built_in">string</span> sourceFileName, <span class="built_in">string</span> destinationFileName,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="built_in">string</span> destinationBackupFileName</span>)</span>;</span><br><span class="line"><span class="function">FileAttributes <span class="title">GetAttributes</span> (<span class="params"><span class="built_in">string</span> path</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetAttributes</span>           (<span class="params"><span class="built_in">string</span> path, FileAttributes fileAttributes</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Decrypt</span> (<span class="params"><span class="built_in">string</span> path</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Encrypt</span> (<span class="params"><span class="built_in">string</span> path</span>)</span>;</span><br><span class="line"><span class="function">DateTime <span class="title">GetCreationTime</span>   (<span class="params"><span class="built_in">string</span> path</span>)</span>;      <span class="comment">// UTC versions are</span></span><br><span class="line"><span class="function">DateTime <span class="title">GetLastAccessTime</span> (<span class="params"><span class="built_in">string</span> path</span>)</span>;      <span class="comment">// also provided.</span></span><br><span class="line"><span class="function">DateTime <span class="title">GetLastWriteTime</span>  (<span class="params"><span class="built_in">string</span> path</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetCreationTime</span>   (<span class="params"><span class="built_in">string</span> path, DateTime creationTime</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetLastAccessTime</span> (<span class="params"><span class="built_in">string</span> path, DateTime lastAccessTime</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetLastWriteTime</span>  (<span class="params"><span class="built_in">string</span> path, DateTime lastWriteTime</span>)</span>;</span><br><span class="line"><span class="function">FileSecurity <span class="title">GetAccessControl</span> (<span class="params"><span class="built_in">string</span> path</span>)</span>;</span><br><span class="line"><span class="function">FileSecurity <span class="title">GetAccessControl</span> (<span class="params"><span class="built_in">string</span> path,</span></span></span><br><span class="line"><span class="params"><span class="function">AccessControlSections includeSections</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetAccessControl</span> (<span class="params"><span class="built_in">string</span> path, FileSecurity fileSecurity</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>如果目标文件已经存在，则Move会抛出异常；Replace则不会。两个方法都允许文件被重命名以及移动到另一个目录中。</p>
<p>如果文件被标记为只读，则会抛出UnauthorizedAccessException；如果我们通过调用GetAttributes来识别属性。下面是GetAttributes返回的FileAttribute枚举成员：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Archive, Compressed, Device, Directory, Encrypted,</span><br><span class="line">Hidden, Normal, NotContentIndexed, Offline, ReadOnly,</span><br><span class="line">ReparsePoint, SparseFile, System, Temporary</span><br></pre></td></tr></table></figure>
<p>这个枚举中的成员是可组合的。下面显示如何修改文件的一个属性而不影响其他的属性：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> filePath = <span class="string">@&quot;c:\temp\test.txt&quot;</span>;</span><br><span class="line">FileAttributes fa = File.GetAttributes (filePath);</span><br><span class="line"><span class="keyword">if</span> ((fa &amp; FileAttributes.ReadOnly) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    fa ^= FileAttributes.ReadOnly;</span><br><span class="line">    File.SetAttributes (filePath, fa);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Now we can delete the file, for instance:</span></span><br><span class="line">File.Delete (filePath);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/06/27/cshap/stream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/27/cshap/stream/" class="post-title-link" itemprop="url">stream</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-27 10:51:04" itemprop="dateCreated datePublished" datetime="2023-06-27T10:51:04+08:00">2023-06-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-30 16:45:56" itemprop="dateModified" datetime="2023-06-30T16:45:56+08:00">2023-06-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Stream(抽象基类)支持读取和写入字节。 所有表示流的类都继承自Stream类。 Stream类及其派生类提供数据源和存储库的常见视图，使程序员不必了解操作系统和基础设备的具体细节。</p>
<p><strong>流涉及三个基本操作：</strong></p>
<ul>
<li><p>读取 - 将数据从流读取到数据结构（如字节数组）中。</p>
</li>
<li><p>写入 - 将数据从数据源写入到流中。</p>
</li>
<li><p>查找 - 对流中的当前位置进行查询和修改。</p>
</li>
</ul>
<p><strong>下面是一些常用的流类：</strong></p>
<ul>
<li><p>FileStream - 用于对文件进行读取和写入操作。</p>
</li>
<li><p>MemoryStream - 用于对内存进行读取和写入操作。</p>
</li>
<li><p>BufferedStream - 用于改进读取和写入操作的性能。</p>
</li>
<li><p>NetworkStream - 用于通过网络套接字进行读取和写入。</p>
</li>
<li><p>IsolatedStorageFileStream - 用于对独立存储中的文件进行读取或写入操作。</p>
</li>
<li><p>PipeStream - 用于通过匿名和命名管道进行读取和写入。</p>
</li>
<li><p>CryptoStream - 用于将数据流链接到加密转换。</p>
</li>
</ul>
<p><strong>读取器和编写器：</strong><br>System.IO 命名空间还提供用于在流中读取和写入已编码字符的类型。 通常，流用于字节输入和输出。 读取器和编写器 处理编码字符与字节之间的来回转换，以便流可以完成操作。 每个读取器和编写器类都与流关联，可以通过类的 BaseStream 属性进行检索。</p>
<p><em>下面是一些常用的读取器和编写器类：</em></p>
<ul>
<li><p>BinaryReader 和 BinaryWriter - 用于将基元数据类型作为二进制值进行读取和写入。</p>
</li>
<li><p>StreamReader 和 StreamWriter - 用于通过使用编码值在字符和字节之间来回转换来读取和写入字符。</p>
</li>
<li><p>StringReader 和 StringWriter - 用于从字符串读取字符以及将字符写入字符串中。</p>
</li>
<li><p>TextReader 和 TextWriter - 用作其他读取器和编写器（读取和写入字符和字符串，而不是二进制数据）的抽象基类。</p>
</li>
</ul>
<h1 id="Stream-类"><a href="#Stream-类" class="headerlink" title="Stream 类"></a>Stream 类</h1><p>继承自Stream类的一些更常用的流包括 FileStream、 和 MemoryStream。根据不同数据源类型，继承自Stream类的流可能仅支持Stream类中的某些功能。 </p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul>
<li><p>CanRead	<br>当在派生类中重写时，获取指示当前流是否支持读取的值。</p>
</li>
<li><p>CanSeek	<br>当在派生类中重写时，获取指示当前流是否支持查找功能的值。</p>
</li>
<li><p>CanTimeout	<br>获取一个值，该值确定当前流是否可以超时。</p>
</li>
<li><p>CanWrite	<br>当在派生类中重写时，获取指示当前流是否支持写入功能的值。</p>
</li>
<li><p>Length	<br>当在派生类中重写时，获取流长度（以字节为单位）。</p>
</li>
<li><p>Position	<br>当在派生类中重写时，获取或设置当前流中的位置。</p>
</li>
</ul>
<blockquote>
<p>很多asp.net项目中文件或图片上传中很多朋友会经历过这样一个痛苦：Stream对象被缓存了，导致了Position属性在流中无法<br>找到正确的位置，这点会让人抓狂，其实解决这个问题很简单，我们每次使用流前必须将Stream.Position设置成0就行了，但是这还不能根本上解决问题，最好的方法就是用Using语句将流对象包裹起来，用完后关闭回收即可。</p>
</blockquote>
<ul>
<li><p>ReadTimeout	<br>获取或设置一个值（以毫秒为单位），该值确定流在超时前将尝试读取的时间。</p>
</li>
<li><p>WriteTimeout	<br>获取或设置一个值（以毫秒为单位），该值确定流在超时前将尝试写入多长时间。</p>
</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li>Flush()	<br>当在派生类中重写时，将清除该流的所有缓冲区，并使得所有缓冲数据被写入到基础设备。</li>
</ul>
<blockquote>
<p>某些流实现对基础数据执行本地缓冲以提高性能。 对于此类流，可以使用 Flush 或 FlushAsync 方法来清除缓冲区，并确保所有数据都已写入基础数据源或存储库。</p>
</blockquote>
<blockquote>
<p>当使用 StreamWriter 或 BinaryWriter 类时，不要刷新 Stream 基对象。而应使用该类的 Flush 或 Close 方法，此方法确保首先将该数据刷新至基础流，然后再将其写入文件。</p>
</blockquote>
<ul>
<li><p>int Read(Byte[] buffer, Int32 offset, Int32 count)	<br>当在派生类中重写时，从当前流读取字节序列，并将此流中的位置提升读取的字节数。</p>
<blockquote>
<p>这个方法包含了3个关键的参数：</p>
<ul>
<li><p>buffer 缓冲字节数组，此数组中 offset 和 (offset + count - 1) 之间的值被从当前源中读取的字节所替换；</p>
</li>
<li><p>offset 位移偏量，从buffer的offset处开始存储从流中读取的数据；</p>
</li>
<li><p>count 读取字节个数，要从当前流中最多读取的字节数；</p>
</li>
</ul>
<p>返回值：读入缓冲区中的总字节数，总字节数可能小于请求的字节数，如果已到达流结尾，则为零 (0)；</p>
</blockquote>
</li>
<li><p>Seek(long offset , SeekOrigin origin)<br>当在派生类中重写时，设置当前流中的位置。</p>
<blockquote>
<ul>
<li>offset: 相对于 origin 参数的字节偏移量。</li>
<li>origin: SeekOrigin 类型的值，指示用于获取新位置的参考点。</li>
</ul>
<p>如果 offset 为负，则要求新位置位于 origin 指定的位置之前，其间隔相差 offset 指定的字节数。如果 offset 为零 (0)，则要求新位置位于由 origin 指定的位置处。</p>
<p>如果 offset 为正，则要求新位置位于 origin 指定的位置之后，其间隔相差 offset 指定的字节数.</p>
<ul>
<li><p>Stream. Seek(-3,Origin.End);  表示在流末端往前数第3个位置</p>
</li>
<li><p>Stream. Seek(0,Origin.Begin); 表示在流的开头位置</p>
</li>
<li><p>Stream. Seek(3,Orig&#96;in.Current); 表示在流的当前位置往后数第三个位置</p>
</li>
</ul>
</blockquote>
</li>
<li><p>void Write (byte[] buffer, int offset, int count); 向当前流中写入字节序列，并将此流中的当前位置提升写入的字节数。</p>
<blockquote>
<ul>
<li><p>buffer: 字节数组。 此方法将 count 个字节从 buffer 复制到当前流</p>
</li>
<li><p>offset: buffer 中的字节偏移量，从此处开始将字节复制到当前流;</p>
</li>
<li><p>count: 要写入当前流的字节数</p>
</li>
</ul>
<p>如果写入操作成功，则流中的位置将按写入的字节数前进。 如果发生异常，则流中的位置保持不变。</p>
</blockquote>
</li>
</ul>
<h1 id="TextReader"><a href="#TextReader" class="headerlink" title="TextReader"></a>TextReader</h1><p>是一个抽象类。 因此，不要在代码中实例化它。 派生类（StreamReader 和 StringReader）必须至少实现 Peek() 和 Read() 方法，才能成为TextReader有用的实例。</p>
<p>此类型实现 IDisposable 接口。 使用完派生自此类型的任何类型后，应直接或间接释放它。 若要直接释放类型，请在 try&#x2F;catch 块中调用其 Dispose 方法。 若要间接释放类型，请使用 using（在 C# 中）等语言构造</p>
<h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><ul>
<li><p>void Close ()：关闭 TextReader 并释放与该 TextReader 关联的所有系统资源；</p>
</li>
<li><p>void Dispose ()：释放由 TextReader 对象使用的所有资源；假如TextReader中持有stream或其他对象，当TextReader执行了Dispose方法时，stream对象也被回收了；</p>
</li>
<li><p>int Peek ()：读取下一个字符，而不更改读取器状态或字符源。 返回下一个可用字符，而实际上并不从读取器中读取此字符。</p>
<blockquote>
<p>返回值：一个表示下一个要读取的字符的整数；如果没有更多可读取的字符或该读取器不支持查找，则为 -1。<br>该方法 Peek 返回整数值，以确定文件末尾还是发生了另一个错误。 这样，用户就可以先检查返回的值是否为 -1，然后再将其强制转换为 Char 类型。</p>
</blockquote>
</li>
<li><p>int Read ()：读取文本读取器中的下一个字符并使该字符的位置前移一个字符。</p>
</li>
</ul>
<blockquote>
<p>返回值：文本读取器中的下一个字符，或为 -1（如果没有更多可用字符）。 默认实现将返回 -1。</p>
<p>read()方法使指针指向下个字符，但是peek()还是指向原来那个字符</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">string</span> text = <span class="string">&quot;abc\nabc&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> (TextReader reader = <span class="keyword">new</span> StringReader(text))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (reader.Peek() != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Peek = &#123;0&#125;&quot;</span>, (<span class="built_in">char</span>)reader.Peek());</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Read = &#123;0&#125;&quot;</span>, (<span class="built_in">char</span>)reader.Read());</span><br><span class="line">    &#125;</span><br><span class="line">    reader.Close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> (TextReader reader = <span class="keyword">new</span> StringReader(text))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span>[] charBuffer = <span class="keyword">new</span> <span class="built_in">char</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">int</span> data = reader.ReadBlock(charBuffer, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; charBuffer.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;通过readBlock读出的数据：&#123;0&#125;&quot;</span>, charBuffer[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    reader.Close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> (TextReader reader = <span class="keyword">new</span> StringReader(text))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> lineData = reader.ReadLine();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;第一行的数据为:&#123;0&#125;&quot;</span>, lineData);</span><br><span class="line">    reader.Close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> (TextReader reader = <span class="keyword">new</span> StringReader(text))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> allData = reader.ReadToEnd();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;全部的数据为:&#123;0&#125;&quot;</span>, allData);</span><br><span class="line">    reader.Close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.ReadLine();</span><br></pre></td></tr></table></figure>

<h1 id="StreamReader"><a href="#StreamReader" class="headerlink" title="StreamReader"></a>StreamReader</h1><p>实现一个 TextReader，使其以一种特定的编码从字节流中读取字符。</p>
<p>StreamReader 设计用于特定编码中的<em><strong>字符-Char</strong>输入，而 Stream 类设计用于</em>*字节-byte**输入和输出。 用于 StreamReader 从标准文本文件读取信息行。</p>
<p>StreamReader 除非另行指定，否则默认为 UTF-8 编码，而不是默认为当前系统的 ANSI 代码页。 UTF-8 正确处理 Unicode 字符，并在操作系统的本地化版本上提供一致的结果。</p>
<p> 如果使用CurrentEncoding属性获取当前字符编码 ，则值在执行第一个 Read 方法之后才可靠，因为编码自动检测在首次调用方法之前不会完成。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul>
<li>StreamReader(Stream)	：为指定的流初始化 StreamReader 类的新实例。</li>
<li>StreamReader(Stream, Encoding)：用指定的字符编码为指定的流初始化 StreamReader 类的一个新实例。</li>
<li>StreamReader(String, Encoding)：用指定的字符编码，为指定的文件名初始化 StreamReader 类的一个新实例。<blockquote>
<p> 这里的string对象不是简单的字符串而是具体文件的地址,然后根据用户选择编码去读取流中的数据</p>
</blockquote>
</li>
</ul>
<h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><ul>
<li>BaseStream：返回基础流。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FileStream fs = <span class="keyword">new</span> FileStream ( <span class="string">&quot;D:\\TextReader.txt&quot;</span>, FileMode.Open , FileAccess.Read ) ; </span><br><span class="line">StreamReader sr= <span class="keyword">new</span> StreamReader ( fs ) ; </span><br><span class="line"><span class="comment">//本例中的BaseStream就是FileStream</span></span><br><span class="line">sr.BaseStream.Seek (<span class="number">0</span> , SeekOrigin.Begin ) ;</span><br></pre></td></tr></table></figure></li>
<li>CurrentEncoding：获取当前 StreamReader 对象正在使用的当前字符编码</li>
<li>EndOfStream：获取一个值，该值指示当前的流位置是否在流结尾，如果当前流位置位于流的末尾，则为 true；否则为 false。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//文件地址</span></span><br><span class="line"><span class="built_in">string</span> txtFilePath = <span class="string">&quot;D:\\TextReader.txt&quot;</span>;</span><br><span class="line"><span class="comment">//定义char数组</span></span><br><span class="line"><span class="built_in">char</span>[] charBuffer2 = <span class="keyword">new</span> <span class="built_in">char</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用FileStream类将文件文本数据变成流然后放入StreamReader构造函数中</span></span><br><span class="line"><span class="keyword">using</span> (FileStream stream = File.OpenRead(txtFilePath))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (StreamReader reader = <span class="keyword">new</span> StreamReader(stream))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//StreamReader.Read()方法</span></span><br><span class="line">        DisplayResultStringByUsingRead(reader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> (FileStream stream = File.OpenRead(txtFilePath))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用Encoding.ASCII来尝试下</span></span><br><span class="line">    <span class="keyword">using</span> (StreamReader reader = <span class="keyword">new</span> StreamReader(stream, Encoding.ASCII, <span class="literal">false</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//StreamReader.ReadBlock()方法</span></span><br><span class="line">        DisplayResultStringByUsingReadBlock(reader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试用文件定位直接得到StreamReader，顺便使用 Encoding.Default</span></span><br><span class="line"><span class="keyword">using</span> (StreamReader reader = <span class="keyword">new</span> StreamReader(txtFilePath, Encoding.Default, <span class="literal">false</span>, <span class="number">123</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//StreamReader.ReadLine()方法</span></span><br><span class="line">    DisplayResultStringByUsingReadLine(reader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以通过File.OpenText方法直接获取到StreamReader对象</span></span><br><span class="line"><span class="keyword">using</span> (StreamReader reader = File.OpenText(txtFilePath))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//StreamReader.ReadLine()方法</span></span><br><span class="line">    DisplayResultStringByUsingReadLine(reader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.ReadLine();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 使用StreamReader.Read()方法</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;reader&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DisplayResultStringByUsingRead</span>(<span class="params">StreamReader reader</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> readChar = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> result = <span class="built_in">string</span>.Empty;</span><br><span class="line">    <span class="keyword">while</span> ((readChar = reader.Read()) != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result += (<span class="built_in">char</span>)readChar;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;使用StreamReader.Read()方法得到Text文件中的数据为 : &#123;0&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 使用StreamReader.ReadBlock()方法</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;reader&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DisplayResultStringByUsingReadBlock</span>(<span class="params">StreamReader reader</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span>[] charBuffer = <span class="keyword">new</span> <span class="built_in">char</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">string</span> result = <span class="built_in">string</span>.Empty;</span><br><span class="line">    reader.ReadBlock(charBuffer, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; charBuffer.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result += charBuffer[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;使用StreamReader.ReadBlock()方法得到Text文件中前10个数据为 : &#123;0&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 使用StreamReader.ReadLine()方法</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;reader&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DisplayResultStringByUsingReadLine</span>(<span class="params">StreamReader reader</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">string</span> resultString = <span class="built_in">string</span>.Empty;</span><br><span class="line">    <span class="keyword">while</span> ((resultString = reader.ReadLine()) != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;使用StreamReader.Read()方法得到Text文件中第&#123;1&#125;行的数据为 : &#123;0&#125;&quot;</span>, resultString, i);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TextWriter"><a href="#TextWriter" class="headerlink" title="TextWriter"></a>TextWriter</h1><p>TextWriter是抽象基类，子类 StreamWriter 和 StringWriter，分别将字符写入流和字符串。 派生类必须实现 Write(Char) 方法，才能创建一个有用的实例 TextWriter。</p>
<h2 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h2><ul>
<li><p>TextWriter()：初始化 TextWriter 类的新实例。</p>
</li>
<li><p>TextWriter(IFormatProvider)：使用指定的格式提供程序初始化 TextWriter 类的新实例。</p>
<blockquote>
<p>使用此构造函数创建的实例，在调用 Write 和 WriteLine 方法时使用FormatProvider属性值，设置的区域性特定格式。</p>
</blockquote>
</li>
</ul>
<h2 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h2><ul>
<li><p>Encoding：当在派生类中重写时，返回用来写输出的该字符编码。</p>
</li>
<li><p>FormatProvider：获取控制格式设置的对象。</p>
</li>
<li><p>NewLine：获取或设置由当前 TextWriter 使用的行结束符字符串。</p>
</li>
</ul>
<h1 id="StreamWriter"><a href="#StreamWriter" class="headerlink" title="StreamWriter"></a>StreamWriter</h1><p>StreamWriter 以一种特定的编码向流中写入字符。 除非另外指定，否则默认为使用UTF8Encoding实例 。 UTF8Encoding实例在构造时没有字节顺序标记 (BOM) ，因此其 GetPreamble 方法返回一个空字节数组。 此构造函数的默认 UTF-8 编码对无效字节引发异常。 此行为不同于属性中的编码对象提供的行为 Encoding.UTF8 。 若要指定一个 BOM 并确定无效字节是否引发了异常，请使用接受编码对象作为参数的构造函数。</p>
<h2 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h2><ul>
<li><p>StreamWriter(Stream)：使用 UTF-8 编码及默认的缓冲区大小，为指定的流初始化 StreamWriter 类的新实例。</p>
</li>
<li><p>StreamWriter(Stream, Encoding)：使用指定的编码及默认的缓冲区大小，为指定的流初始化 StreamWriter 类的新实例。</p>
</li>
<li><p>StreamWriter (string path, bool append)：用默认编码和缓冲区大小，为指定的文件初始化 StreamWriter 类的一个新实例。</p>
<blockquote>
<p> 若要追加数据到该文件中，append为 true；若要覆盖该文件，append为 false。 如果指定的文件不存在，该参数无效，且构造函数将创建一个新文件。</p>
</blockquote>
</li>
</ul>
<h2 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h2><ul>
<li><p>AutoFlush：获取或设置一个值，该值指示 StreamWriter 在每次调用 Write(Char) 之后是否都将其缓冲区刷新到基础流。</p>
</li>
<li><p>BaseStream：获取同后备存储连接的基础流。</p>
</li>
<li><p>Encoding：获取在其中写入输出的 Encoding。</p>
</li>
<li><p>FormatProvider：获取控制格式设置的对象。</p>
</li>
<li><p>NewLine：获取或设置由当前 TextWriter 使用的行结束符字符串。</p>
</li>
</ul>
<h1 id="FileStream"><a href="#FileStream" class="headerlink" title="FileStream"></a>FileStream</h1><p>使用FileStream类读取、写入、打开和关闭文件系统上的文件，并操作其他与文件相关的操作系统句柄，包括管道、标准输入和标准输出。 可以使用 Read、 Write、 CopyTo和 Flush 方法执行同步操作，或使用 ReadAsync、 WriteAsync、 CopyToAsync和 FlushAsync 方法执行异步操作。 使用异步方法执行资源密集型文件操作，而不会阻止主线程。 </p>
<p>属性 IsAsync 检测文件句柄是否已异步打开。 使用具有 isAsync、 或 options 参数的构造函数创建FileStream类的实例时，useAsync可以指定此值。 当IsAsync属性为 true时，流利用重叠的 I&#x2F;O 以异步方式执行文件操作。 </p>
<p>当IsAsync属性为 false 并且你调用异步读取和写入操作时，UI 线程仍不会被阻止，但实际 I&#x2F;O 操作是同步执行的。</p>
<p>方法 Seek 支持对文件的随机访问。 Seek 允许将读&#x2F;写位置移动到文件中的任何位置。</p>
<p>当对象 FileStream 在其句柄上没有独占保留时，另一个线程可以同时访问文件句柄，并更改与文件句柄关联的操作系统文件指针的位置。 在这种情况下，对象中的 FileStream 缓存位置和缓冲区中的缓存数据可能会受到威胁。 对象 FileStream 定期对访问缓存缓冲区的方法执行检查，以确保操作系统的句柄位置与对象使用的 FileStream 缓存位置相同。</p>
<p>如果在调用 Read 方法时检测到句柄位置的意外更改，.NET Framework放弃缓冲区的内容，并从文件中再次读取流。 这可能会影响性能，具体取决于文件的大小以及可能影响文件流位置的任何其他进程。</p>
<p>如果在调用 Write 方法时检测到句柄位置的意外更改，则会丢弃缓冲区的内容并 IOException 引发异常。</p>
<h2 id="构造函数-3"><a href="#构造函数-3" class="headerlink" title="构造函数"></a>构造函数</h2><ul>
<li>FileStream(SafeFileHandle, FileAccess)：使用指定的读&#x2F;写权限为指定的文件句柄初始化 FileStream 类的新实例。<blockquote>
<p>SafeFileHandle<br>当前 FileStream 对象将封装的文件的文件句柄。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>FileAccess<br>枚举值的按位组合，它用于设置 FileStream 对象的 CanRead 和 CanWrite 属性。</p>
</blockquote>
<ul>
<li>FileStream(String, FileMode, FileAccess, FileShare, Int32, FileOptions):使用指定的路径、创建模式、读&#x2F;写和共享权限、其他 FileStreams 可以具有的对此文件的访问权限、缓冲区大小和附加文件选项初始化 FileStream 类的新实例。</li>
</ul>
<blockquote>
<p>String: 当前 FileStream 对象将封装的文件的相对路径或绝对路径。</p>
<p>FileMode: 用于确定文件的打开或创建方式的枚举值之一。</p>
<p>FileAccess: 枚举值的按位组合，这些枚举值确定 FileStream 对象访问文件的方式。 该常数还可以确定由 FileStream 对象的 CanRead 和 CanWrite 属性返回的值。 如果 path 指定磁盘文件，则 CanSeek 为 true。</p>
<p>FileShare: 枚举值的按位组合，这些枚举值确定进程共享文件的方式。</p>
<p>Int32: 一个大于零的正 Int32 值，表示缓冲区大小。 默认缓冲区大小为 4096<br>FileOptions: 枚举值的按位组合，它用于指定其他文件选项</p>
</blockquote>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ul>
<li><p>FileMode：指定操作系统打开文件的方式。</p>
<blockquote>
<p>Append: 若存在文件，则打开该文件并查找到文件尾，或者创建一个新文件。 FileMode.Append 只能与 FileAccess.Write 一起使用。 试图查找文件尾之前的位置时会引发 IOException 异常，并且任何试图读取的操作都会失败并引发 NotSupportedException 异常。</p>
<p>Create: 指定操作系统应创建新文件。 如果此文件已存在，则会将其覆盖。 这需要 Write 权限。<br>FileMode.Create 等效于这样的请求：如果文件不存在，则使用 CreateNew；否则使用 Truncate。 如果该文件已存在但为隐藏文件，则将引发 UnauthorizedAccessException异常。</p>
<p>CreateNew: 指定操作系统应创建新文件。 这需要 Write 权限。 如果文件已存在，则将引发 IOException异常。</p>
<p>Open: 指定操作系统应打开现有文件。 打开文件的能力取决于 FileAccess 枚举所指定的值。 如果文件不存在，引发一个 FileNotFoundException 异常。</p>
<p>OpenOrCreate: 指定操作系统应打开文件（如果文件存在）；否则，应创建新文件。 如果用 FileAccess.Read 打开文件，则需要 Read权限。 如果文件访问为 FileAccess.Write，则需要 Write权限。 如果用 FileAccess.ReadWrite 打开文件，则同时需要 Read 和 Write权限</p>
<p>Truncate: 指定操作系统应打开现有文件。 该文件被打开时，将被截断为零字节大小。 这需要 Write 权限。 尝试从使用 FileMode.Truncate 打开的文件中进行读取将导致 ArgumentException 异常。</p>
</blockquote>
</li>
<li><p>FileAccess: 定义文件的读取、写入或读&#x2F;写访问权限的常量。</p>
</li>
</ul>
<blockquote>
<p>Read: 对文件的读访问。 可从文件中读取数据。 与 Write 组合以进行读写访问。</p>
<p>ReadWrite: 对文件的读写访问权限。 可从文件读取数据和将数据写入文件。</p>
<p>Write: 文件的写访问。 可将数据写入文件。 与 Read 组合以进行读写访问。</p>
</blockquote>
<ul>
<li>FileShare: 包含用于控制其他 FileStream 对象对同一文件可以具有的访问类型的常数。</li>
</ul>
<blockquote>
<p>Delete: 允许随后删除文件。</p>
<p>Inheritable: 使文件句柄可由子进程继承。 Win32 不直接支持此功能。</p>
<p>None: 谢绝共享当前文件。 文件关闭前，打开该文件的任何请求（由此进程或另一进程发出的请求）都将失败。</p>
<p>Read: 允许随后打开文件读取。 如果未指定此标志，则文件关闭前，任何打开该文件以进行读取的请求（由此进程或另一进程发出的请求）都将失败。 但是，即使指定了此标志，仍可能需要附加权限才能够访问该文件。</p>
<p>ReadWrite: 允许随后打开文件读取或写入。 如果未指定此标志，则文件关闭前，任何打开该文件以进行读取或写入的请求（由此进程或另一进程发出）都将失败。 但是，即使指定了此标志，仍可能需要附加权限才能够访问该文件。</p>
<p>Write: 允许随后打开文件写入。 如果未指定此标志，则文件关闭前，任何打开该文件以进行写入的请求（由此进程或另一进过程发出的请求）都将失败。 但是，即使指定了此标志，仍可能需要附加权限才能够访问该文件。</p>
</blockquote>
<ul>
<li>FileOptions</li>
</ul>
<blockquote>
<p>Asynchronous: 指示文件可用于异步读取和写入</p>
<p>DeleteOnClose: 指示当不再使用某个文件时，自动删除该文件。</p>
<p>Encrypted: 指示文件是加密的，只能通过用于加密的同一用户帐户来解密。</p>
<p>None: 指示在生成 FileStream 对象时，不应使用其他选项。</p>
<p>RandomAccess: 指示随机访问文件。 系统可将此选项用作优化文件缓存的提示。</p>
<p>SequentialScan: 指示按从头到尾的顺序访问文件。 系统可将此选项用作优化文件缓存的提示。 如果应用程序移动用于随机访问的文件指针，可能不发生优化缓存，但仍然保证操作的正确性。 如果指定此标志，可提升某些案例中的性能。</p>
<p>WriteThrough: 指示系统应通过任何中间缓存、直接写入磁盘。</p>
</blockquote>
<blockquote>
<p>指定 FileOptions.SequentialScan 标志可以提高使用顺序访问读取大型文件的应用程序的性能。 对于主要按顺序读取大型文件，但偶尔跳过小范围字节的应用程序，性能提升可能更为明显。</p>
</blockquote>
<h2 id="属性-4"><a href="#属性-4" class="headerlink" title="属性"></a>属性</h2><ul>
<li><p>IsAsync：获取一个值，它指示 FileStream 是异步打开还是同步打开的。</p>
</li>
<li><p>Length：获取流的长度（以字节为单位）。</p>
</li>
<li><p>Name：获取 FileStream 中已打开的文件的绝对路径。</p>
</li>
<li><p>Position：获取或设置此流的当前位置。</p>
</li>
<li><p>SafeFileHandle：获取 SafeFileHandle 对象，它代表当前 FileStream 对象所封装的文件的操作系统文件句柄。</p>
</li>
</ul>
<h2 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h2><p>属于FileStream独有的方法</p>
<ul>
<li><p>FileSecurity GetAccessControl(FileStream)： 返回文件的安全信息。</p>
<blockquote>
<p>FileStream: 一个要从中获取安全信息的现有文件</p>
</blockquote>
</li>
<li><p>void SetAccessControl(FileSecurity fileSecurity): 和GetAccessControl很相似，ACL技术会在以后单独介绍</p>
</li>
<li><p>Lock (long position, long length);防止其他进程读取或写入 FileStream。</p>
</li>
</ul>
<blockquote>
<p> 这个Lock方法和线程中的Look关键字很不一样，它能够锁住文件中的某一部分，非常的强悍！用了这个方法我们能够精确锁定住我们需要锁住的文件的部分内容</p>
</blockquote>
<ul>
<li>void Unlock (long position,long length):正好和lock方法相反，对于文件部分的解锁</li>
</ul>
<h1 id="MemoryStream"><a href="#MemoryStream" class="headerlink" title="MemoryStream"></a>MemoryStream</h1><p>创建一个流，其后备存储为内存。</p>
<p>使用无符号字节数组创建的内存流提供不可调整大小的数据流。 使用字节数组时，既不能追加流，也不能收缩流，不过，根据传递到构造函数的参数，可以修改现有内容。 空内存流可调整大小，可以写入和读取。</p>
<p>由于MemoryStream是通过无符号字节数组组成的，可以说MemoryStream的性能可以算比较出色，所以它担当起了一些其他流进行数据交换时的中间工作，同时可降低应用程序中对临时缓冲区和临时文件的需要.</p>
<h2 id="构造函数-4"><a href="#构造函数-4" class="headerlink" title="构造函数"></a>构造函数</h2><ul>
<li>MemoryStream()：使用初始化为零的可扩展容量初始化 MemoryStream 类的新实例。</li>
</ul>
<blockquote>
<p>使用初始化为零的可扩展容量初始化 MemoryStream 类的新实例。</p>
<p>CanSeek属性CanRead和CanWrite属性都设置为 true。</p>
<p>使用 SetLength 该方法将长度设置为大于当前流的容量的值时，当前流的容量会自动增加。</p>
<p>此构造函数公开返回的基础流 GetBuffer 。</p>
</blockquote>
<ul>
<li>MemoryStream(Byte[])：基于指定的字节数组初始化 MemoryStream 类的无法调整大小的新实例。</li>
</ul>
<blockquote>
<p>基于指定的字节数组初始化 MemoryStream 类的无法调整大小的新实例。</p>
<p>CanSeek属性CanRead和CanWrite属性都设置为 true。 Capacity 设置为指定字节数组的长度。 可将新流写入，但不可调整大小。</p>
<p>流的长度不能设置为大于指定字节数组的初始长度的值;但是， (可以看到 SetLength) 截断流。</p>
<p>此构造函数不公开基础流。 GetBuffer throws UnauthorizedAccessException.</p>
</blockquote>
<ul>
<li>MemoryStream(Int32)：使用按指定要求初始化的可扩展容量初始化 MemoryStream 类的新实例。</li>
</ul>
<blockquote>
<p>使用按指定要求初始化的可扩展容量初始化 MemoryStream 类的新实例。</p>
<p>CanSeek属性CanRead和CanWrite属性都设置为 true。</p>
<p>使用 SetLength 此方法将长度设置为大于当前流的容量的值时，容量会自动增加。</p>
<p>此构造函数公开返回的基础流 GetBuffer</p>
</blockquote>
<ul>
<li>MemoryStream(Byte[], Int32, Int32, Boolean, Boolean)：在 MemoryStream 属性和调用 CanWrite 的能力按指定设置的状态下，基于字节数组的指定区域初始化 GetBuffer() 类的新实例。</li>
</ul>
<blockquote>
<p>和CanRead、CanSeek属性都设置为true。 将 Capacity 设置为 count。</p>
<p>可以将新流实例写入其中，但 Capacity 基础字节数组无法更改。 流的长度不能设置为大于指定字节数组的初始长度的值;</p>
</blockquote>
<h2 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h2><ul>
<li>virtual byte[] GetBuffer()： 返回从中创建此流的无符号字节的数组</li>
</ul>
<blockquote>
<p>请注意，缓冲区包含可能未使用的已分配字节。 例如，如果将字符串“test”写入 MemoryStream 对象，则返回 GetBuffer 的缓冲区长度为 256，而不是 4，未使用 252 个字节。 若要仅获取缓冲区中的数据，请使用 ToArray 该方法;但是， ToArray 会在内存中创建数据的副本。</p>
<p>这个方法使用时需要小心，因为这个方法返回无符号字节数组，也就是说，即使我只输入几个字符例如”HellowWorld”我们只希望返回11个数据就行，可是这个方法会把整个缓冲区的数据，包括那些已经分配但是实际上没有用到的字节数据都返回出来;</p>
</blockquote>
<ul>
<li>virtual void WriteTo(Stream stream): 将此内存流的整个内容写入到另一个流中。</li>
</ul>
<blockquote>
<p>memoryStream常用起中间流的作用，所以在处理完后将内存流写入其他流中;</p>
</blockquote>
<h1 id="BufferedStream"><a href="#BufferedStream" class="headerlink" title="BufferedStream"></a>BufferedStream</h1><p>将缓冲层添加到另一个流上的读取和写入操作。<br>BufferedStream能够实现流的缓存，换句话说也就是在内存中能够缓存一定的数据而不是</p>
<p>时时给系统带来负担，同时BufferedStream可以对缓存中的数据进行写入或是读取，所以对流的性能带来一定的提升，但是无法同时进行读取或写入工作，如果不使用缓冲区也行，BufferedStream能够保证不用缓冲区时不会降低因缓冲区带来的读取或写入性能的下降。</p>
<p>为什么MemoryStream 同样也是在内存中对流进行操作，和BufferedStream有什么区别呢？BufferedStream并不是将所有内容都存放到内存中，而MemoryStream则是。BufferedStream必须跟其他流如FileStream结合使用，而MemoryStream则不用，聪明的你肯定能够想到，BufferedStream必然类似于一个流的包装类，对流进行”缓存功能的扩展包装”，所以BufferedStream的优势不仅体现在其原有的缓存功能上，更体现在如何帮助原有类实现其功能的扩展层面上。</p>
<h1 id="NetworkStream"><a href="#NetworkStream" class="headerlink" title="NetworkStream"></a>NetworkStream</h1><p>如果服务器和客户端之间基于TCP连接的，他们之间能够依靠一个稳定的字节流进行相互传输信息，这也是</p>
<p>NetworkStream的最关键的作用，有了这个神奇的协议，NetWorkStream便能向其他流一样在网络中（进行点对点的传输）</p>
<blockquote>
<ul>
<li><p>NetworkStream只能用在具有Tcp&#x2F;IP协议之中，如果用在UDP中编译不报错，会报异常</p>
</li>
<li><p>NetworkStream 是面向连接的</p>
</li>
<li><p>在网络中利用流的形式传递信息</p>
</li>
<li><p>必须借助Socket (也称之为流式socket)，或使用一些返回的返回值，例如TcpClient类的GetStream方法</p>
</li>
<li><p>用法和普通流方法几乎一模一样，但具有特殊性</p>
</li>
</ul>
</blockquote>
<p>可以在类实例 NetworkStream 上同时执行读取和写入操作，而无需同步。 只要写入操作有一个唯一线程，读取操作有一个唯一线程，读取和写入线程之间就不会有交叉干扰，也不需要同步。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/06/15/asp-net-core/Asp-Net-Core-%E8%AF%BB%E5%8F%96Request-Body%E7%9A%84%E6%AD%A3%E5%8F%96%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/15/asp-net-core/Asp-Net-Core-%E8%AF%BB%E5%8F%96Request-Body%E7%9A%84%E6%AD%A3%E5%8F%96%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">Asp.Net Core 读取Request.Body的正取方式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-15 11:10:31" itemprop="dateCreated datePublished" datetime="2023-06-15T11:10:31+08:00">2023-06-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-27 10:08:42" itemprop="dateModified" datetime="2023-06-27T10:08:42+08:00">2023-06-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="常用读取方式"><a href="#常用读取方式" class="headerlink" title="常用读取方式"></a>常用读取方式</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">ActionExecutingContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在ASP.NET Core中Request Body是Stream的形式</span></span><br><span class="line">    StreamReader stream = <span class="keyword">new</span> StreamReader(context.HttpContext.Request.Body);</span><br><span class="line">    <span class="built_in">string</span> body = stream.ReadToEnd();</span><br><span class="line">    _logger.LogDebug(<span class="string">&quot;body content:&quot;</span> + body);</span><br><span class="line">    <span class="keyword">base</span>.OnActionExecuting(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>直接报一个这个错System.InvalidOperationException: Synchronous operations are disallowed. Call ReadAsync or set AllowSynchronousIO to true instead.大致的意思就是同步操作不被允许，请使用ReadAsync的方式或设置AllowSynchronousIO为true。</p>
<h2 id="同步读取"><a href="#同步读取" class="headerlink" title="同步读取"></a>同步读取</h2><p>如何设置AllowSynchronousIO的值。第一种方式是在ConfigureServices中配置，操作如下</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">services.Configure&lt;KestrelServerOptions&gt;(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.AllowSynchronousIO = <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>还有一种方式，可以不用在ConfigureServices中设置，通过IHttpBodyControlFeature的方式设置，具体如下</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">ActionExecutingContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> syncIOFeature = context.HttpContext.Features.Get&lt;IHttpBodyControlFeature&gt;();</span><br><span class="line">    <span class="keyword">if</span> (syncIOFeature != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        syncIOFeature.AllowSynchronousIO = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StreamReader stream = <span class="keyword">new</span> StreamReader(context.HttpContext.Request.Body);</span><br><span class="line">    <span class="built_in">string</span> body = stream.ReadToEnd();</span><br><span class="line">    _logger.LogDebug(<span class="string">&quot;body content:&quot;</span> + body);</span><br><span class="line">    <span class="keyword">base</span>.OnActionExecuting(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式同样有效，通过这种方式操作，不需要每次读取Body的时候都去设置，只要在准备读取Body之前设置一次即可。这两种方式都是去设置AllowSynchronousIO为true，但是我们需要思考一点，微软为何设置AllowSynchronousIO默认为false，说明微软并不希望我们去同步读取Body。通过查找资料得出了这么一个结论</p>
<blockquote>
<p>Kestrel：默认情况下禁用 AllowSynchronousIO（同步IO），线程不足会导致应用崩溃，而同步I&#x2F;O API（例如HttpRequest.Body.Read）是导致线程不足的常见原因。</p>
</blockquote>
<h2 id="异步读取"><a href="#异步读取" class="headerlink" title="异步读取"></a>异步读取</h2><p>通过上面我们了解到微软并不希望我们通过设置AllowSynchronousIO的方式去操作，因为会影响性能。那我们可以使用异步的方式去读取，这里所说的异步方式其实就是使用Stream自带的异步方法去读取，如下所示</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">ActionExecutingContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StreamReader stream = <span class="keyword">new</span> StreamReader(context.HttpContext.Request.Body);</span><br><span class="line">    <span class="built_in">string</span> body = stream.ReadToEndAsync().GetAwaiter().GetResult();</span><br><span class="line">    _logger.LogDebug(<span class="string">&quot;body content:&quot;</span> + body);</span><br><span class="line">    <span class="keyword">base</span>.OnActionExecuting(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ASP.NET Core中许多操作都是异步操作，甚至是过滤器或中间件都可以直接返回Task类型的方法，因此我们可以直接使用异步操作</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">async</span> Task <span class="title">OnActionExecutionAsync</span>(<span class="params">ActionExecutingContext context, ActionExecutionDelegate next</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StreamReader stream = <span class="keyword">new</span> StreamReader(context.HttpContext.Request.Body);</span><br><span class="line">    <span class="built_in">string</span> body = <span class="keyword">await</span> stream.ReadToEndAsync();</span><br><span class="line">    _logger.LogDebug(<span class="string">&quot;body content:&quot;</span> + body);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种方式的操作优点是不需要额外设置别的，只是通过异步方法读取即可，也是我们比较推荐的做法。</p>
<h1 id="重复读取"><a href="#重复读取" class="headerlink" title="重复读取"></a>重复读取</h1><p>上面我们演示了使用同步方式和异步方式读取RequestBody，但是这样真的就可以了吗？其实并不行，这种方式每次请求只能读取一次正确的Body结果，如果继续对RequestBody这个Stream进行读取，将读取不到任何内容，首先来举个例子</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">async</span> Task <span class="title">OnActionExecutionAsync</span>(<span class="params">ActionExecutingContext context, ActionExecutionDelegate next</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StreamReader stream = <span class="keyword">new</span> StreamReader(context.HttpContext.Request.Body);</span><br><span class="line">    <span class="built_in">string</span> body = <span class="keyword">await</span> stream.ReadToEndAsync();</span><br><span class="line">    _logger.LogDebug(<span class="string">&quot;body content:&quot;</span> + body);</span><br><span class="line"></span><br><span class="line">    StreamReader stream2 = <span class="keyword">new</span> StreamReader(context.HttpContext.Request.Body);</span><br><span class="line">    <span class="built_in">string</span> body2 = <span class="keyword">await</span> stream2.ReadToEndAsync();</span><br><span class="line">    _logger.LogDebug(<span class="string">&quot;body2 content:&quot;</span> + body2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中body里有正确的RequestBody的结果，但是body2中是空字符串。</p>
<p>那到底该如何解决呢？也很简单，微软知道自己刨下了坑，自然给我们提供了解决办法，用起来也很简单就是加EnableBuffering</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">async</span> Task <span class="title">OnActionExecutionAsync</span>(<span class="params">ActionExecutingContext context, ActionExecutionDelegate next</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//操作Request.Body之前加上EnableBuffering即可</span></span><br><span class="line">    context.HttpContext.Request.EnableBuffering();</span><br><span class="line"></span><br><span class="line">    StreamReader stream = <span class="keyword">new</span> StreamReader(context.HttpContext.Request.Body);</span><br><span class="line">    <span class="built_in">string</span> body = <span class="keyword">await</span> stream.ReadToEndAsync();</span><br><span class="line">    _logger.LogDebug(<span class="string">&quot;body content:&quot;</span> + body);</span><br><span class="line"></span><br><span class="line">    context.HttpContext.Request.Body.Seek(<span class="number">0</span>, SeekOrigin.Begin);</span><br><span class="line">    StreamReader stream2 = <span class="keyword">new</span> StreamReader(context.HttpContext.Request.Body);</span><br><span class="line">    <span class="comment">//注意这里！！！我已经使用了同步读取的方式</span></span><br><span class="line">    <span class="built_in">string</span> body2 = stream2.ReadToEnd();</span><br><span class="line">    context.HttpContext.Request.Body.Seek(<span class="number">0</span>, SeekOrigin.Begin);</span><br><span class="line">    _logger.LogDebug(<span class="string">&quot;body2 content:&quot;</span> + body2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过添加Request.EnableBuffering()我们就可以重复的读取RequestBody了，看名字我们可以大概的猜出来，他是和缓存RequestBody有关，需要注意的是Request.EnableBuffering()要加在准备读取RequestBody之前才有效果，否则将无效，而且每次请求只需要添加一次即可。而且大家看到了我第二次读取Body的时候使用了同步的方式去读取的RequestBody，是不是很神奇，待会的时候我们会从源码的角度分析这个问题。</p>
<h1 id="源码探究"><a href="#源码探究" class="headerlink" title="源码探究"></a>源码探究</h1><p>上面我们看到了通过StreamReader的ReadToEnd同步读取Request.Body需要设置AllowSynchronousIO为true才能操作，但是使用StreamReader的ReadToEndAsync方法却可以直接操作。</p>
<h2 id="StreamReader和Stream的关系"><a href="#StreamReader和Stream的关系" class="headerlink" title="StreamReader和Stream的关系"></a>StreamReader和Stream的关系</h2><p>我们看到了都是通过操作StreamReader的方法即可，那关我Request.Body啥事，别急咱们先看一看这里的操作，首先来大致看下ReadToEnd的实现了解一下StreamReader到底和Stream有啥关联，找到ReadToEnd方法</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ReadToEnd</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    ThrowIfDisposed();</span><br><span class="line">    CheckAsyncTaskInProgress();</span><br><span class="line">    <span class="comment">// 调用ReadBuffer，然后从charBuffer中提取数据。 </span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(_charLen - _charPos);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//循环拼接读取内容</span></span><br><span class="line">        sb.Append(_charBuffer, _charPos, _charLen - _charPos);</span><br><span class="line">        _charPos = _charLen; </span><br><span class="line">        <span class="comment">//读取buffer，这是核心操作</span></span><br><span class="line">        ReadBuffer();</span><br><span class="line">    &#125; <span class="keyword">while</span> (_charLen &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//返回读取内容</span></span><br><span class="line">    <span class="keyword">return</span> sb.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这段源码我们了解到了这么个信息，一个是StreamReader的ReadToEnd其实本质是通过循环读取ReadBuffer然后通过StringBuilder去拼接读取的内容，核心是读取ReadBuffer方法，由于代码比较多，我们找到大致呈现一下核心操作</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_checkPreamble)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//通过这里我们可以知道本质就是使用要读取的Stream里的Read方法</span></span><br><span class="line">    <span class="built_in">int</span> len = _stream.Read(_byteBuffer, _bytePos, _byteBuffer.Length - _bytePos);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_byteLen &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _charLen += _decoder.GetChars(_byteBuffer, <span class="number">0</span>, _byteLen, _charBuffer, _charLen);</span><br><span class="line">            _bytePos = _byteLen = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _charLen;</span><br><span class="line">    &#125;</span><br><span class="line">    _byteLen += len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//通过这里我们可以知道本质就是使用要读取的Stream里的Read方法</span></span><br><span class="line">    _byteLen = _stream.Read(_byteBuffer, <span class="number">0</span>, _byteBuffer.Length);</span><br><span class="line">    <span class="keyword">if</span> (_byteLen == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _charLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码我们可以了解到StreamReader其实是工具类，只是封装了对Stream的原始操作，简化我们的代码ReadToEnd方法本质是读取Stream的Read方法。接下来我们看一下ReadToEndAsync方法的具体实现</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">ReadToEndAsync</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (GetType() != <span class="keyword">typeof</span>(StreamReader))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">base</span>.ReadToEndAsync();</span><br><span class="line">    &#125;</span><br><span class="line">    ThrowIfDisposed();</span><br><span class="line">    CheckAsyncTaskInProgress();</span><br><span class="line">    <span class="comment">//本质是ReadToEndAsyncInternal方法</span></span><br><span class="line">    Task&lt;<span class="built_in">string</span>&gt; task = ReadToEndAsyncInternal();</span><br><span class="line">    _asyncReadTask = task;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">ReadToEndAsyncInternal</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//也是循环拼接读取的内容</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(_charLen - _charPos);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> tmpCharPos = _charPos;</span><br><span class="line">        sb.Append(_charBuffer, tmpCharPos, _charLen - tmpCharPos);</span><br><span class="line">        _charPos = _charLen; </span><br><span class="line">        <span class="comment">//核心操作是ReadBufferAsync方法</span></span><br><span class="line">        <span class="keyword">await</span> ReadBufferAsync(CancellationToken.None).ConfigureAwait(<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (_charLen &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> sb.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这个我们可以看到核心操作是ReadBufferAsync方法，代码比较多我们同样看一下核心实现</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">byte</span>[] tmpByteBuffer = _byteBuffer;</span><br><span class="line"><span class="comment">//Stream赋值给tmpStream </span></span><br><span class="line">Stream tmpStream = _stream;</span><br><span class="line"><span class="keyword">if</span> (_checkPreamble)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> tmpBytePos = _bytePos;</span><br><span class="line">    <span class="comment">//本质是调用Stream的ReadAsync方法</span></span><br><span class="line">    <span class="built_in">int</span> len = <span class="keyword">await</span> tmpStream.ReadAsync(<span class="keyword">new</span> Memory&lt;<span class="built_in">byte</span>&gt;(tmpByteBuffer, tmpBytePos, tmpByteBuffer.Length - tmpBytePos), cancellationToken).ConfigureAwait(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_byteLen &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _charLen += _decoder.GetChars(tmpByteBuffer, <span class="number">0</span>, _byteLen, _charBuffer, _charLen);</span><br><span class="line">            _bytePos = <span class="number">0</span>; _byteLen = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _charLen;</span><br><span class="line">    &#125;</span><br><span class="line">    _byteLen += len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//本质是调用Stream的ReadAsync方法</span></span><br><span class="line">    _byteLen = <span class="keyword">await</span> tmpStream.ReadAsync(<span class="keyword">new</span> Memory&lt;<span class="built_in">byte</span>&gt;(tmpByteBuffer), cancellationToken).ConfigureAwait(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (_byteLen == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _charLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面代码我可以了解到StreamReader的本质就是读取Stream的包装，核心方法还是来自Stream本身。我们之所以大致介绍了StreamReader类，就是为了给大家呈现出StreamReader和Stream的关系，否则怕大家误解这波操作是StreamReader的里的实现，而不是Request.Body的问题，其实并不是这样的所有的一切都是指向Stream的Request的Body就是Stream这个大家可以自己查看一下，了解到这一步我们就可以继续了。</p>
<h1 id="HttpRequest的Body"><a href="#HttpRequest的Body" class="headerlink" title="HttpRequest的Body"></a>HttpRequest的Body</h1><p>上面我们说到了Request的Body本质就是Stream，Stream本身是抽象类，所以Request.Body是Stream的实现类。默认情况下Request.Body的是HttpRequestStream的实例，我们这里说了是默认，因为它是可以改变的，我们一会再说。我们从上面StreamReader的结论中得到ReadToEnd本质还是调用的Stream的Read方法，即这里的HttpRequestStream的Read方法，我们来看一下具体实现</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">Read</span>(<span class="params"><span class="built_in">byte</span>[] buffer, <span class="built_in">int</span> offset, <span class="built_in">int</span> count</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//知道同步读取Body为啥报错了吧</span></span><br><span class="line">    <span class="keyword">if</span> (!_bodyControl.AllowSynchronousIO)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(CoreStrings.SynchronousReadsDisallowed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//本质是调用ReadAsync</span></span><br><span class="line">    <span class="keyword">return</span> ReadAsync(buffer, offset, count).GetAwaiter().GetResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这段代码我们就可以知道了为啥在不设置AllowSynchronousIO为true的情下读取Body会抛出异常了吧，这个是程序级别的控制，而且我们还了解到Read的本质还是在调用ReadAsync异步方法</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> ValueTask&lt;<span class="built_in">int</span>&gt; <span class="title">ReadAsync</span>(<span class="params">Memory&lt;<span class="built_in">byte</span>&gt; destination, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ReadAsyncWrapper(destination, cancellationToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReadAsync本身并无特殊限制，所以直接操作ReadAsync不会存在类似Read的异常。</p>
<blockquote>
<p>通过这个我们得出了结论Request.Body即HttpRequestStream的同步读取Read会抛出异常，而异步读取ReadAsync并不会抛出异常只和HttpRequestStream的Read方法本身存在判断AllowSynchronousIO的值有关系。</p>
</blockquote>
<h1 id="EnableBuffering神奇的背后"><a href="#EnableBuffering神奇的背后" class="headerlink" title="EnableBuffering神奇的背后"></a>EnableBuffering神奇的背后</h1><p>我们在上面的示例中看到了，如果不添加EnableBuffering的话直接设置RequestBody的Position会报NotSupportedException这么一个错误，而且加了它之后我居然可以直接使用同步的方式去读取RequestBody，首先我们来看一下为啥会报错，我们从上面的错误了解到错误来自于HttpRequestStream这个类，上面我们也说了这个类继承了Stream抽象类,通过源码我们可以看到如下相关代码</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不能使用Seek操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> CanSeek =&gt; <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//允许读</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> CanRead =&gt; <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//不允许写</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> CanWrite =&gt; <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//不能获取长度</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">long</span> Length =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> NotSupportedException();</span><br><span class="line"><span class="comment">//不能读写Position</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">long</span> Position</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> NotSupportedException();</span><br><span class="line">    <span class="keyword">set</span> =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> NotSupportedException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不能使用Seek方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">long</span> <span class="title">Seek</span>(<span class="params"><span class="built_in">long</span> offset, SeekOrigin origin</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NotSupportedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相信通过这些我们可以清楚的看到针对HttpRequestStream的设置或者写相关的操作是不被允许的，这也是为啥我们上面直接通过Seek设置Position的时候为啥会报错，还有一些其他操作的限制，总之默认是不希望我们对HttpRequestStream做过多的操作，特别是设置或者写相关的操作。但是我们使用EnableBuffering的时候却没有这些问题，究竟是为什么?接下来我们要揭开它的什么面纱了。首先我们从Request.EnableBuffering()这个方法入手</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 确保Request.Body可以被多次读取</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;request&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EnableBuffering</span>(<span class="params"><span class="keyword">this</span> HttpRequest request</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    BufferingHelper.EnableRewind(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认内存中可缓存的大小为30K,超过这个大小将会被存储到磁盘</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">const</span> <span class="built_in">int</span> DefaultBufferThreshold = <span class="number">1024</span> * <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 这个方法也是HttpRequest扩展方法</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpRequest <span class="title">EnableRewind</span>(<span class="params"><span class="keyword">this</span> HttpRequest request, <span class="built_in">int</span> bufferThreshold = DefaultBufferThreshold, <span class="built_in">long</span>? bufferLimit = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (request == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(request));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先获取Request Body</span></span><br><span class="line">    <span class="keyword">var</span> body = request.Body;</span><br><span class="line">    <span class="comment">//默认情况Body是HttpRequestStream这个类CanSeek是false所以肯定会执行到if逻辑里面</span></span><br><span class="line">    <span class="keyword">if</span> (!body.CanSeek)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//实例化了FileBufferingReadStream这个类，看来这是关键所在</span></span><br><span class="line">        <span class="keyword">var</span> fileStream = <span class="keyword">new</span> FileBufferingReadStream(body, bufferThreshold,bufferLimit,AspNetCoreTempDirectory.TempDirectoryFactory);</span><br><span class="line">        <span class="comment">//赋值给Body，也就是说开启了EnableBuffering之后Request.Body类型将会是FileBufferingReadStream</span></span><br><span class="line">        request.Body = fileStream;</span><br><span class="line">        <span class="comment">//这里要把fileStream注册给Response便于释放</span></span><br><span class="line">        request.HttpContext.Response.RegisterForDispose(fileStream);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面这段源码实现中我们可以大致得到两个结论</p>
<ul>
<li>BufferingHelper的EnableRewind方法也是HttpRequest的扩展方法，可以直接通过Request.EnableRewind的形式调用，效果等同于调用Request.EnableBuffering因为EnableBuffering也是调用的EnableRewind</li>
<li>启用了EnableBuffering这个操作之后实际上会使用FileBufferingReadStream替换掉默认的HttpRequestStream，所以后续处理RequestBody的操作将会是FileBufferingReadStream实例</li>
</ul>
<p>通过上面的分析我们也清楚的看到了，核心操作在于FileBufferingReadStream这个类，而且从名字也能看出来它肯定是也继承了Stream抽象类</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇文章篇幅比较多，如果你想深入的研究相关逻辑，希望本文能给你带来一些阅读源码的指导。为了防止大家深入文章当中而忘记了具体的流程逻辑，在这里我们就大致的总结一下关于正确读取RequestBody的全部结论</p>
<ul>
<li>首先关于同步读取Request.Body由于默认的RequestBody的实现是HttpRequestStream，但是HttpRequestStream在重写Read方法的时候会判断是否开启AllowSynchronousIO，如果未开启则直接抛出异常。但是HttpRequestStream的ReadAsync方法并无这种限制，所以使用异步方式的读取RequestBody并无异常。</li>
<li>虽然通过设置AllowSynchronousIO或使用ReadAsync的方式我们可以读取RequestBody，但是RequestBody无法重复读取，这是因为HttpRequestStream的Position和Seek都是不允许进行修改操作的，设置了会直接抛出异常。为了可以重复读取，我们引入了Request的扩展方法EnableBuffering通过这个方法我们可以重置读取位置来实现RequestBody的重复读取。</li>
<li>关于开启EnableBuffering方法每次请求设置一次即可，即在准备读取RequestBody之前设置。其本质其实是使用FileBufferingReadStream代替默认RequestBody的默认类型HttpRequestStream，这样我们在一次Http请求中操作Body的时候其实是操作FileBufferingReadStream，这个类重写Stream的时候Position和Seek都是可以设置的，这样我们就实现了重复读取。</li>
<li>FileBufferingReadStream带给我们的不仅仅是可重复读取，还增加了对RequestBody的缓存功能，使得我们在一次请求中重复读取RequestBody的时候可以在Buffer里直接获取缓存内容而Buffer本身是一个MemoryStream。当然我们也可以自己实现一套逻辑来替换Body，只要我们重写的时候让这个Stream支持重置读取位置即可。</li>
</ul>
<p>摘抄 yi念之间 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/wucy/p/14699717.html">原文地址</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/06/13/asp-net-core/%E5%9C%A8Asp-Net-Core%E4%B8%AD%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/13/asp-net-core/%E5%9C%A8Asp-Net-Core%E4%B8%AD%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">在Asp.Net Core中上传文件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-13 11:25:44" itemprop="dateCreated datePublished" datetime="2023-06-13T11:25:44+08:00">2023-06-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-27 11:17:10" itemprop="dateModified" datetime="2023-06-27T11:17:10+08:00">2023-06-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>ASP.NET Core 支持使用缓冲模型绑定（针对较小文件）和无缓冲流式传输（针对较大文件）上传一个或多个文件。</p>
<h1 id="小型和大型文件"><a href="#小型和大型文件" class="headerlink" title="小型和大型文件"></a>小型和大型文件</h1><p>小型和大型文件的定义取决于可用的计算资源。 应用应对存储方法进行基准测试，以确保它可以处理预期的大小。 基准内存、CPU、磁盘和数据库性能。</p>
<p>虽然无法针对部署的“小”与“大”提供特定边界，但以下是 AspNetCore 针对 FormOptions 的一些相关默认值：</p>
<ul>
<li>默认情况下， HttpRequest.Form 不会缓冲整个请求正文 (BufferBody) ，但会缓冲包含的任何多部分表单文件。</li>
<li>MultipartBodyLengthLimit 是缓冲表单文件的最大大小，默认值为 128MB。</li>
<li>MemoryBufferThreshold 指示在转换为磁盘上的缓冲区文件之前，内存中的文件缓冲量，默认为 64KB。 MemoryBufferThreshold 充当小型和大型文件之间的边界，这些文件根据应用资源和方案而引发或</li>
</ul>
<h1 id="文件上传方案"><a href="#文件上传方案" class="headerlink" title="文件上传方案"></a>文件上传方案</h1><p>缓冲和流式传输是上传文件的两种常见方法。</p>
<p><em><strong>缓冲</strong></em></p>
<p>将整个文件读入 IFormFile。 IFormFile 是用于处理或保存文件的文件的 C# 表示形式。</p>
<p>文件上传使用的磁盘和内存取决于并发文件上传的数量和大小。 如果应用尝试缓冲过多上传，站点就会在内存或磁盘空间不足时崩溃。 如果文件上传的大小或频率会消耗应用资源，请使用流式传输。</p>
<p>会将大于 64 KB 的所有单个缓冲文件从内存移到磁盘的临时文件。</p>
<p>较大请求的临时文件将写入环境变量中 ASPNETCORE_TEMP 名为 的位置。 如果未 ASPNETCORE_TEMP 定义 ，则文件将写入当前用户的临时文件夹。</p>
<p><strong>流式处理</strong></p>
<p>从多部分请求收到文件，然后应用直接处理或保存它。 流式传输无法显著提高性能。 流式传输可降低上传文件时对内存或磁盘空间的需求。</p>
<h1 id="通过缓冲的模型绑定将小型文件上传到物理存储"><a href="#通过缓冲的模型绑定将小型文件上传到物理存储" class="headerlink" title="通过缓冲的模型绑定将小型文件上传到物理存储"></a>通过缓冲的模型绑定将小型文件上传到物理存储</h1><p>要上传小文件，请使用多部分窗体或使用 JavaScript 构造 POST 请求。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">AJAXSubmit</span> (oFormElement) &#123;</span><br><span class="line">    <span class="keyword">var</span> oReq = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    oReq.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123; </span><br><span class="line">    oFormElement.<span class="property">elements</span>.<span class="title function_">namedItem</span>(<span class="string">&quot;result&quot;</span>).<span class="property">value</span> = </span><br><span class="line">      <span class="string">&#x27;Result: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">status</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">statusText</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    oReq.<span class="title function_">open</span>(<span class="string">&quot;post&quot;</span>, oFormElement.<span class="property">action</span>);</span><br><span class="line">    oReq.<span class="title function_">send</span>(<span class="keyword">new</span> <span class="title class_">FormData</span>(oFormElement));</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>如下示例中：</p>
<ul>
<li>循环访问一个或多个上传的文件。</li>
<li>使用 Path.GetTempFileName 返回文件的完整路径，包括文件名称。</li>
<li>使用应用生成的文件名将文件保存到本地文件系统。</li>
<li>返回上传的文件的总数量和总大小。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">OnPostUploadAsync</span>(<span class="params">List&lt;IFormFile&gt; files</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">long</span> size = files.Sum(f =&gt; f.Length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> formFile <span class="keyword">in</span> files)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (formFile.Length &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> filePath = Path.GetTempFileName();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> stream = System.IO.File.Create(filePath))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> formFile.CopyToAsync(stream);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process uploaded files</span></span><br><span class="line">    <span class="comment">// Don&#x27;t rely on or trust the FileName property without validation.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Ok(<span class="keyword">new</span> &#123; count = files.Count, size &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>使用 Path.GetRandomFileName 生成文件名（不含路径）。 在下面的示例中，从配置获取路径：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> formFile <span class="keyword">in</span> files)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (formFile.Length &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> filePath = Path.Combine(_config[<span class="string">&quot;StoredFilesPath&quot;</span>], </span><br><span class="line">            Path.GetRandomFileName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> stream = System.IO.File.Create(filePath))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> formFile.CopyToAsync(stream);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传递给 FileStream 的路径必须包含文件名。 如果未提供文件名，则会在运行时引发 UnauthorizedAccessException。</p>
<p>使用 IFormFile 技术上传的文件在处理之前会缓冲在内存中或服务器的磁盘中。 在操作方法中，IFormFile 内容可作为 Stream 访问。 除本地文件系统之外，还可以将文件保存到网络共享或文件存储服务，如 Azure Blob 存储。</p>
<blockquote>
<p>如果在未删除先前临时文件的情况下创建了 65,535 个以上的文件，则 Path.GetTempFileName 将抛出一个 IOException。 65,535 个文件限制是每个服务器的限制。 有关 Windows 操作系统上的此限制的详细信息，请参阅以下主题中的说明：</p>
<ul>
<li>GetTempFileNameA 函数</li>
<li>GetTempFileName</li>
</ul>
</blockquote>
<h1 id="使用缓冲的模型绑定将小型文件上传到数据库"><a href="#使用缓冲的模型绑定将小型文件上传到数据库" class="headerlink" title="使用缓冲的模型绑定将小型文件上传到数据库"></a>使用缓冲的模型绑定将小型文件上传到数据库</h1><p>要使用实体框架将二进制文件数据存储在数据库中，请在实体上定义 Byte 数组属性：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AppFile</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">byte</span>[] Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为包括 IFormFile 的类指定页模型属性：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BufferedSingleFileUploadDbModel</span> : <span class="title">PageModel</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    [<span class="meta">BindProperty</span>]</span><br><span class="line">    <span class="keyword">public</span> BufferedSingleFileUploadDb FileUpload &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BufferedSingleFileUploadDb</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Required</span>]</span><br><span class="line">    [<span class="meta">Display(Name=<span class="string">&quot;File&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> IFormFile FormFile &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将窗体发布到服务器后，将 IFormFile 复制到流，并将它作为字节数组保存在数据库中。 在下面的示例中，_dbContext 存储应用的数据库上下文：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">OnPostUploadAsync</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> memoryStream = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> FileUpload.FormFile.CopyToAsync(memoryStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Upload the file if less than 2 MB</span></span><br><span class="line">        <span class="keyword">if</span> (memoryStream.Length &lt; <span class="number">2097152</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> file = <span class="keyword">new</span> AppFile()</span><br><span class="line">            &#123;</span><br><span class="line">                Content = memoryStream.ToArray()</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            _dbContext.File.Add(file);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">await</span> _dbContext.SaveChangesAsync();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ModelState.AddModelError(<span class="string">&quot;File&quot;</span>, <span class="string">&quot;The file is too large.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Page();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="通过流式传输上传大型文件"><a href="#通过流式传输上传大型文件" class="headerlink" title="通过流式传输上传大型文件"></a>通过流式传输上传大型文件</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">UploadDatabase</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!MultipartRequestHelper.IsMultipartContentType(Request.ContentType))</span><br><span class="line">    &#123;</span><br><span class="line">        ModelState.AddModelError(<span class="string">&quot;File&quot;</span>, </span><br><span class="line">            <span class="string">$&quot;The request couldn&#x27;t be processed (Error 1).&quot;</span>);</span><br><span class="line">        <span class="comment">// Log error</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BadRequest(ModelState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Accumulate the form data key-value pairs in the request (formAccumulator).</span></span><br><span class="line">    <span class="keyword">var</span> formAccumulator = <span class="keyword">new</span> KeyValueAccumulator();</span><br><span class="line">    <span class="keyword">var</span> trustedFileNameForDisplay = <span class="built_in">string</span>.Empty;</span><br><span class="line">    <span class="keyword">var</span> untrustedFileNameForStorage = <span class="built_in">string</span>.Empty;</span><br><span class="line">    <span class="keyword">var</span> streamedFileContent = Array.Empty&lt;<span class="built_in">byte</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> boundary = MultipartRequestHelper.GetBoundary(</span><br><span class="line">        MediaTypeHeaderValue.Parse(Request.ContentType),</span><br><span class="line">        _defaultFormOptions.MultipartBoundaryLengthLimit);</span><br><span class="line">    <span class="keyword">var</span> reader = <span class="keyword">new</span> MultipartReader(boundary, HttpContext.Request.Body);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> section = <span class="keyword">await</span> reader.ReadNextSectionAsync();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (section != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> hasContentDispositionHeader = </span><br><span class="line">            ContentDispositionHeaderValue.TryParse(</span><br><span class="line">                section.ContentDisposition, <span class="keyword">out</span> <span class="keyword">var</span> contentDisposition);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasContentDispositionHeader)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (MultipartRequestHelper</span><br><span class="line">                .HasFileContentDisposition(contentDisposition))</span><br><span class="line">            &#123;</span><br><span class="line">                untrustedFileNameForStorage = contentDisposition.FileName.Value;</span><br><span class="line">                <span class="comment">// Don&#x27;t trust the file name sent by the client. To display</span></span><br><span class="line">                <span class="comment">// the file name, HTML-encode the value.</span></span><br><span class="line">                trustedFileNameForDisplay = WebUtility.HtmlEncode(</span><br><span class="line">                        contentDisposition.FileName.Value);</span><br><span class="line"></span><br><span class="line">                streamedFileContent = </span><br><span class="line">                    <span class="keyword">await</span> FileHelpers.ProcessStreamedFile(section, contentDisposition, </span><br><span class="line">                        ModelState, _permittedExtensions, _fileSizeLimit);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!ModelState.IsValid)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> BadRequest(ModelState);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (MultipartRequestHelper</span><br><span class="line">                .HasFormDataContentDisposition(contentDisposition))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Don&#x27;t limit the key name length because the </span></span><br><span class="line">                <span class="comment">// multipart headers length limit is already in effect.</span></span><br><span class="line">                <span class="keyword">var</span> key = HeaderUtilities</span><br><span class="line">                    .RemoveQuotes(contentDisposition.Name).Value;</span><br><span class="line">                <span class="keyword">var</span> encoding = GetEncoding(section);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (encoding == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ModelState.AddModelError(<span class="string">&quot;File&quot;</span>, </span><br><span class="line">                        <span class="string">$&quot;The request couldn&#x27;t be processed (Error 2).&quot;</span>);</span><br><span class="line">                    <span class="comment">// Log error</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> BadRequest(ModelState);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">using</span> (<span class="keyword">var</span> streamReader = <span class="keyword">new</span> StreamReader(</span><br><span class="line">                    section.Body,</span><br><span class="line">                    encoding,</span><br><span class="line">                    detectEncodingFromByteOrderMarks: <span class="literal">true</span>,</span><br><span class="line">                    bufferSize: <span class="number">1024</span>,</span><br><span class="line">                    leaveOpen: <span class="literal">true</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// The value length limit is enforced by </span></span><br><span class="line">                    <span class="comment">// MultipartBodyLengthLimit</span></span><br><span class="line">                    <span class="keyword">var</span> <span class="keyword">value</span> = <span class="keyword">await</span> streamReader.ReadToEndAsync();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">string</span>.Equals(<span class="keyword">value</span>, <span class="string">&quot;undefined&quot;</span>, </span><br><span class="line">                        StringComparison.OrdinalIgnoreCase))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">value</span> = <span class="built_in">string</span>.Empty;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    formAccumulator.Append(key, <span class="keyword">value</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (formAccumulator.ValueCount &gt; </span><br><span class="line">                        _defaultFormOptions.ValueCountLimit)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// Form key count limit of </span></span><br><span class="line">                        <span class="comment">// _defaultFormOptions.ValueCountLimit </span></span><br><span class="line">                        <span class="comment">// is exceeded.</span></span><br><span class="line">                        ModelState.AddModelError(<span class="string">&quot;File&quot;</span>, </span><br><span class="line">                            <span class="string">$&quot;The request couldn&#x27;t be processed (Error 3).&quot;</span>);</span><br><span class="line">                        <span class="comment">// Log error</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> BadRequest(ModelState);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Drain any remaining section body that hasn&#x27;t been consumed and</span></span><br><span class="line">        <span class="comment">// read the headers for the next section.</span></span><br><span class="line">        section = <span class="keyword">await</span> reader.ReadNextSectionAsync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind form data to the model</span></span><br><span class="line">    <span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line">    <span class="keyword">var</span> formValueProvider = <span class="keyword">new</span> FormValueProvider(</span><br><span class="line">        BindingSource.Form,</span><br><span class="line">        <span class="keyword">new</span> FormCollection(formAccumulator.GetResults()),</span><br><span class="line">        CultureInfo.CurrentCulture);</span><br><span class="line">    <span class="keyword">var</span> bindingSuccessful = <span class="keyword">await</span> TryUpdateModelAsync(formData, prefix: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        valueProvider: formValueProvider);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!bindingSuccessful)</span><br><span class="line">    &#123;</span><br><span class="line">        ModelState.AddModelError(<span class="string">&quot;File&quot;</span>, </span><br><span class="line">            <span class="string">&quot;The request couldn&#x27;t be processed (Error 5).&quot;</span>);</span><br><span class="line">        <span class="comment">// Log error</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BadRequest(ModelState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// **WARNING!**</span></span><br><span class="line">    <span class="comment">// In the following example, the file is saved without</span></span><br><span class="line">    <span class="comment">// scanning the file&#x27;s contents. In most production</span></span><br><span class="line">    <span class="comment">// scenarios, an anti-virus/anti-malware scanner API</span></span><br><span class="line">    <span class="comment">// is used on the file before making the file available</span></span><br><span class="line">    <span class="comment">// for download or for use by other systems. </span></span><br><span class="line">    <span class="comment">// For more information, see the topic that accompanies </span></span><br><span class="line">    <span class="comment">// this sample app.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> file = <span class="keyword">new</span> AppFile()</span><br><span class="line">    &#123;</span><br><span class="line">        Content = streamedFileContent,</span><br><span class="line">        UntrustedName = untrustedFileNameForStorage,</span><br><span class="line">        Note = formData.Note,</span><br><span class="line">        Size = streamedFileContent.Length, </span><br><span class="line">        UploadDT = DateTime.UtcNow</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    _context.File.Add(file);</span><br><span class="line">    <span class="keyword">await</span> _context.SaveChangesAsync();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Created(<span class="keyword">nameof</span>(StreamingController), <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/04/13/angular/Angular%E8%A3%85%E9%A5%B0%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/13/angular/Angular%E8%A3%85%E9%A5%B0%E5%99%A8/" class="post-title-link" itemprop="url">Angular装饰器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-04-13 15:29:52 / 修改时间：17:28:50" itemprop="dateCreated datePublished" datetime="2023-04-13T15:29:52+08:00">2023-04-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我们使用装饰器为Angular中的类声明、方法、访问器、属性和参数提供元数据。我们使用它来装饰组件、指令、模块等。在本文中，让我们了解什么是装饰器，为什么需要它，以及如何创建自定义装饰器。我们还要了解Angular支持的内置装饰器。</p>
<h1 id="Angular-装饰器"><a href="#Angular-装饰器" class="headerlink" title="Angular 装饰器"></a>Angular 装饰器</h1><p>Angular 装饰器是一个函数，我们使用它将元数据附加到类、方法、访问器、属性或参数。</p>
<p>我们以@expression形式使用装饰器，其中expression是装饰器的名称。</p>
<p>例如，@Component是一个装饰器，我们将其附加到一个Angular组件。当Angular看到@Component装饰器应用于一个类时，它将该类视为一个组件类。在下面的示例中，正是@Component装饰器使AppComponent成为一个Angular组件。如果没有装饰器，AppComponent就像其他类一样。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppComponent</span> &#123;</span><br><span class="line">  title = <span class="string">&#x27;app&#x27;</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>decorator装饰器是一个Typescript特性，它仍然不是Javascript的一部分。它仍处于提案阶段。</p>
<p>要启用Angular 装饰器，我们需要将experialDecorators添加到tsconfig.json文件中。ng-new命令会自动为我们添加此内容。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ES5&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;experimentalDecorators&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="创建新的装饰器"><a href="#创建新的装饰器" class="headerlink" title="创建新的装饰器"></a>创建新的装饰器</h1><p>在下面的例子中，我们创建了一个函数simpleDecorator。我们将使用它来装饰AppComponent类。该函数不接受任何参数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span>, <span class="variable constant_">VERSION</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@simpleDecorator</span>      </span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;my-app&#x27;</span>,</span><br><span class="line">  <span class="attr">templateUrl</span>: <span class="string">&#x27;./app.component.html&#x27;</span>,</span><br><span class="line">  <span class="attr">styleUrls</span>: [<span class="string">&#x27;./app.component.css&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppComponent</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;Angular &#x27;</span> + <span class="variable constant_">VERSION</span>.<span class="property">major</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello from Class constructor&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="title function_">ngOnInit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="variable language_">this</span> <span class="keyword">as</span> <span class="built_in">any</span>).<span class="property">value1</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="variable language_">this</span> <span class="keyword">as</span> <span class="built_in">any</span>).<span class="property">value2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">simpleDecorator</span>(<span class="params">target: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello from Decorator&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;value1&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span></span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;value2&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">**** <span class="title class_">Console</span> ***</span><br><span class="line"> </span><br><span class="line"><span class="title class_">Hello</span> <span class="keyword">from</span> <span class="title class_">Decorator</span></span><br><span class="line"><span class="title class_">Hello</span> <span class="keyword">from</span> <span class="title class_">Class</span> constructor</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure>

<p>正如我们前面所说，d装饰器 是一个常规的JavaScript函数。由于我们在类上使用它，因此它获取AppComponent的实例作为参数（目标）</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">simpleDecorator</span>(<span class="params">target: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello from Decorator&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//target is instance of AppComponent</span></span><br></pre></td></tr></table></figure>

<p>在函数内部，我们将两个自定义属性value1和value2添加到AppComponent。请注意，我们使用defineProperty属性向组件类添加一个新属性。此外，我们将其添加到类的原型属性中。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;value1&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span></span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;value2&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span></span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>现在，我们可以使用它来装饰我们的AppComponent</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@simpleDecorator</span></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;my-app&#x27;</span>,</span><br><span class="line">  <span class="attr">templateUrl</span>: <span class="string">&#x27;./app.component.html&#x27;</span>,</span><br><span class="line">  <span class="attr">styleUrls</span>: [<span class="string">&#x27;./app.component.css&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppComponent</span> &#123;</span><br></pre></td></tr></table></figure>
<p>在组件内部，我们可以使用关键字“this”访问新的属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">ngOnInit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="variable language_">this</span> <span class="keyword">as</span> <span class="built_in">any</span>).<span class="property">value1</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="variable language_">this</span> <span class="keyword">as</span> <span class="built_in">any</span>).<span class="property">value2</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h1><p>要创建一个带参数的装饰器，我们需要创建一个工厂函数，该函数返回装饰器函数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span>, <span class="variable constant_">VERSION</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@simpleDecorator</span>(&#123;</span><br><span class="line">  <span class="attr">value1</span>: <span class="string">&#x27;100&#x27;</span>,</span><br><span class="line">  <span class="attr">value2</span>: <span class="string">&#x27;200&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;my-app&#x27;</span>,</span><br><span class="line">  <span class="attr">templateUrl</span>: <span class="string">&#x27;./app.component.html&#x27;</span>,</span><br><span class="line">  <span class="attr">styleUrls</span>: [<span class="string">&#x27;./app.component.css&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppComponent</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;Angular &#x27;</span> + <span class="variable constant_">VERSION</span>.<span class="property">major</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello from Class constructor&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="title function_">ngOnInit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="variable language_">this</span> <span class="keyword">as</span> <span class="built_in">any</span>).<span class="property">value1</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="variable language_">this</span> <span class="keyword">as</span> <span class="built_in">any</span>).<span class="property">value2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">simpleDecorator</span>(<span class="params">args</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">target: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello from Decorator&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> target);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(target);</span><br><span class="line"> </span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;value1&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">value</span>: args.<span class="property">value1</span>,</span><br><span class="line">      <span class="attr">writable</span>: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;value2&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">value</span>: args.<span class="property">value2</span>,</span><br><span class="line">      <span class="attr">writable</span>: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> simpleDecorator将args作为参数，并返回 装饰器函数。除了使用参数填充财产之外，其余代码与上面的代码相同。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">simpleDecorator</span>(<span class="params">args</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">target: <span class="built_in">any</span></span>) &#123;</span><br></pre></td></tr></table></figure>

<p> 我们在组件上应用simpleDecorator，如下所示</p>
<h1 id="Angular-装饰器-列表"><a href="#Angular-装饰器-列表" class="headerlink" title="Angular 装饰器 列表"></a>Angular 装饰器 列表</h1><p>Angular提供了几个内置的装饰器。我们可以把它们分为四类</p>
<p>以下是Angular中装饰器的完整列表。</p>
<ul>
<li>类装饰器<ul>
<li>@NgModule</li>
<li>@Component</li>
<li>@Injectable</li>
<li>@Directive</li>
<li>@Pipe</li>
</ul>
</li>
<li>属性装饰器<ul>
<li>@Input</li>
<li>@Output</li>
<li>@HostBinding</li>
<li>@ContentChild</li>
<li>@ContentChildren</li>
<li>@ViewChild</li>
<li>@ViewChildren</li>
</ul>
</li>
<li>方法装饰器<ul>
<li>@HostListener</li>
</ul>
</li>
<li>参数装饰器<ul>
<li>@Inject</li>
<li>@Self</li>
<li>@SkipSelf</li>
<li>@Optional</li>
<li>@Host</li>
</ul>
</li>
</ul>
<h1 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/04/08/angular/Angular%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/08/angular/Angular%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/" class="post-title-link" itemprop="url">Angular生命周期钩子</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-08 18:56:06" itemprop="dateCreated datePublished" datetime="2023-04-08T18:56:06+08:00">2023-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-28 09:22:51" itemprop="dateModified" datetime="2023-06-28T09:22:51+08:00">2023-06-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>AfterViewInit、AfterContentInit、AfterViewChecked和AfterContentChecked是生命周期钩子。Angular在组件的生命周期中，调用它们。在本教程中，我们将了解它们是什么以及Angular何时调用它们。我们还了解了AfterViewInit和AfterContentInit与AfterViewChecked和AfterContentChecked之间的差异。</p>
<h1 id="生命周期回顾"><a href="#生命周期回顾" class="headerlink" title="生命周期回顾"></a>生命周期回顾</h1><p>当Angular实例化组件时，组件（或指令）的生命就开始了。实例化从调用组件的构造函数开始，并通过依赖注入服务。</p>
<p>一旦Angular实例化了组件，它就会启动组件的变更检测，它检查并更新组件的输入数据绑定属性，并初始化组件。然后，它会引发以下生命周期钩子。</p>
<p>Onchanges,如果Angular检测到Input属性的任何更改或angular检测到输入变化时，Onchanges都会被运行。</p>
<p>OnInit，它告诉我们组件已经准备好了。这个钩子让我们有机会运行初始化逻辑，更新属性等。这个钩子只运行一次。</p>
<p>DoCheck，这允许我们运行自定义更改检测，因为更改检测可能会忽略一些更改。该挂钩在每个变化检测周期中运行。</p>
<p>在此之后，Angular又调用了四个钩子。它们是AfterContentInit、AfterContentChecked、AfterViewInit和AfterViewChecked。我们将详细研究它们。</p>
<p>最后，当我们移除组件时，Angular调用ngOnDestroy钩子，销毁组件。</p>
<h1 id="Content-Vs-View"><a href="#Content-Vs-View" class="headerlink" title="Content Vs View"></a>Content Vs View</h1><p>在深入研究这些挂钩之前，我们需要了解内容(Content)和视图(View)之间的区别。钩子AfterConentInit和AfterContentChecked处理内容(Content)，而AfterViewInit、AfterViewChecked处理视图(View)。</p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>内容是指使用内容投影注入到该组件中的外部内容。<br>内容投影是将HTML内容从父组件传递到子组件的一种方式。子组件将在指定位置显示传入的内容。我们使用ng-content在子组件的模板中创建一个点，如下所示。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Child Component<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ng-content</span>&gt;</span><span class="tag">&lt;/<span class="name">ng-content</span>&gt;</span>   <span class="comment">&lt;!-- place hodler for content from parent --&gt;</span></span><br></pre></td></tr></table></figure>

<p>父元素在开始元素和结束元素之间注入内容。Angular将此内容传递给子组件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Parent Component<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">app-child</span>&gt;</span> This <span class="tag">&lt;<span class="name">b</span>&gt;</span>content<span class="tag">&lt;/<span class="name">b</span>&gt;</span> is injected from parent<span class="tag">&lt;/<span class="name">app-child</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图是指组件的模板。</p>
<h1 id="AfterContentInit"><a href="#AfterContentInit" class="headerlink" title="AfterContentInit"></a>AfterContentInit</h1><p>AfterContentInit是在组件的内容完全初始化并注入组件视图后，angular调用的生命周期挂钩。</p>
<p>Angular在调用AfterContentInit之前，先更新被ContentChild和ContentChildren装饰的属性。</p>
<p>即使组件中没有使用内容投影，Angular也会调用AfterContentInit，此挂钩在ngDoCheck挂钩之后启动。</p>
<p>AfterContentInit仅调用一次(在组件创建后第一个变更检测后)。</p>
<h1 id="AfterContentChecked"><a href="#AfterContentChecked" class="headerlink" title="AfterContentChecked"></a>AfterContentChecked</h1><p>AfterContentChecked 在 ngDoCheck 和 AfterContentInit调用之后触发。<br>Angular在调用AfterContentChecked之前，先更新被ContentChild和ContentChildren装饰的属性。</p>
<h1 id="AfterViewInit"><a href="#AfterViewInit" class="headerlink" title="AfterViewInit"></a>AfterViewInit</h1><p>仅在组件创建后的第一个变更检测周期内触发一次。</p>
<p>Angular 在完成组件视图及其子视图的初始化后，在变更检测期间调用的生命周期挂钩。</p>
<p>在引发AfterViewInit之前，Angular 还会更新用 ViewChild 和 ViewChildren 属性装饰的属性。</p>
<h1 id="AfterViewChecked"><a href="#AfterViewChecked" class="headerlink" title="AfterViewChecked"></a>AfterViewChecked</h1><p>在变更检测器完成对组件视图和子视图变更的检查后，Angular 调用的生命周期挂钩。</p>
<p>在引发此挂钩之前，Angular 还会更新用 ViewChild 和 ViewChildren 属性装饰的属性。</p>
<h1 id="Init-Vs-Checked"><a href="#Init-Vs-Checked" class="headerlink" title="Init Vs Checked"></a>Init Vs Checked</h1><p>当第一次初始化内容或视图时，Angular 会触发 AfterContentInit 和 AfterViewInit 钩子。 这发生在第一个变化检测周期中，Angular在组件实例化后立即调用。</p>
<p>Angular 触发 AfterContentChecked 和 AfterViewChecked 钩子，Angular 在其中检查内容或视图是否已更改。 即先前呈现的内容或视图与当前内容或视图相同。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/04/06/angular/%E4%BD%BF%E7%94%A8Renderer2%E6%93%8D%E4%BD%9CDOM%E5%85%83%E7%B4%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/06/angular/%E4%BD%BF%E7%94%A8Renderer2%E6%93%8D%E4%BD%9CDOM%E5%85%83%E7%B4%A0/" class="post-title-link" itemprop="url">使用Renderer2操作DOM元素</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-04-06 15:13:47 / 修改时间：18:50:29" itemprop="dateCreated datePublished" datetime="2023-04-06T15:13:47+08:00">2023-04-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Renderer2允许我们在不直接访问DOM的情况下操作DOM元素。它在DOM元素和组件代码之间提供了一层抽象。使用Renderer2，我们可以创建一个元素，向其中添加一个文本节点，使用appendchild方法附加子元素。我们还可以添加或删除样式、HTML属性、CSS类和属性等。我们还可以附加和侦听DOM事件。</p>
<h1 id="为什么不直接使用-ElementRef"><a href="#为什么不直接使用-ElementRef" class="headerlink" title="为什么不直接使用 ElementRef"></a>为什么不直接使用 ElementRef</h1><p>ElelemtRef的nativeElement属性包含对底层DOM对象的引用，这使我们可以绕过Angular直接访问DOM，我们可以使用nativeElement属性来直接操作DOM元素。但由于以下原因，直接操作DOM是不建议的。</p>
<ol>
<li>Angular使用模板、数据绑定和更改检测等保持组件和视图同步。当我们直接更新DOM时，所有这些都会被绕过。</li>
<li>DOM操作仅适用于浏览器。您将无法在其他平台中使用该应用程序，例如在服务器（服务器端渲染）、桌面或移动应用程序等中。</li>
<li>DOM API不会对数据进行净化。因此，可以通过注入脚本，打开我们的应用程序，成为XSS注入攻击的目标。</li>
</ol>
<h1 id="使用-Renderer2"><a href="#使用-Renderer2" class="headerlink" title="使用 Renderer2"></a>使用 Renderer2</h1><p>首先从  @angular&#x2F;core 导入 Renderer2.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Component</span>, <span class="title class_">Renderer2</span>, <span class="title class_">ElementRef</span>, <span class="title class_">ViewChild</span>, <span class="title class_">AfterViewInit</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>在组件中注入 Renderer2</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> renderer:Renderer2</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 ElementRef &amp; ViewChild 获取我们想操作的DOM元素实例</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ViewChild</span>(<span class="string">&#x27;hello&#x27;</span>, &#123; <span class="attr">static</span>: <span class="literal">false</span> &#125;) <span class="attr">divHello</span>: <span class="title class_">ElementRef</span>;</span><br></pre></td></tr></table></figure>

<p>使用setProperty、setStyle等方法更改元素的属性和样式，如下所示</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">renderer</span>.<span class="title function_">setProperty</span>(<span class="variable language_">this</span>.<span class="property">divHello</span>.<span class="property">nativeElement</span>,<span class="string">&#x27;innerHTML&#x27;</span>,<span class="string">&quot;Hello Angular&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">this</span>.<span class="property">renderer</span>.<span class="title function_">setStyle</span>(<span class="variable language_">this</span>.<span class="property">divHello</span>.<span class="property">nativeElement</span>, <span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;red&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="设置-amp-移除-Styles"><a href="#设置-amp-移除-Styles" class="headerlink" title="设置&amp;移除 Styles"></a>设置&amp;移除 Styles</h1><p>使用setStyle和RemoveStyle添加或删除样式，它接受四个参数。第一个参数是我们要应用样式的元素，第二个参数是样式的名称，第三个参数是样式的值，最后一个参数是可选的，他是样式变量的标志</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="title function_">setStyle</span>(<span class="attr">el</span>: <span class="built_in">any</span>, <span class="attr">style</span>: <span class="built_in">string</span>, <span class="attr">value</span>: <span class="built_in">any</span>, flags?: <span class="title class_">RendererStyleFlags2</span>): <span class="built_in">void</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="title function_">removeStyle</span>(<span class="attr">el</span>: <span class="built_in">any</span>, <span class="attr">style</span>: <span class="built_in">string</span>, flags?: <span class="title class_">RendererStyleFlags2</span>): <span class="built_in">void</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Template</span></span><br><span class="line">&lt;div #hello&gt;<span class="title class_">Hello</span> !&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Component</span></span><br><span class="line"><span class="meta">@ViewChild</span>(<span class="string">&#x27;hello&#x27;</span>, &#123; <span class="attr">static</span>: <span class="literal">false</span> &#125;) <span class="attr">divHello</span>: <span class="title class_">ElementRef</span>;</span><br><span class="line"> </span><br><span class="line"><span class="title function_">setStyle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">renderer</span>.<span class="title function_">setStyle</span>(<span class="variable language_">this</span>.<span class="property">divHello</span>.<span class="property">nativeElement</span>, <span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="title function_">removeStyle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">renderer</span>.<span class="title function_">removeStyle</span>(<span class="variable language_">this</span>.<span class="property">divHello</span>.<span class="property">nativeElement</span>, <span class="string">&#x27;color&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用最后一个选项RendererStyleFlags2指定渲染器特有样式修饰符</p>
<h1 id="添加-amp-删除CSS-样式"><a href="#添加-amp-删除CSS-样式" class="headerlink" title="添加&amp;删除CSS 样式"></a>添加&amp;删除CSS 样式</h1><p>使用 addClass &#x2F; removeClass 添加&amp;删除CSS样式。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="title function_">addClass</span>(<span class="attr">el</span>: <span class="built_in">any</span>, <span class="attr">name</span>: <span class="built_in">string</span>): <span class="built_in">void</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="title function_">removeClass</span>(<span class="attr">el</span>: <span class="built_in">any</span>, <span class="attr">name</span>: <span class="built_in">string</span>): <span class="built_in">void</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Template</span></span><br><span class="line">&lt;div #hello&gt;<span class="title class_">Hello</span> !&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Component</span></span><br><span class="line"><span class="meta">@ViewChild</span>(<span class="string">&#x27;hello&#x27;</span>, &#123; <span class="attr">static</span>: <span class="literal">false</span> &#125;) <span class="attr">divHello</span>: <span class="title class_">ElementRef</span>;</span><br><span class="line"> </span><br><span class="line"><span class="title function_">addClass</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">renderer</span>.<span class="title function_">addClass</span>(<span class="variable language_">this</span>.<span class="property">divHello</span>.<span class="property">nativeElement</span>, <span class="string">&#x27;blackborder&#x27;</span> );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="title function_">removeClass</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">renderer</span>.<span class="title function_">removeClass</span>(<span class="variable language_">this</span>.<span class="property">divHello</span>.<span class="property">nativeElement</span>, <span class="string">&#x27;blackborder&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="添加删除-Attributes"><a href="#添加删除-Attributes" class="headerlink" title="添加删除 Attributes"></a>添加删除 Attributes</h1><p>使用 setAttribute &amp; removeAttribute 添加&amp;移除 attribute样式。</p>
<blockquote>
<p>元素没有此 attribute，也可以添加上去<br>attribute，还可以做动词，表示赋予，属于人为赋予的可改变的属性</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setAttribute</span>(<span class="attr">el</span>: <span class="built_in">any</span>, <span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">value</span>: <span class="built_in">string</span>, <span class="keyword">namespace</span>?: string): void</span><br><span class="line"> </span><br><span class="line">removeAttribute(el: any, name: string, <span class="keyword">namespace</span>?: string): void</span><br></pre></td></tr></table></figure>

<h1 id="设置Property"><a href="#设置Property" class="headerlink" title="设置Property"></a>设置Property</h1><p>使用setProperty方法设置DOM元素的任何属性。</p>
<blockquote>
<p>元素没有此 property 不会添加上去<br>property是 物体本身自带属性，不能改变的（一旦改了就是另外一个东西了）</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setProperty</span>(<span class="attr">el</span>: <span class="built_in">any</span>, <span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">value</span>: <span class="built_in">any</span>): <span class="built_in">void</span></span><br></pre></td></tr></table></figure>

<h1 id="AppendChild-createElement-createText"><a href="#AppendChild-createElement-createText" class="headerlink" title="AppendChild createElement createText"></a>AppendChild createElement createText</h1><p>使用appendChild将一个新元素（子元素）附加到任何现有元素（父元素）。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">appendChild</span>(<span class="attr">parent</span>: <span class="built_in">any</span>, <span class="attr">newChild</span>: <span class="built_in">any</span>): <span class="built_in">void</span></span><br></pre></td></tr></table></figure>
<p>它接受两个参数。第一个参数是父节点(我们希望在其中附加一个新的子节点)。第二个参数是要添加的子节点。</p>
<h2 id="创建一个新元素"><a href="#创建一个新元素" class="headerlink" title="创建一个新元素"></a>创建一个新元素</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="variable language_">this</span>.<span class="property">renderer</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> text = <span class="variable language_">this</span>.<span class="property">renderer</span>.<span class="title function_">createText</span>(<span class="string">&#x27;Inserted at bottom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">renderer</span>.<span class="title function_">appendChild</span>(div, text);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">renderer</span>.<span class="title function_">appendChild</span>(<span class="variable language_">this</span>.<span class="property">div</span>.<span class="property">nativeElement</span>, div);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="InsertBefore"><a href="#InsertBefore" class="headerlink" title="InsertBefore"></a>InsertBefore</h1><p>我们还可以使用insertBefore方法在DOM元素中的元素之前插入新元素。insertBefore的语法如下所示</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">insertBefore</span>(<span class="attr">parent</span>: <span class="built_in">any</span>, <span class="attr">newChild</span>: <span class="built_in">any</span>, <span class="attr">refChild</span>: <span class="built_in">any</span>): <span class="built_in">void</span></span><br></pre></td></tr></table></figure>
<p>parent是父节点,newChild是要插入的新节点,refChild是插入newChild之前的现有子节点。</p>
<h1 id="添加注释"><a href="#添加注释" class="headerlink" title="添加注释"></a>添加注释</h1><p>createComment创建注释节点。它接受注释作为自变量。然后可以使用appendChild或insertBefore将其插入DOM中的任何位置。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">createComment</span>(<span class="attr">value</span>: <span class="built_in">string</span>): <span class="built_in">any</span></span><br></pre></td></tr></table></figure>

<h1 id="ParentNode-amp-NextSibling"><a href="#ParentNode-amp-NextSibling" class="headerlink" title="ParentNode &amp; NextSibling"></a>ParentNode &amp; NextSibling</h1><p>ParentNode方法返回宿主元素DOM中给定节点的父节点。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/<span class="title class_">Returns</span> the parent <span class="title class_">Node</span> <span class="keyword">of</span> div3</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">renderer</span>.<span class="title function_">parentNode</span>(<span class="variable language_">this</span>.<span class="property">div3</span>.<span class="property">nativeElement</span>);</span><br></pre></td></tr></table></figure>
<p>nextSibling方法返回宿主元素DOM中给定节点的下一个同级节点。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Returns the next Sibling node of div2</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">renderer</span>.<span class="title function_">nextSibling</span>(<span class="variable language_">this</span>.<span class="property">div2</span>.<span class="property">nativeElement</span>);</span><br></pre></td></tr></table></figure>

<h1 id="SelectRootElement"><a href="#SelectRootElement" class="headerlink" title="SelectRootElement"></a>SelectRootElement</h1><p>我们也可以使用selectRoomElement来选择基于选择器的节点元素。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">selectRootElement</span>(<span class="attr">selectorOrNode</span>: <span class="built_in">any</span>, preserveContent?: <span class="built_in">boolean</span>)</span><br></pre></td></tr></table></figure>
<p>第一个参数是选择器或节点。Renderer2使用选择器来搜索DOM元素并返回它。</p>
<p>第二个参数是preserveContent，如果是no或undefined，renderer2将删除所有子节点。如果是yes，则不会删除子节点。</p>
<h1 id="监听-DOM-事件"><a href="#监听-DOM-事件" class="headerlink" title="监听 DOM 事件"></a>监听 DOM 事件</h1><p>您也可以使用listen方法来侦听DOM事件。</p>
<p>listen方法接受三个参数，第一个参数是DOM元素（目标），第二个参数是事件的名称（eventName），第三个参数是回调函数</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="title function_">listen</span>(<span class="attr">target</span>: <span class="built_in">any</span>, <span class="attr">eventName</span>: <span class="built_in">string</span>, <span class="attr">callback</span>: <span class="function">(<span class="params">event: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">boolean</span> | <span class="built_in">void</span>): <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/04/05/angular/Angular%E4%B8%AD%E7%9A%84ElementRef/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/05/angular/Angular%E4%B8%AD%E7%9A%84ElementRef/" class="post-title-link" itemprop="url">Angular中的ElementRef</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-05 22:04:06" itemprop="dateCreated datePublished" datetime="2023-04-05T22:04:06+08:00">2023-04-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-06 15:14:47" itemprop="dateModified" datetime="2023-04-06T15:14:47+08:00">2023-04-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Angular ElementRef是一个围绕原生DOM元素（HTML元素）对象的包装器。它包含属性nativeElement，该属性保存对底层DOM对象的引用。我们可以使用它来操作DOM。我们组件中使用ViewChild来获取模板HTML元素的ElementRef实例。Angular还在组件或指令的构造函数中注入宿主元素的ElementRef实例。在本教程中，让我们探讨如何使用ElementRef来获得HtmlElement的引用并在Angular Applications中操作DOM。</p>
<h1 id="ElementRef"><a href="#ElementRef" class="headerlink" title="ElementRef"></a>ElementRef</h1><p>DOM对象由浏览器创建和维护。它们代表了文件的结构和内容。在原生JavaScript代码中，我们访问这些DOM对象来操作View。我们可以创建文档，以及添加、修改或删除元素和内容。</p>
<p>Angular提供了许多工具和技术来操作DOM。我们可以添加&#x2F;删除组件。它提供了许多指令，如类指令或样式指令，来操纵他们的风格等。</p>
<p>在某些情况下，我们可能仍然需要访问DOM元素。这就需要用到ElementRef。</p>
<h1 id="在组件中获取ElementRef"><a href="#在组件中获取ElementRef" class="headerlink" title="在组件中获取ElementRef"></a>在组件中获取ElementRef</h1><p>要使用ElementRef操作DOM，我们需要在组件&#x2F;指令中获取它对DOM元素的引用。</p>
<ol>
<li>获取对组件中DOM元素的引用</li>
</ol>
<ul>
<li>为组件&#x2F;指令中的元素创建模板引用变量。</li>
<li>使用ViewChild或ViewChildren通过模板变量在组件中直接获取DOM元素引用。</li>
</ul>
<ol start="2">
<li>获取组件&#x2F;指令的宿主DOM元素</li>
</ol>
<ul>
<li>组件或指令的构造函数中注入宿主元素的ElementRef引用（Angular Dependency注入）</li>
</ul>
<p>例如，在下面的代码中，变量hello引用了HTML元素div。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> #<span class="attr">hello</span>&gt;</span>Hello Angular<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们可以在模板中使用hello这个模板引用变量。</p>
<p>在Component类中，我们使用ViewChild来注入hello元素。Angular将hello作为ElementRef类型注入。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ViewChild</span>(<span class="string">&#x27;hello&#x27;</span>, &#123; <span class="attr">static</span>: <span class="literal">false</span> &#125;) <span class="attr">divHello</span>: <span class="title class_">ElementRef</span>;</span><br></pre></td></tr></table></figure>

<h2 id="读取令牌"><a href="#读取令牌" class="headerlink" title="读取令牌"></a>读取令牌</h2><p>考虑以下示例</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> #<span class="attr">nameInput</span> [(<span class="attr">ngModel</span>)]=<span class="string">&quot;name&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>nameInput 模板引用变量现在绑定到input输入元素。但与此同时，我们也将ngModel指令绑定到它上面。</p>
<p>在这种情况下，我们可以使用read令牌让angular知道我们需要ElementRef引用到谁，如下所示</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewChild returns ElementRef i.e. input HTML Element</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@ViewChild</span>(<span class="string">&#x27;nameInput&#x27;</span>,&#123;<span class="attr">static</span>:<span class="literal">false</span>, <span class="attr">read</span>: <span class="title class_">ElementRef</span>&#125;) elRef;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//ViewChild returns NgModel associated with the nameInput</span></span><br><span class="line"><span class="meta">@ViewChild</span>(<span class="string">&#x27;nameInput&#x27;</span>,&#123;<span class="attr">static</span>:<span class="literal">false</span>, <span class="attr">read</span>: <span class="title class_">NgModel</span>&#125;) inRef;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h1 id="ElementRef-例子"><a href="#ElementRef-例子" class="headerlink" title="ElementRef 例子"></a>ElementRef 例子</h1><p>一旦我们有了ElementRef，我们就可以使用nativeElement属性来操作DOM，如下所示。<br>在访问ViewChild变量之前，我们需要等待Angular初始化视图。因此，我们要等到AfterViewInit生命周期挂钩之后，才能开始使用该变量。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span>,<span class="title class_">ElementRef</span>, <span class="title class_">ViewChild</span>, <span class="title class_">AfterViewInit</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-root&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>:  <span class="string">&#x27;&lt;div #hello&gt;Hello&lt;/div&gt;&#x27;</span></span><br><span class="line">  <span class="attr">styleUrls</span>: [<span class="string">&#x27;./app.component.css&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppComponent</span> <span class="keyword">implements</span> <span class="title class_">AfterViewInit</span> &#123;</span><br><span class="line"> </span><br><span class="line"> <span class="meta">@ViewChild</span>(<span class="string">&#x27;hello&#x27;</span>, &#123; <span class="attr">static</span>: <span class="literal">false</span> &#125;) <span class="attr">divHello</span>: <span class="title class_">ElementRef</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="title function_">ngAfterViewInit</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">divHello</span>.<span class="property">nativeElement</span>.<span class="property">innerHTML</span> = <span class="string">&quot;Hello Angular&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以非常容易得操作DOM元素</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">ngAfterViewInit</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">divHello</span>.<span class="property">nativeElement</span>.<span class="property">innerHTML</span> = <span class="string">&quot;Hello Angular&quot;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">divHello</span>.<span class="property">nativeElement</span>.<span class="property">className</span>=<span class="string">&quot;someClass&quot;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">divHello</span>.<span class="property">nativeElement</span>.<span class="property">style</span>.<span class="property">backgroundColor</span>=<span class="string">&quot;red&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="在自定义指令中使用-ElementRef"><a href="#在自定义指令中使用-ElementRef" class="headerlink" title="在自定义指令中使用 ElementRef"></a>在自定义指令中使用 ElementRef</h1><p>ElementRef的一个用例是Angular指令。我们学习了如何在Angular中创建自定义指令。以下是ttClass自定义属性指令的代码。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Directive</span>, <span class="title class_">ElementRef</span>, <span class="title class_">Input</span>, <span class="title class_">OnInit</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@Directive</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;[ttClass]&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ttClassDirective</span> <span class="keyword">implements</span> <span class="title class_">OnInit</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Input</span>() <span class="attr">ttClass</span>: <span class="built_in">string</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> el: ElementRef</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="title function_">ngOnInit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">el</span>.<span class="property">nativeElement</span>.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="variable language_">this</span>.<span class="property">ttClass</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，我们在构造函数中注入ElementRef。每当我们访问构造函数中注入的ElementRef时，Angular就会注入对指令的宿主DOM元素的引用。</p>
<blockquote>
<p>谨慎使用<br>当需要直接访问DOM时，使用此API作为最后的手段。请改用Angular提供的模板和数据绑定。或者，您可以看看Renderer2，它提供了即使不支持直接访问本机元素也可以安全使用的API。<br>依赖于直接DOM访问会在应用程序和渲染层之间产生紧密耦合，这将使您无法将两者分离并将应用程序部署到web工作者中。</p>
</blockquote>
<h1 id="ElementRef和XSS注入攻击"><a href="#ElementRef和XSS注入攻击" class="headerlink" title="ElementRef和XSS注入攻击"></a>ElementRef和XSS注入攻击</h1><p>ElementRef的不当使用可能导致XSS注入攻击。例如，在下面的代码中，我们正在使用elementRef注入一个脚本。当包含此类代码的组件运行时，将执行脚本</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> elementRef: ElementRef</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> s = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    s.<span class="property">type</span> = <span class="string">&#x27;text/javascript&#x27;</span>;</span><br><span class="line">    s.<span class="property">textContent</span> = <span class="string">&#x27;alert(&quot;Hello World&quot;)&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">elementRef</span>.<span class="property">nativeElement</span>.<span class="title function_">appendChild</span>(s);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://leetao50.github.io/2023/04/04/angular/%E7%90%86%E8%A7%A3ViewChild-ViewChildren-Querylist/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="InfoPool">
      <meta itemprop="description" content="记录信息来源网络，内容只为方便查找，非公开信息，非请勿入">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | InfoPool">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/04/angular/%E7%90%86%E8%A7%A3ViewChild-ViewChildren-Querylist/" class="post-title-link" itemprop="url">理解ViewChild, ViewChildren & Querylist</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-04-04 14:03:01 / 修改时间：18:33:27" itemprop="dateCreated datePublished" datetime="2023-04-04T14:03:01+08:00">2023-04-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>ViewChild或ViewChildren装饰器用于查询和获取组件中DOM元素的引用。ViewChild返回第一个匹配的元素，ViewChildren以QueryList形式返回所有匹配的元素。我们可以通过这些引用在组件中操作dom元素属性。</p>
<p>ViewChild或ViewChildren的第一个参数是查询选择器，通过ViewChild或ViewChildren来查询DOM元素，我们可以提供字符串或类型作为查询选择器。参数static确定是在更改检测之前还是之后执行查询。read选项允许我们查询不同的令牌，而不是默认令牌，并且在元素与多个类型关联时很有用。</p>
<h1 id="ViewChild"><a href="#ViewChild" class="headerlink" title="ViewChild"></a>ViewChild</h1><p>ViewChild查询从DOM返回第一个匹配元素，并更新它在组件中绑定的变量。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ViewChild</span>(<span class="attr">selector</span>: <span class="built_in">string</span> | <span class="title class_">Function</span> | <span class="title class_">Type</span>&lt;<span class="built_in">any</span>&gt;, <span class="attr">opts</span>: &#123; read?: <span class="built_in">any</span>; <span class="attr">static</span>: <span class="built_in">boolean</span>; &#125;): <span class="built_in">any</span></span><br></pre></td></tr></table></figure>
<p>我们在组件属性上应用viewChild装饰器。它需要提供两个参数，selector和opts。</p>
<ul>
<li><p>selector：可以是字符串、类型或返回字符串或类型的函数。变更检测查找与选择器匹配的第一个元素，并使用对该元素的引用更新组件属性。如果DOM发生更改，并且有一个新元素与选择器匹配，则变更检测会更新组件属性。</p>
</li>
<li><p>opts：有两个选项。</p>
<ul>
<li>static：确定何时解析查询。设为True时，当视图首次初始化（在第一次更改检测之前）。设为False时，在每次检测到更改后执行。</li>
<li>read：使用它从查询的元素中读取不同的令牌。</li>
</ul>
</li>
</ul>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="在组件和指令中注入引用"><a href="#在组件和指令中注入引用" class="headerlink" title="在组件和指令中注入引用"></a>在组件和指令中注入引用</h2><p>ViewChild的一个用例是在父组件中获取子组件的引用并操作其属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;child-component&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;h2&gt;Child Component&lt;/h2&gt;</span></span><br><span class="line"><span class="string">            current count is &#123;&#123; count &#125;&#125;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ChildComponent</span> &#123;</span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">decrement</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在父组件中使用 ViewChild 引用子组件。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ViewChild</span>(<span class="title class_">ChildComponent</span>, &#123;<span class="attr">static</span>:<span class="literal">true</span>&#125;) <span class="attr">child</span>: <span class="title class_">ChildComponent</span>;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，ViewChild在父组件视图(Template)中查找第一个出现的ChildComponent组件，并更新父组件中的child变量。现在我们可以从父组件调用ChildComponent组件中的Increment和Decrement方法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span>, <span class="title class_">ViewChild</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ChildComponent</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./child.component&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-root&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt; current count is &#123;&#123;child.count&#125;&#125; &lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;button (click)=&quot;increment()&quot;&gt;Increment&lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;button (click)=&quot;decrement()&quot;&gt;decrement&lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;child-component&gt;&lt;/child-component&gt;</span></span><br><span class="line"><span class="string">        `</span> ,</span><br><span class="line">  <span class="attr">styleUrls</span>: [<span class="string">&#x27;./app.component.css&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppComponent</span> &#123;</span><br><span class="line">  title = <span class="string">&#x27;Parent calls an @ViewChild()&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ViewChild</span>(<span class="title class_">ChildComponent</span>, &#123;<span class="attr">static</span>:<span class="literal">true</span>&#125;) <span class="attr">child</span>: <span class="title class_">ChildComponent</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">child</span>.<span class="title function_">increment</span>();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="title function_">decrement</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">child</span>.<span class="title function_">decrement</span>();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用模板引用变量"><a href="#使用模板引用变量" class="headerlink" title="使用模板引用变量"></a>使用模板引用变量</h2><p>您可以使用模板引用变量代替组件类型。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child-component</span> #<span class="attr">child</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在ViewChild查询中使用它来获取对该组件的引用。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ViewChild</span>(<span class="string">&quot;child&quot;</span>, &#123; <span class="attr">static</span>: <span class="literal">true</span> &#125;) <span class="attr">child</span>: <span class="title class_">ChildComponent</span>;</span><br></pre></td></tr></table></figure>

<h2 id="使用ElementRef注入HTML元素"><a href="#使用ElementRef注入HTML元素" class="headerlink" title="使用ElementRef注入HTML元素"></a>使用ElementRef注入HTML元素</h2><p>Viewchild 同样可以用来查询 HTML元素。<br>首先可以给HTML元素指定模板变量，然后就可以在viewChild中使用此模板变量查询HTML元素。查询结果将返回一个ElementRef类型的元素，它是本地HTML元素的包装器。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">AfterViewInit</span>, <span class="title class_">Component</span>, <span class="title class_">ElementRef</span>, <span class="title class_">ViewChild</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    <span class="attr">selector</span>: <span class="string">&#x27;htmlelement&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;p #para&gt;Some text&lt;/p&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">HTMLElementComponent</span> <span class="keyword">implements</span> <span class="title class_">AfterViewInit</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@ViewChild</span>(<span class="string">&#x27;para&#x27;</span>,&#123;<span class="attr">static</span>:<span class="literal">false</span>&#125;) <span class="attr">para</span>: <span class="title class_">ElementRef</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="title function_">ngAfterViewInit</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">para</span>.<span class="property">nativeElement</span>.<span class="property">innerHTML</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">para</span>.<span class="property">nativeElement</span>.<span class="property">innerHTML</span>=<span class="string">&quot;new text&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多个实例"><a href="#多个实例" class="headerlink" title="多个实例"></a>多个实例</h2><p>模板中可能存在同一组件或元素的多个实例。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child-component</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child-component</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>ViewChild 总是返回第一个匹配的组件。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ViewChild</span>(<span class="title class_">ChildComponent</span>, &#123;<span class="attr">static</span>:<span class="literal">true</span>&#125;) <span class="attr">child</span>: <span class="title class_">ChildComponent</span>;</span><br></pre></td></tr></table></figure>
<p>要获取子组件的所有实例，我们可以使用ViewChildren，我们将在本教程后面介绍它。</p>
<h2 id="ViewChild-返回-Undefined"><a href="#ViewChild-返回-Undefined" class="headerlink" title="ViewChild 返回 Undefined"></a>ViewChild 返回 Undefined</h2><p>ViewChild返回Undefined是我们在使用它们时遇到的常见错误之一。</p>
<p>该错误是由于我们试图在ViewChild初始化之前使用该值。</p>
<p>例如，下面的代码导致无法读取未定义的属性“increment”。当构造函数运行前，组件的视图尚未初始化。因此，Angular无法通过引用ChildComposet变量来更新child变量。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppComponent</span> &#123;</span><br><span class="line">  title = <span class="string">&#x27;Parent calls an @ViewChild()&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ViewChild</span>(<span class="title class_">ChildComponent</span>, &#123;<span class="attr">static</span>:<span class="literal">true</span>&#125;) <span class="attr">child</span>: <span class="title class_">ChildComponent</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">child</span>.<span class="title function_">increment</span>()</span><br><span class="line">  &#125; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="title class_">Cannot</span> read property <span class="string">&#x27;increment&#x27;</span> <span class="keyword">of</span> <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
<p>解决方案是等待Angular初始化视图。Angular在完成视图初始化后会引发AfterViewInit生命周期挂钩。因此，我们可以使用ngAfterViewInit来访问子变量。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">ngAfterViewInit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">child</span>.<span class="title function_">increment</span>()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>现在，代码没有给出任何错误。</p>
<p>上面的代码也将与ngOnInit生命周期挂钩一起使用。但它不能保证一直工作，因为Angular可能不会在引发ngOnInit钩子之前初始化视图的所有部分。因此，最好使用ngAfterViewInit钩子。</p>
<p>此外，ViewChild更新值的时间也取决于静态选项</p>
<h2 id="在ViewChild中使用Static选项"><a href="#在ViewChild中使用Static选项" class="headerlink" title="在ViewChild中使用Static选项"></a>在ViewChild中使用Static选项</h2><p>我们在上面的代码中使用了{static:true}。</p>
<p>static选项确定ViewChild查询解析的时间。</p>
<ul>
<li><p>static:true 将在每次变更改检测之前解析ViewChild。</p>
</li>
<li><p>static:false 将在每次变更改检测之后解析ViewChild。</p>
</li>
</ul>
<p>当动态渲染子对象时，static的值变得很重要。例如在ngIf或ngSwitch等内部。</p>
<p>例如，考虑下面的代码，我们子组件放在ngIf中</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//child.component.html</span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>ViewChild Example<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;showCounter&quot;</span> <span class="attr">name</span>=<span class="string">&quot;showCounter&quot;</span> [(<span class="attr">ngModel</span>)]=<span class="string">&quot;showCounter&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">ng-container</span>  *<span class="attr">ngIf</span>=<span class="string">&quot;showCounter&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span> current count is &#123;&#123;child?.count&#125;&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> (<span class="attr">click</span>)=<span class="string">&quot;increment()&quot;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> (<span class="attr">click</span>)=<span class="string">&quot;decrement()&quot;</span>&gt;</span>decrement<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">child-component</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">ng-container</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//child.component.ts</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span>, <span class="title class_">ViewChild</span>, <span class="title class_">AfterViewInit</span>, <span class="title class_">OnInit</span>, <span class="title class_">ChangeDetectorRef</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ChildComponent</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./child.component&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-root&#x27;</span>,</span><br><span class="line">  <span class="attr">templateUrl</span>: <span class="string">&#x27;app.component.html&#x27;</span> ,</span><br><span class="line">  <span class="attr">styleUrls</span>: [<span class="string">&#x27;./app.component.css&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppComponent</span> &#123;</span><br><span class="line">  title = <span class="string">&#x27;ViewChild Example)&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="attr">showCounter</span>: <span class="built_in">boolean</span> = <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line">  <span class="meta">@ViewChild</span>(<span class="title class_">ChildComponent</span>, &#123; <span class="attr">static</span>: <span class="literal">true</span> &#125;) <span class="attr">child</span>: <span class="title class_">ChildComponent</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">child</span>.<span class="title function_">increment</span>();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="title function_">decrement</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">child</span>.<span class="title function_">decrement</span>();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码导致TypeError:无法读取未定义的属性“increment”。即使我们将true赋值给showCounter，也会发生错误。<br>因为在上述情况下，Angular不会立即渲染子组件。但在第一次变更检测之后，angular会检测showCounter的值并渲染子组件。</p>
<p>由于我们使用了static:true，angular将在运行第一次更改检测之前尝试解析ViewChild。因此，child变量总是未定义的。<br>现在，更改static：false。现在，代码将正常工作。也就是说，因为在每次检测到更改之后，Angular都会更新ViewChild。</p>
<h2 id="在-ViewChild-中使用-Read选项"><a href="#在-ViewChild-中使用-Read选项" class="headerlink" title="在 ViewChild 中使用 Read选项"></a>在 ViewChild 中使用 Read选项</h2><p>单个元素可以与多种类型相关联。</p>
<p>例如，考虑以下代码#nameInput模板变量现在与input和ngModel都关联</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> #<span class="attr">nameInput</span> [(<span class="attr">ngModel</span>)]=<span class="string">&quot;name&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面的viewChild代码将input元素的实例作为elementRef返回。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ViewChild</span>(<span class="string">&#x27;nameInput&#x27;</span>,&#123;<span class="attr">static</span>:<span class="literal">false</span>&#125;) nameVar;</span><br></pre></td></tr></table></figure>

<p>如果我们想获得ngModel的实例，那么我们使用Read选项指定需要的令牌类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ViewChild</span>(<span class="string">&#x27;nameInput&#x27;</span>,&#123;<span class="attr">static</span>:<span class="literal">false</span>, <span class="attr">read</span>: <span class="title class_">NgModel</span>&#125;) inRef;</span><br><span class="line"><span class="meta">@ViewChild</span>(<span class="string">&#x27;nameInput&#x27;</span>,&#123;<span class="attr">static</span>:<span class="literal">false</span>, <span class="attr">read</span>: <span class="title class_">ElementRef</span>&#125;) elRef;</span><br><span class="line"><span class="meta">@ViewChild</span>(<span class="string">&#x27;nameInput&#x27;</span>, &#123;<span class="attr">static</span>:<span class="literal">false</span>, <span class="attr">read</span>: <span class="title class_">ViewContainerRef</span> &#125;) vcRef;</span><br></pre></td></tr></table></figure>

<p>Angular中的每个元素总是有一个ElementRef和ViewContainerRef与之关联。如果该元素是一个组件或指令，那么总是有组件或指令实例。您也可以对一个元素应用多个指令。<br>不带read令牌的ViewChild默认返回值类型为组件，如果返回值不是组件类型则返回elementRef类型。</p>
<h2 id="从子组件注入提供程序"><a href="#从子组件注入提供程序" class="headerlink" title="从子组件注入提供程序"></a>从子组件注入提供程序</h2><p>您还可以注入子组件中提供的服务。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ViewChild</span>, <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-child&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;h1&gt;Child With Provider&lt;/h1&gt;`</span>,</span><br><span class="line">  <span class="attr">providers</span>: [&#123; <span class="attr">provide</span>: <span class="string">&#x27;Token&#x27;</span>, <span class="attr">useValue</span>: <span class="string">&#x27;Value&#x27;</span> &#125;]</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ChildComponent</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在父组件中，可以使用read属性访问提供程序</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ViewChild</span>, <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-root&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;app-child&gt;&lt;/app-child&gt;`</span>,</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppComponent</span>&#123;</span><br><span class="line">    <span class="meta">@ViewChild</span>(<span class="title class_">ChildComponent</span> , &#123; <span class="attr">read</span>:<span class="string">&#x27;Token&#x27;</span>, <span class="attr">static</span>:<span class="literal">false</span> &#125; ) <span class="attr">childToken</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
